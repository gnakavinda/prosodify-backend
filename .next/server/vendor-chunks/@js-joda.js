"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@js-joda";
exports.ids = ["vendor-chunks/@js-joda"];
exports.modules = {

/***/ "(rsc)/./node_modules/@js-joda/core/dist/js-joda.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@js-joda/core/dist/js-joda.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArithmeticException: () => (/* binding */ ArithmeticException),\n/* harmony export */   ChronoField: () => (/* binding */ ChronoField),\n/* harmony export */   ChronoLocalDate: () => (/* binding */ ChronoLocalDate),\n/* harmony export */   ChronoLocalDateTime: () => (/* binding */ ChronoLocalDateTime),\n/* harmony export */   ChronoUnit: () => (/* binding */ ChronoUnit),\n/* harmony export */   ChronoZonedDateTime: () => (/* binding */ ChronoZonedDateTime),\n/* harmony export */   Clock: () => (/* binding */ Clock),\n/* harmony export */   DateTimeException: () => (/* binding */ DateTimeException),\n/* harmony export */   DateTimeFormatter: () => (/* binding */ DateTimeFormatter),\n/* harmony export */   DateTimeFormatterBuilder: () => (/* binding */ DateTimeFormatterBuilder),\n/* harmony export */   DateTimeParseException: () => (/* binding */ DateTimeParseException),\n/* harmony export */   DayOfWeek: () => (/* binding */ DayOfWeek),\n/* harmony export */   DecimalStyle: () => (/* binding */ DecimalStyle),\n/* harmony export */   Duration: () => (/* binding */ Duration),\n/* harmony export */   IllegalArgumentException: () => (/* binding */ IllegalArgumentException),\n/* harmony export */   IllegalStateException: () => (/* binding */ IllegalStateException),\n/* harmony export */   Instant: () => (/* binding */ Instant),\n/* harmony export */   IsoChronology: () => (/* binding */ IsoChronology),\n/* harmony export */   IsoFields: () => (/* binding */ IsoFields),\n/* harmony export */   LocalDate: () => (/* binding */ LocalDate),\n/* harmony export */   LocalDateTime: () => (/* binding */ LocalDateTime),\n/* harmony export */   LocalTime: () => (/* binding */ LocalTime),\n/* harmony export */   Month: () => (/* binding */ Month),\n/* harmony export */   MonthDay: () => (/* binding */ MonthDay),\n/* harmony export */   NullPointerException: () => (/* binding */ NullPointerException),\n/* harmony export */   OffsetDateTime: () => (/* binding */ OffsetDateTime),\n/* harmony export */   OffsetTime: () => (/* binding */ OffsetTime),\n/* harmony export */   ParsePosition: () => (/* binding */ ParsePosition),\n/* harmony export */   Period: () => (/* binding */ Period),\n/* harmony export */   ResolverStyle: () => (/* binding */ ResolverStyle),\n/* harmony export */   SignStyle: () => (/* binding */ SignStyle),\n/* harmony export */   Temporal: () => (/* binding */ Temporal),\n/* harmony export */   TemporalAccessor: () => (/* binding */ TemporalAccessor),\n/* harmony export */   TemporalAdjuster: () => (/* binding */ TemporalAdjuster),\n/* harmony export */   TemporalAdjusters: () => (/* binding */ TemporalAdjusters),\n/* harmony export */   TemporalAmount: () => (/* binding */ TemporalAmount),\n/* harmony export */   TemporalField: () => (/* binding */ TemporalField),\n/* harmony export */   TemporalQueries: () => (/* binding */ TemporalQueries),\n/* harmony export */   TemporalQuery: () => (/* binding */ TemporalQuery),\n/* harmony export */   TemporalUnit: () => (/* binding */ TemporalUnit),\n/* harmony export */   TextStyle: () => (/* binding */ TextStyle),\n/* harmony export */   UnsupportedTemporalTypeException: () => (/* binding */ UnsupportedTemporalTypeException),\n/* harmony export */   ValueRange: () => (/* binding */ ValueRange),\n/* harmony export */   Year: () => (/* binding */ Year),\n/* harmony export */   YearConstants: () => (/* binding */ YearConstants),\n/* harmony export */   YearMonth: () => (/* binding */ YearMonth),\n/* harmony export */   ZoneId: () => (/* binding */ ZoneId),\n/* harmony export */   ZoneOffset: () => (/* binding */ ZoneOffset),\n/* harmony export */   ZoneOffsetTransition: () => (/* binding */ ZoneOffsetTransition),\n/* harmony export */   ZoneRegion: () => (/* binding */ ZoneRegion),\n/* harmony export */   ZoneRules: () => (/* binding */ ZoneRules),\n/* harmony export */   ZoneRulesProvider: () => (/* binding */ ZoneRulesProvider),\n/* harmony export */   ZonedDateTime: () => (/* binding */ ZonedDateTime),\n/* harmony export */   _: () => (/* binding */ _),\n/* harmony export */   convert: () => (/* binding */ convert),\n/* harmony export */   nativeJs: () => (/* binding */ nativeJs),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\n//! @version @js-joda/core - 5.6.5\n//! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors\n//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ function createErrorType(name, init, superErrorClass) {\n    if (superErrorClass === void 0) {\n        superErrorClass = Error;\n    }\n    function JsJodaException(message) {\n        if (!Error.captureStackTrace) {\n            this.stack = new Error().stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        this.message = message;\n        init && init.apply(this, arguments);\n        this.toString = function() {\n            return this.name + \": \" + this.message;\n        };\n    }\n    JsJodaException.prototype = Object.create(superErrorClass.prototype);\n    JsJodaException.prototype.name = name;\n    JsJodaException.prototype.constructor = JsJodaException;\n    return JsJodaException;\n}\nvar DateTimeException = createErrorType(\"DateTimeException\", messageWithCause);\nvar DateTimeParseException = createErrorType(\"DateTimeParseException\", messageForDateTimeParseException);\nvar UnsupportedTemporalTypeException = createErrorType(\"UnsupportedTemporalTypeException\", null, DateTimeException);\nvar ArithmeticException = createErrorType(\"ArithmeticException\");\nvar IllegalArgumentException = createErrorType(\"IllegalArgumentException\");\nvar IllegalStateException = createErrorType(\"IllegalStateException\");\nvar NullPointerException = createErrorType(\"NullPointerException\");\nfunction messageWithCause(message, cause) {\n    if (cause === void 0) {\n        cause = null;\n    }\n    var msg = message || this.name;\n    if (cause !== null && cause instanceof Error) {\n        msg += \"\\n-------\\nCaused by: \" + cause.stack + \"\\n-------\\n\";\n    }\n    this.message = msg;\n}\nfunction messageForDateTimeParseException(message, text, index, cause) {\n    if (text === void 0) {\n        text = \"\";\n    }\n    if (index === void 0) {\n        index = 0;\n    }\n    if (cause === void 0) {\n        cause = null;\n    }\n    var msg = message || this.name;\n    msg += \": \" + text + \", at index: \" + index;\n    if (cause !== null && cause instanceof Error) {\n        msg += \"\\n-------\\nCaused by: \" + cause.stack + \"\\n-------\\n\";\n    }\n    this.message = msg;\n    this.parsedString = function() {\n        return text;\n    };\n    this.errorIndex = function() {\n        return index;\n    };\n}\nfunction _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ function assert(assertion, msg, error) {\n    if (!assertion) {\n        if (error) {\n            throw new error(msg);\n        } else {\n            throw new Error(msg);\n        }\n    }\n}\nfunction requireNonNull(value, parameterName) {\n    if (value == null) {\n        throw new NullPointerException(parameterName + \" must not be null\");\n    }\n    return value;\n}\nfunction requireInstance(value, _class, parameterName) {\n    if (!(value instanceof _class)) {\n        throw new IllegalArgumentException(parameterName + \" must be an instance of \" + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? \", but is \" + value.constructor.name : \"\"));\n    }\n    return value;\n}\nfunction abstractMethodFail(methodName) {\n    throw new TypeError('abstract method \"' + methodName + '\" is not implemented');\n}\nvar assert$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    abstractMethodFail: abstractMethodFail,\n    assert: assert,\n    requireInstance: requireInstance,\n    requireNonNull: requireNonNull\n});\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var MAX_SAFE_INTEGER = 9007199254740991;\nvar MIN_SAFE_INTEGER = -9007199254740991;\nvar MathUtil = function() {\n    function MathUtil() {}\n    MathUtil.intDiv = function intDiv(x, y) {\n        var r = x / y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    };\n    MathUtil.intMod = function intMod(x, y) {\n        var r = x - MathUtil.intDiv(x, y) * y;\n        r = MathUtil.roundDown(r);\n        return MathUtil.safeZero(r);\n    };\n    MathUtil.roundDown = function roundDown(r) {\n        if (r < 0) {\n            return Math.ceil(r);\n        } else {\n            return Math.floor(r);\n        }\n    };\n    MathUtil.floorDiv = function floorDiv(x, y) {\n        var r = Math.floor(x / y);\n        return MathUtil.safeZero(r);\n    };\n    MathUtil.floorMod = function floorMod(x, y) {\n        var r = x - MathUtil.floorDiv(x, y) * y;\n        return MathUtil.safeZero(r);\n    };\n    MathUtil.safeAdd = function safeAdd(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        var r = MathUtil.safeToInt(x + y);\n        if (r === x || r === y) {\n            throw new ArithmeticException(\"Invalid addition beyond MAX_SAFE_INTEGER!\");\n        }\n        return r;\n    };\n    MathUtil.safeSubtract = function safeSubtract(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 0 && y === 0) {\n            return 0;\n        } else if (x === 0) {\n            return MathUtil.safeZero(-1 * y);\n        } else if (y === 0) {\n            return MathUtil.safeZero(x);\n        }\n        return MathUtil.safeToInt(x - y);\n    };\n    MathUtil.safeMultiply = function safeMultiply(x, y) {\n        MathUtil.verifyInt(x);\n        MathUtil.verifyInt(y);\n        if (x === 1) {\n            return MathUtil.safeZero(y);\n        }\n        if (y === 1) {\n            return MathUtil.safeZero(x);\n        }\n        if (x === 0 || y === 0) {\n            return 0;\n        }\n        var r = MathUtil.safeToInt(x * y);\n        if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {\n            throw new ArithmeticException(\"Multiplication overflows: \" + x + \" * \" + y);\n        }\n        return r;\n    };\n    MathUtil.parseInt = function(_parseInt) {\n        function parseInt1(_x) {\n            return _parseInt.apply(this, arguments);\n        }\n        parseInt1.toString = function() {\n            return _parseInt.toString();\n        };\n        return parseInt1;\n    }(function(value) {\n        var r = parseInt(value);\n        return MathUtil.safeToInt(r);\n    });\n    MathUtil.safeToInt = function safeToInt(value) {\n        MathUtil.verifyInt(value);\n        return MathUtil.safeZero(value);\n    };\n    MathUtil.verifyInt = function verifyInt(value) {\n        if (value == null) {\n            throw new ArithmeticException(\"Invalid value: '\" + value + \"', using null or undefined as argument\");\n        }\n        if (isNaN(value)) {\n            throw new ArithmeticException(\"Invalid int value, using NaN as argument\");\n        }\n        if (Number.isInteger) {\n            if (!Number.isInteger(Number(value))) {\n                throw new ArithmeticException(\"Invalid value: '\" + value + \"' is a float\");\n            }\n        } else if (value % 1 !== 0) {\n            throw new ArithmeticException(\"Invalid value: '\" + value + \"' is a float\");\n        }\n        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {\n            throw new ArithmeticException(\"Calculation overflows an int: \" + value);\n        }\n    };\n    MathUtil.safeZero = function safeZero(value) {\n        return value === 0 ? 0 : +value;\n    };\n    MathUtil.compareNumbers = function compareNumbers(a, b) {\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    };\n    MathUtil.smi = function smi(int) {\n        return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;\n    };\n    MathUtil.hash = function hash(number) {\n        if (number !== number || number === Infinity) {\n            return 0;\n        }\n        var result = number;\n        while(number > 0xFFFFFFFF){\n            number /= 0xFFFFFFFF;\n            result ^= number;\n        }\n        return MathUtil.smi(result);\n    };\n    MathUtil.hashCode = function hashCode() {\n        var result = 17;\n        for(var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++){\n            numbers[_key] = arguments[_key];\n        }\n        for(var _i = 0, _numbers = numbers; _i < _numbers.length; _i++){\n            var n = _numbers[_i];\n            result = (result << 5) - result + MathUtil.hash(n);\n        }\n        return MathUtil.hash(result);\n    };\n    return MathUtil;\n}();\nMathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nMathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var Enum = function() {\n    function Enum(name) {\n        this._name = name;\n    }\n    var _proto = Enum.prototype;\n    _proto.equals = function equals(other) {\n        return this === other;\n    };\n    _proto.toString = function toString() {\n        return this._name;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return Enum;\n}();\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var TemporalAmount = function() {\n    function TemporalAmount() {}\n    var _proto = TemporalAmount.prototype;\n    _proto.get = function get(unit) {\n        abstractMethodFail(\"get\");\n    };\n    _proto.units = function units() {\n        abstractMethodFail(\"units\");\n    };\n    _proto.addTo = function addTo(temporal) {\n        abstractMethodFail(\"addTo\");\n    };\n    _proto.subtractFrom = function subtractFrom(temporal) {\n        abstractMethodFail(\"subtractFrom\");\n    };\n    return TemporalAmount;\n}();\nif (typeof Symbol !== \"undefined\" && Symbol.toPrimitive) {\n    TemporalAmount.prototype[Symbol.toPrimitive] = function(hint) {\n        if (hint !== \"number\") {\n            return this.toString();\n        }\n        throw new TypeError(\"A conversion from TemporalAmount to a number is not allowed. \" + \"To compare use the methods .equals(), .compareTo(), .isBefore() \" + \"or one that is more suitable to your use case.\");\n    };\n}\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var TemporalUnit = function() {\n    function TemporalUnit() {}\n    var _proto = TemporalUnit.prototype;\n    _proto.duration = function duration() {\n        abstractMethodFail(\"duration\");\n    };\n    _proto.isDurationEstimated = function isDurationEstimated() {\n        abstractMethodFail(\"isDurationEstimated\");\n    };\n    _proto.isDateBased = function isDateBased() {\n        abstractMethodFail(\"isDateBased\");\n    };\n    _proto.isTimeBased = function isTimeBased() {\n        abstractMethodFail(\"isTimeBased\");\n    };\n    _proto.isSupportedBy = function isSupportedBy(temporal) {\n        abstractMethodFail(\"isSupportedBy\");\n    };\n    _proto.addTo = function addTo(dateTime, periodToAdd) {\n        abstractMethodFail(\"addTo\");\n    };\n    _proto.between = function between(temporal1, temporal2) {\n        abstractMethodFail(\"between\");\n    };\n    return TemporalUnit;\n}();\nvar Duration = function(_TemporalAmount) {\n    _inheritsLoose(Duration, _TemporalAmount);\n    function Duration(seconds, nanos) {\n        var _this;\n        _this = _TemporalAmount.call(this) || this;\n        _this._seconds = MathUtil.safeToInt(seconds);\n        _this._nanos = MathUtil.safeToInt(nanos);\n        return _this;\n    }\n    Duration.ofDays = function ofDays(days) {\n        return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);\n    };\n    Duration.ofHours = function ofHours(hours) {\n        return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);\n    };\n    Duration.ofMinutes = function ofMinutes(minutes) {\n        return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);\n    };\n    Duration.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {\n        if (nanoAdjustment === void 0) {\n            nanoAdjustment = 0;\n        }\n        var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));\n        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Duration._create(secs, nos);\n    };\n    Duration.ofMillis = function ofMillis(millis) {\n        var secs = MathUtil.intDiv(millis, 1000);\n        var mos = MathUtil.intMod(millis, 1000);\n        if (mos < 0) {\n            mos += 1000;\n            secs--;\n        }\n        return Duration._create(secs, mos * 1000000);\n    };\n    Duration.ofNanos = function ofNanos(nanos) {\n        var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);\n        var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);\n        if (nos < 0) {\n            nos += LocalTime.NANOS_PER_SECOND;\n            secs--;\n        }\n        return this._create(secs, nos);\n    };\n    Duration.of = function of(amount, unit) {\n        return Duration.ZERO.plus(amount, unit);\n    };\n    Duration.from = function from(amount) {\n        requireNonNull(amount, \"amount\");\n        requireInstance(amount, TemporalAmount);\n        var duration = Duration.ZERO;\n        amount.units().forEach(function(unit) {\n            duration = duration.plus(amount.get(unit), unit);\n        });\n        return duration;\n    };\n    Duration.between = function between(startInclusive, endExclusive) {\n        requireNonNull(startInclusive, \"startInclusive\");\n        requireNonNull(endExclusive, \"endExclusive\");\n        var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);\n        var nanos = 0;\n        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {\n            try {\n                var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);\n                nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;\n                if (secs > 0 && nanos < 0) {\n                    nanos += LocalTime.NANOS_PER_SECOND;\n                } else if (secs < 0 && nanos > 0) {\n                    nanos -= LocalTime.NANOS_PER_SECOND;\n                } else if (secs === 0 && nanos !== 0) {\n                    var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);\n                    secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);\n                }\n            } catch (e) {}\n        }\n        return this.ofSeconds(secs, nanos);\n    };\n    Duration.parse = function parse(text) {\n        requireNonNull(text, \"text\");\n        var PATTERN = new RegExp(\"([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?\", \"i\");\n        var matches = PATTERN.exec(text);\n        if (matches !== null) {\n            if (\"T\" === matches[3] === false) {\n                var negate = \"-\" === matches[1];\n                var dayMatch = matches[2];\n                var hourMatch = matches[4];\n                var minuteMatch = matches[5];\n                var secondMatch = matches[6];\n                var fractionMatch = matches[7];\n                if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {\n                    var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, \"days\");\n                    var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, \"hours\");\n                    var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, \"minutes\");\n                    var seconds = Duration._parseNumber(text, secondMatch, 1, \"seconds\");\n                    var negativeSecs = secondMatch != null && secondMatch.charAt(0) === \"-\";\n                    var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);\n                    try {\n                        return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);\n                    } catch (ex) {\n                        throw new DateTimeParseException(\"Text cannot be parsed to a Duration: overflow\", text, 0, ex);\n                    }\n                }\n            }\n        }\n        throw new DateTimeParseException(\"Text cannot be parsed to a Duration\", text, 0);\n    };\n    Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {\n        if (parsed == null) {\n            return 0;\n        }\n        try {\n            if (parsed[0] === \"+\") {\n                parsed = parsed.substring(1);\n            }\n            return MathUtil.safeMultiply(parseFloat(parsed), multiplier);\n        } catch (ex) {\n            throw new DateTimeParseException(\"Text cannot be parsed to a Duration: \" + errorText, text, 0, ex);\n        }\n    };\n    Duration._parseFraction = function _parseFraction(text, parsed, negate) {\n        if (parsed == null || parsed.length === 0) {\n            return 0;\n        }\n        parsed = (parsed + \"000000000\").substring(0, 9);\n        return parseFloat(parsed) * negate;\n    };\n    Duration._create = function _create() {\n        if (arguments.length <= 2) {\n            return Duration._createSecondsNanos(arguments[0], arguments[1]);\n        } else {\n            return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n        }\n    };\n    Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {\n        var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));\n        if (negate) {\n            return Duration.ofSeconds(seconds, nanos).negated();\n        }\n        return Duration.ofSeconds(seconds, nanos);\n    };\n    Duration._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {\n        if (seconds === void 0) {\n            seconds = 0;\n        }\n        if (nanoAdjustment === void 0) {\n            nanoAdjustment = 0;\n        }\n        if (seconds === 0 && nanoAdjustment === 0) {\n            return Duration.ZERO;\n        }\n        return new Duration(seconds, nanoAdjustment);\n    };\n    var _proto = Duration.prototype;\n    _proto.get = function get(unit) {\n        if (unit === ChronoUnit.SECONDS) {\n            return this._seconds;\n        } else if (unit === ChronoUnit.NANOS) {\n            return this._nanos;\n        } else {\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n    };\n    _proto.units = function units() {\n        return [\n            ChronoUnit.SECONDS,\n            ChronoUnit.NANOS\n        ];\n    };\n    _proto.isZero = function isZero() {\n        return this._seconds === 0 && this._nanos === 0;\n    };\n    _proto.isNegative = function isNegative() {\n        return this._seconds < 0;\n    };\n    _proto.seconds = function seconds() {\n        return this._seconds;\n    };\n    _proto.nano = function nano() {\n        return this._nanos;\n    };\n    _proto.withSeconds = function withSeconds(seconds) {\n        return Duration._create(seconds, this._nanos);\n    };\n    _proto.withNanos = function withNanos(nanoOfSecond) {\n        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);\n        return Duration._create(this._seconds, nanoOfSecond);\n    };\n    _proto.plusDuration = function plusDuration(duration) {\n        requireNonNull(duration, \"duration\");\n        return this.plus(duration.seconds(), duration.nano());\n    };\n    _proto.plus = function plus(durationOrNumber, unitOrNumber) {\n        if (arguments.length === 1) {\n            return this.plusDuration(durationOrNumber);\n        } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {\n            return this.plusAmountUnit(durationOrNumber, unitOrNumber);\n        } else {\n            return this.plusSecondsNanos(durationOrNumber, unitOrNumber);\n        }\n    };\n    _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, \"amountToAdd\");\n        requireNonNull(unit, \"unit\");\n        if (unit === ChronoUnit.DAYS) {\n            return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);\n        }\n        if (unit.isDurationEstimated()) {\n            throw new UnsupportedTemporalTypeException(\"Unit must not have an estimated duration\");\n        }\n        if (amountToAdd === 0) {\n            return this;\n        }\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.NANOS:\n                    return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS:\n                    return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);\n                case ChronoUnit.MILLIS:\n                    return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS:\n                    return this.plusSeconds(amountToAdd);\n            }\n            return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);\n        }\n        var duration = unit.duration().multipliedBy(amountToAdd);\n        return this.plusSecondsNanos(duration.seconds(), duration.nano());\n    };\n    _proto.plusDays = function plusDays(daysToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);\n    };\n    _proto.plusHours = function plusHours(hoursToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);\n    };\n    _proto.plusMinutes = function plusMinutes(minutesToAdd) {\n        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);\n    };\n    _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n        return this.plusSecondsNanos(secondsToAdd, 0);\n    };\n    _proto.plusMillis = function plusMillis(millisToAdd) {\n        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);\n    };\n    _proto.plusNanos = function plusNanos(nanosToAdd) {\n        return this.plusSecondsNanos(0, nanosToAdd);\n    };\n    _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {\n        requireNonNull(secondsToAdd, \"secondsToAdd\");\n        requireNonNull(nanosToAdd, \"nanosToAdd\");\n        if (secondsToAdd === 0 && nanosToAdd === 0) {\n            return this;\n        }\n        var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);\n        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));\n        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);\n        return Duration.ofSeconds(epochSec, nanoAdjustment);\n    };\n    _proto.minus = function minus(durationOrNumber, unit) {\n        if (arguments.length === 1) {\n            return this.minusDuration(durationOrNumber);\n        } else {\n            return this.minusAmountUnit(durationOrNumber, unit);\n        }\n    };\n    _proto.minusDuration = function minusDuration(duration) {\n        requireNonNull(duration, \"duration\");\n        var secsToSubtract = duration.seconds();\n        var nanosToSubtract = duration.nano();\n        if (secsToSubtract === MIN_SAFE_INTEGER) {\n            return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);\n        }\n        return this.plus(-secsToSubtract, -nanosToSubtract);\n    };\n    _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, \"amountToSubtract\");\n        requireNonNull(unit, \"unit\");\n        return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);\n    };\n    _proto.minusDays = function minusDays(daysToSubtract) {\n        return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);\n    };\n    _proto.minusHours = function minusHours(hoursToSubtract) {\n        return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);\n    };\n    _proto.minusMinutes = function minusMinutes(minutesToSubtract) {\n        return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);\n    };\n    _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n        return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);\n    };\n    _proto.minusMillis = function minusMillis(millisToSubtract) {\n        return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);\n    };\n    _proto.minusNanos = function minusNanos(nanosToSubtract) {\n        return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);\n    };\n    _proto.multipliedBy = function multipliedBy(multiplicand) {\n        if (multiplicand === 0) {\n            return Duration.ZERO;\n        }\n        if (multiplicand === 1) {\n            return this;\n        }\n        var secs = MathUtil.safeMultiply(this._seconds, multiplicand);\n        var nos = MathUtil.safeMultiply(this._nanos, multiplicand);\n        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);\n        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);\n        return Duration.ofSeconds(secs, nos);\n    };\n    _proto.dividedBy = function dividedBy(divisor) {\n        if (divisor === 0) {\n            throw new ArithmeticException(\"Cannot divide by zero\");\n        }\n        if (divisor === 1) {\n            return this;\n        }\n        var secs = MathUtil.intDiv(this._seconds, divisor);\n        var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);\n        var nos = MathUtil.intDiv(this._nanos, divisor);\n        nos = secsMod + nos;\n        return Duration.ofSeconds(secs, nos);\n    };\n    _proto.negated = function negated() {\n        return this.multipliedBy(-1);\n    };\n    _proto.abs = function abs() {\n        return this.isNegative() ? this.negated() : this;\n    };\n    _proto.addTo = function addTo(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (this._seconds !== 0) {\n            temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    };\n    _proto.subtractFrom = function subtractFrom(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (this._seconds !== 0) {\n            temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);\n        }\n        if (this._nanos !== 0) {\n            temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);\n        }\n        return temporal;\n    };\n    _proto.toDays = function toDays() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);\n    };\n    _proto.toHours = function toHours() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n    };\n    _proto.toMinutes = function toMinutes() {\n        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n    };\n    _proto.toMillis = function toMillis() {\n        var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));\n        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));\n        return millis;\n    };\n    _proto.toNanos = function toNanos() {\n        var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);\n        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);\n        return totalNanos;\n    };\n    _proto.compareTo = function compareTo(otherDuration) {\n        requireNonNull(otherDuration, \"otherDuration\");\n        requireInstance(otherDuration, Duration, \"otherDuration\");\n        var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherDuration.nano();\n    };\n    _proto.equals = function equals(otherDuration) {\n        if (this === otherDuration) {\n            return true;\n        }\n        if (otherDuration instanceof Duration) {\n            return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();\n        }\n        return false;\n    };\n    _proto.toString = function toString() {\n        if (this === Duration.ZERO) {\n            return \"PT0S\";\n        }\n        var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);\n        var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);\n        var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);\n        var rval = \"PT\";\n        if (hours !== 0) {\n            rval += hours + \"H\";\n        }\n        if (minutes !== 0) {\n            rval += minutes + \"M\";\n        }\n        if (secs === 0 && this._nanos === 0 && rval.length > 2) {\n            return rval;\n        }\n        if (secs < 0 && this._nanos > 0) {\n            if (secs === -1) {\n                rval += \"-0\";\n            } else {\n                rval += secs + 1;\n            }\n        } else {\n            rval += secs;\n        }\n        if (this._nanos > 0) {\n            rval += \".\";\n            var nanoString;\n            if (secs < 0) {\n                nanoString = \"\" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);\n            } else {\n                nanoString = \"\" + (LocalTime.NANOS_PER_SECOND + this._nanos);\n            }\n            nanoString = nanoString.slice(1, nanoString.length);\n            rval += nanoString;\n            while(rval.charAt(rval.length - 1) === \"0\"){\n                rval = rval.slice(0, rval.length - 1);\n            }\n        }\n        rval += \"S\";\n        return rval;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return Duration;\n}(TemporalAmount);\nfunction _init$n() {\n    Duration.ZERO = new Duration(0, 0);\n}\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)\n */ var YearConstants = function YearConstants() {};\nfunction _init$m() {\n    YearConstants.MIN_VALUE = -999999;\n    YearConstants.MAX_VALUE = 999999;\n}\nvar ChronoUnit = function(_TemporalUnit) {\n    _inheritsLoose(ChronoUnit, _TemporalUnit);\n    function ChronoUnit(name, estimatedDuration) {\n        var _this;\n        _this = _TemporalUnit.call(this) || this;\n        _this._name = name;\n        _this._duration = estimatedDuration;\n        return _this;\n    }\n    var _proto = ChronoUnit.prototype;\n    _proto.duration = function duration() {\n        return this._duration;\n    };\n    _proto.isDurationEstimated = function isDurationEstimated() {\n        return this.isDateBased() || this === ChronoUnit.FOREVER;\n    };\n    _proto.isDateBased = function isDateBased() {\n        return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;\n    };\n    _proto.isTimeBased = function isTimeBased() {\n        return this.compareTo(ChronoUnit.DAYS) < 0;\n    };\n    _proto.isSupportedBy = function isSupportedBy(temporal) {\n        if (this === ChronoUnit.FOREVER) {\n            return false;\n        }\n        try {\n            temporal.plus(1, this);\n            return true;\n        } catch (e) {\n            try {\n                temporal.plus(-1, this);\n                return true;\n            } catch (e2) {\n                return false;\n            }\n        }\n    };\n    _proto.addTo = function addTo(temporal, amount) {\n        return temporal.plus(amount, this);\n    };\n    _proto.between = function between(temporal1, temporal2) {\n        return temporal1.until(temporal2, this);\n    };\n    _proto.toString = function toString() {\n        return this._name;\n    };\n    _proto.compareTo = function compareTo(other) {\n        return this.duration().compareTo(other.duration());\n    };\n    return ChronoUnit;\n}(TemporalUnit);\nfunction _init$l() {\n    ChronoUnit.NANOS = new ChronoUnit(\"Nanos\", Duration.ofNanos(1));\n    ChronoUnit.MICROS = new ChronoUnit(\"Micros\", Duration.ofNanos(1000));\n    ChronoUnit.MILLIS = new ChronoUnit(\"Millis\", Duration.ofNanos(1000000));\n    ChronoUnit.SECONDS = new ChronoUnit(\"Seconds\", Duration.ofSeconds(1));\n    ChronoUnit.MINUTES = new ChronoUnit(\"Minutes\", Duration.ofSeconds(60));\n    ChronoUnit.HOURS = new ChronoUnit(\"Hours\", Duration.ofSeconds(3600));\n    ChronoUnit.HALF_DAYS = new ChronoUnit(\"HalfDays\", Duration.ofSeconds(43200));\n    ChronoUnit.DAYS = new ChronoUnit(\"Days\", Duration.ofSeconds(86400));\n    ChronoUnit.WEEKS = new ChronoUnit(\"Weeks\", Duration.ofSeconds(7 * 86400));\n    ChronoUnit.MONTHS = new ChronoUnit(\"Months\", Duration.ofSeconds(31556952 / 12));\n    ChronoUnit.YEARS = new ChronoUnit(\"Years\", Duration.ofSeconds(31556952));\n    ChronoUnit.DECADES = new ChronoUnit(\"Decades\", Duration.ofSeconds(31556952 * 10));\n    ChronoUnit.CENTURIES = new ChronoUnit(\"Centuries\", Duration.ofSeconds(31556952 * 100));\n    ChronoUnit.MILLENNIA = new ChronoUnit(\"Millennia\", Duration.ofSeconds(31556952 * 1000));\n    ChronoUnit.ERAS = new ChronoUnit(\"Eras\", Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));\n    ChronoUnit.FOREVER = new ChronoUnit(\"Forever\", Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));\n}\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var TemporalField = function() {\n    function TemporalField() {}\n    var _proto = TemporalField.prototype;\n    _proto.isDateBased = function isDateBased() {\n        abstractMethodFail(\"isDateBased\");\n    };\n    _proto.isTimeBased = function isTimeBased() {\n        abstractMethodFail(\"isTimeBased\");\n    };\n    _proto.baseUnit = function baseUnit() {\n        abstractMethodFail(\"baseUnit\");\n    };\n    _proto.rangeUnit = function rangeUnit() {\n        abstractMethodFail(\"rangeUnit\");\n    };\n    _proto.range = function range() {\n        abstractMethodFail(\"range\");\n    };\n    _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {\n        abstractMethodFail(\"rangeRefinedBy\");\n    };\n    _proto.getFrom = function getFrom(temporal) {\n        abstractMethodFail(\"getFrom\");\n    };\n    _proto.adjustInto = function adjustInto(temporal, newValue) {\n        abstractMethodFail(\"adjustInto\");\n    };\n    _proto.isSupportedBy = function isSupportedBy(temporal) {\n        abstractMethodFail(\"isSupportedBy\");\n    };\n    _proto.displayName = function displayName() {\n        abstractMethodFail(\"displayName\");\n    };\n    _proto.equals = function equals(other) {\n        abstractMethodFail(\"equals\");\n    };\n    _proto.name = function name() {\n        abstractMethodFail(\"name\");\n    };\n    return TemporalField;\n}();\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ValueRange = function() {\n    function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {\n        assert(!(minSmallest > minLargest), \"Smallest minimum value '\" + minSmallest + \"' must be less than largest minimum value '\" + minLargest + \"'\", IllegalArgumentException);\n        assert(!(maxSmallest > maxLargest), \"Smallest maximum value '\" + maxSmallest + \"' must be less than largest maximum value '\" + maxLargest + \"'\", IllegalArgumentException);\n        assert(!(minLargest > maxLargest), \"Minimum value '\" + minLargest + \"' must be less than maximum value '\" + maxLargest + \"'\", IllegalArgumentException);\n        this._minSmallest = minSmallest;\n        this._minLargest = minLargest;\n        this._maxLargest = maxLargest;\n        this._maxSmallest = maxSmallest;\n    }\n    var _proto = ValueRange.prototype;\n    _proto.isFixed = function isFixed() {\n        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;\n    };\n    _proto.minimum = function minimum() {\n        return this._minSmallest;\n    };\n    _proto.largestMinimum = function largestMinimum() {\n        return this._minLargest;\n    };\n    _proto.maximum = function maximum() {\n        return this._maxLargest;\n    };\n    _proto.smallestMaximum = function smallestMaximum() {\n        return this._maxSmallest;\n    };\n    _proto.isValidValue = function isValidValue(value) {\n        return this.minimum() <= value && value <= this.maximum();\n    };\n    _proto.checkValidValue = function checkValidValue(value, field) {\n        var msg;\n        if (!this.isValidValue(value)) {\n            if (field != null) {\n                msg = \"Invalid value for \" + field + \" (valid values \" + this.toString() + \"): \" + value;\n            } else {\n                msg = \"Invalid value (valid values \" + this.toString() + \"): \" + value;\n            }\n            return assert(false, msg, DateTimeException);\n        }\n        return value;\n    };\n    _proto.checkValidIntValue = function checkValidIntValue(value, field) {\n        if (this.isValidIntValue(value) === false) {\n            throw new DateTimeException(\"Invalid int value for \" + field + \": \" + value);\n        }\n        return value;\n    };\n    _proto.isValidIntValue = function isValidIntValue(value) {\n        return this.isIntValue() && this.isValidValue(value);\n    };\n    _proto.isIntValue = function isIntValue() {\n        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;\n    };\n    _proto.equals = function equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ValueRange) {\n            return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);\n    };\n    _proto.toString = function toString() {\n        var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? \"/\" + this.largestMinimum() : \"\");\n        str += \" - \";\n        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? \"/\" + this.maximum() : \"\");\n        return str;\n    };\n    ValueRange.of = function of() {\n        if (arguments.length === 2) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);\n        } else if (arguments.length === 3) {\n            return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);\n        } else if (arguments.length === 4) {\n            return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);\n        } else {\n            return assert(false, \"Invalid number of arguments \" + arguments.length, IllegalArgumentException);\n        }\n    };\n    return ValueRange;\n}();\nvar ChronoField = function(_TemporalField) {\n    _inheritsLoose(ChronoField, _TemporalField);\n    ChronoField.byName = function byName(fieldName) {\n        for(var prop in ChronoField){\n            if (ChronoField[prop]) {\n                if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {\n                    return ChronoField[prop];\n                }\n            }\n        }\n    };\n    function ChronoField(name, baseUnit, rangeUnit, range) {\n        var _this;\n        _this = _TemporalField.call(this) || this;\n        _this._name = name;\n        _this._baseUnit = baseUnit;\n        _this._rangeUnit = rangeUnit;\n        _this._range = range;\n        return _this;\n    }\n    var _proto = ChronoField.prototype;\n    _proto.name = function name() {\n        return this._name;\n    };\n    _proto.baseUnit = function baseUnit() {\n        return this._baseUnit;\n    };\n    _proto.rangeUnit = function rangeUnit() {\n        return this._rangeUnit;\n    };\n    _proto.range = function range() {\n        return this._range;\n    };\n    _proto.displayName = function displayName() {\n        return this.toString();\n    };\n    _proto.checkValidValue = function checkValidValue(value) {\n        return this.range().checkValidValue(value, this);\n    };\n    _proto.checkValidIntValue = function checkValidIntValue(value) {\n        return this.range().checkValidIntValue(value, this);\n    };\n    _proto.isDateBased = function isDateBased() {\n        var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.PROLEPTIC_MONTH || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;\n        return dateBased;\n    };\n    _proto.isTimeBased = function isTimeBased() {\n        var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;\n        return timeBased;\n    };\n    _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {\n        return temporal.range(this);\n    };\n    _proto.getFrom = function getFrom(temporal) {\n        return temporal.getLong(this);\n    };\n    _proto.toString = function toString() {\n        return this.name();\n    };\n    _proto.equals = function equals(other) {\n        return this === other;\n    };\n    _proto.adjustInto = function adjustInto(temporal, newValue) {\n        return temporal.with(this, newValue);\n    };\n    _proto.isSupportedBy = function isSupportedBy(temporal) {\n        return temporal.isSupported(this);\n    };\n    return ChronoField;\n}(TemporalField);\nfunction _init$k() {\n    ChronoField.NANO_OF_SECOND = new ChronoField(\"NanoOfSecond\", ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));\n    ChronoField.NANO_OF_DAY = new ChronoField(\"NanoOfDay\", ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));\n    ChronoField.MICRO_OF_SECOND = new ChronoField(\"MicroOfSecond\", ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));\n    ChronoField.MICRO_OF_DAY = new ChronoField(\"MicroOfDay\", ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));\n    ChronoField.MILLI_OF_SECOND = new ChronoField(\"MilliOfSecond\", ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));\n    ChronoField.MILLI_OF_DAY = new ChronoField(\"MilliOfDay\", ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));\n    ChronoField.SECOND_OF_MINUTE = new ChronoField(\"SecondOfMinute\", ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));\n    ChronoField.SECOND_OF_DAY = new ChronoField(\"SecondOfDay\", ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));\n    ChronoField.MINUTE_OF_HOUR = new ChronoField(\"MinuteOfHour\", ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));\n    ChronoField.MINUTE_OF_DAY = new ChronoField(\"MinuteOfDay\", ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));\n    ChronoField.HOUR_OF_AMPM = new ChronoField(\"HourOfAmPm\", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));\n    ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField(\"ClockHourOfAmPm\", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));\n    ChronoField.HOUR_OF_DAY = new ChronoField(\"HourOfDay\", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));\n    ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField(\"ClockHourOfDay\", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));\n    ChronoField.AMPM_OF_DAY = new ChronoField(\"AmPmOfDay\", ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));\n    ChronoField.DAY_OF_WEEK = new ChronoField(\"DayOfWeek\", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField(\"AlignedDayOfWeekInMonth\", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n    ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField(\"AlignedDayOfWeekInYear\", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));\n    ChronoField.DAY_OF_MONTH = new ChronoField(\"DayOfMonth\", ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), \"day\");\n    ChronoField.DAY_OF_YEAR = new ChronoField(\"DayOfYear\", ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));\n    ChronoField.EPOCH_DAY = new ChronoField(\"EpochDay\", ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));\n    ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField(\"AlignedWeekOfMonth\", ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));\n    ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField(\"AlignedWeekOfYear\", ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));\n    ChronoField.MONTH_OF_YEAR = new ChronoField(\"MonthOfYear\", ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), \"month\");\n    ChronoField.PROLEPTIC_MONTH = new ChronoField(\"ProlepticMonth\", ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));\n    ChronoField.YEAR_OF_ERA = new ChronoField(\"YearOfEra\", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));\n    ChronoField.YEAR = new ChronoField(\"Year\", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), \"year\");\n    ChronoField.ERA = new ChronoField(\"Era\", ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));\n    ChronoField.INSTANT_SECONDS = new ChronoField(\"InstantSeconds\", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));\n    ChronoField.OFFSET_SECONDS = new ChronoField(\"OffsetSeconds\", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));\n}\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var TemporalQueries = function() {\n    function TemporalQueries() {}\n    TemporalQueries.zoneId = function zoneId() {\n        return TemporalQueries.ZONE_ID;\n    };\n    TemporalQueries.chronology = function chronology() {\n        return TemporalQueries.CHRONO;\n    };\n    TemporalQueries.precision = function precision() {\n        return TemporalQueries.PRECISION;\n    };\n    TemporalQueries.zone = function zone() {\n        return TemporalQueries.ZONE;\n    };\n    TemporalQueries.offset = function offset() {\n        return TemporalQueries.OFFSET;\n    };\n    TemporalQueries.localDate = function localDate() {\n        return TemporalQueries.LOCAL_DATE;\n    };\n    TemporalQueries.localTime = function localTime() {\n        return TemporalQueries.LOCAL_TIME;\n    };\n    return TemporalQueries;\n}();\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var TemporalAccessor = function() {\n    function TemporalAccessor() {}\n    var _proto = TemporalAccessor.prototype;\n    _proto.query = function query(_query) {\n        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {\n            return null;\n        }\n        return _query.queryFrom(this);\n    };\n    _proto.get = function get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    };\n    _proto.getLong = function getLong(field) {\n        abstractMethodFail(\"getLong\");\n    };\n    _proto.range = function range(field) {\n        if (field instanceof ChronoField) {\n            if (this.isSupported(field)) {\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    };\n    _proto.isSupported = function isSupported(field) {\n        abstractMethodFail(\"isSupported\");\n    };\n    return TemporalAccessor;\n}();\nvar TemporalQuery = function(_Enum) {\n    _inheritsLoose(TemporalQuery, _Enum);\n    function TemporalQuery() {\n        return _Enum.apply(this, arguments) || this;\n    }\n    var _proto = TemporalQuery.prototype;\n    _proto.queryFrom = function queryFrom(temporal) {\n        abstractMethodFail(\"queryFrom\");\n    };\n    return TemporalQuery;\n}(Enum);\nfunction createTemporalQuery(name, queryFromFunction) {\n    var ExtendedTemporalQuery = function(_TemporalQuery) {\n        _inheritsLoose(ExtendedTemporalQuery, _TemporalQuery);\n        function ExtendedTemporalQuery() {\n            return _TemporalQuery.apply(this, arguments) || this;\n        }\n        return ExtendedTemporalQuery;\n    }(TemporalQuery);\n    ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;\n    return new ExtendedTemporalQuery(name);\n}\nvar DayOfWeek = function(_TemporalAccessor) {\n    _inheritsLoose(DayOfWeek, _TemporalAccessor);\n    function DayOfWeek(ordinal, name) {\n        var _this;\n        _this = _TemporalAccessor.call(this) || this;\n        _this._ordinal = ordinal;\n        _this._name = name;\n        return _this;\n    }\n    var _proto = DayOfWeek.prototype;\n    _proto.ordinal = function ordinal() {\n        return this._ordinal;\n    };\n    _proto.name = function name() {\n        return this._name;\n    };\n    DayOfWeek.values = function values() {\n        return ENUMS.slice();\n    };\n    DayOfWeek.valueOf = function valueOf(name) {\n        var ordinal = 0;\n        for(ordinal; ordinal < ENUMS.length; ordinal++){\n            if (ENUMS[ordinal].name() === name) {\n                break;\n            }\n        }\n        return DayOfWeek.of(ordinal + 1);\n    };\n    DayOfWeek.of = function of(dayOfWeek) {\n        if (dayOfWeek < 1 || dayOfWeek > 7) {\n            throw new DateTimeException(\"Invalid value for DayOfWeek: \" + dayOfWeek);\n        }\n        return ENUMS[dayOfWeek - 1];\n    };\n    DayOfWeek.from = function from(temporal) {\n        assert(temporal != null, \"temporal\", NullPointerException);\n        if (temporal instanceof DayOfWeek) {\n            return temporal;\n        }\n        try {\n            return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));\n        } catch (ex) {\n            if (ex instanceof DateTimeException) {\n                throw new DateTimeException(\"Unable to obtain DayOfWeek from TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : \"\"), ex);\n            } else {\n                throw ex;\n            }\n        }\n    };\n    _proto.value = function value() {\n        return this._ordinal + 1;\n    };\n    _proto.displayName = function displayName(style, locale) {\n        throw new IllegalArgumentException(\"Pattern using (localized) text not implemented yet!\");\n    };\n    _proto.isSupported = function isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.DAY_OF_WEEK;\n        }\n        return field != null && field.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    };\n    _proto.get = function get(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    };\n    _proto.getLong = function getLong(field) {\n        if (field === ChronoField.DAY_OF_WEEK) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.plus = function plus(days) {\n        var amount = MathUtil.floorMod(days, 7);\n        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];\n    };\n    _proto.minus = function minus(days) {\n        return this.plus(-1 * MathUtil.floorMod(days, 7));\n    };\n    _proto.query = function query(_query) {\n        if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n            return null;\n        }\n        assert(_query != null, \"query\", NullPointerException);\n        return _query.queryFrom(this);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());\n    };\n    _proto.equals = function equals(other) {\n        return this === other;\n    };\n    _proto.toString = function toString() {\n        return this._name;\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, DayOfWeek, \"other\");\n        return this._ordinal - other._ordinal;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return DayOfWeek;\n}(TemporalAccessor);\nvar ENUMS;\nfunction _init$j() {\n    DayOfWeek.MONDAY = new DayOfWeek(0, \"MONDAY\");\n    DayOfWeek.TUESDAY = new DayOfWeek(1, \"TUESDAY\");\n    DayOfWeek.WEDNESDAY = new DayOfWeek(2, \"WEDNESDAY\");\n    DayOfWeek.THURSDAY = new DayOfWeek(3, \"THURSDAY\");\n    DayOfWeek.FRIDAY = new DayOfWeek(4, \"FRIDAY\");\n    DayOfWeek.SATURDAY = new DayOfWeek(5, \"SATURDAY\");\n    DayOfWeek.SUNDAY = new DayOfWeek(6, \"SUNDAY\");\n    DayOfWeek.FROM = createTemporalQuery(\"DayOfWeek.FROM\", function(temporal) {\n        return DayOfWeek.from(temporal);\n    });\n    ENUMS = [\n        DayOfWeek.MONDAY,\n        DayOfWeek.TUESDAY,\n        DayOfWeek.WEDNESDAY,\n        DayOfWeek.THURSDAY,\n        DayOfWeek.FRIDAY,\n        DayOfWeek.SATURDAY,\n        DayOfWeek.SUNDAY\n    ];\n}\nvar Month = function(_TemporalAccessor) {\n    _inheritsLoose(Month, _TemporalAccessor);\n    function Month(value, name) {\n        var _this;\n        _this = _TemporalAccessor.call(this) || this;\n        _this._value = MathUtil.safeToInt(value);\n        _this._name = name;\n        return _this;\n    }\n    var _proto = Month.prototype;\n    _proto.value = function value() {\n        return this._value;\n    };\n    _proto.ordinal = function ordinal() {\n        return this._value - 1;\n    };\n    _proto.name = function name() {\n        return this._name;\n    };\n    _proto.displayName = function displayName(style, locale) {\n        throw new IllegalArgumentException(\"Pattern using (localized) text not implemented yet!\");\n    };\n    _proto.isSupported = function isSupported(field) {\n        if (null === field) {\n            return false;\n        }\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR;\n        }\n        return field != null && field.isSupportedBy(this);\n    };\n    _proto.get = function get(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        }\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    };\n    _proto.getLong = function getLong(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return this.value();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.plus = function plus(months) {\n        var amount = MathUtil.intMod(months, 12) + 12;\n        var newMonthVal = MathUtil.intMod(this.value() + amount, 12);\n        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;\n        return Month.of(newMonthVal);\n    };\n    _proto.minus = function minus(months) {\n        return this.plus(-1 * MathUtil.intMod(months, 12));\n    };\n    _proto.length = function length(leapYear) {\n        switch(this){\n            case Month.FEBRUARY:\n                return leapYear ? 29 : 28;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    };\n    _proto.minLength = function minLength() {\n        switch(this){\n            case Month.FEBRUARY:\n                return 28;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    };\n    _proto.maxLength = function maxLength() {\n        switch(this){\n            case Month.FEBRUARY:\n                return 29;\n            case Month.APRIL:\n            case Month.JUNE:\n            case Month.SEPTEMBER:\n            case Month.NOVEMBER:\n                return 30;\n            default:\n                return 31;\n        }\n    };\n    _proto.firstDayOfYear = function firstDayOfYear(leapYear) {\n        var leap = leapYear ? 1 : 0;\n        switch(this){\n            case Month.JANUARY:\n                return 1;\n            case Month.FEBRUARY:\n                return 32;\n            case Month.MARCH:\n                return 60 + leap;\n            case Month.APRIL:\n                return 91 + leap;\n            case Month.MAY:\n                return 121 + leap;\n            case Month.JUNE:\n                return 152 + leap;\n            case Month.JULY:\n                return 182 + leap;\n            case Month.AUGUST:\n                return 213 + leap;\n            case Month.SEPTEMBER:\n                return 244 + leap;\n            case Month.OCTOBER:\n                return 274 + leap;\n            case Month.NOVEMBER:\n                return 305 + leap;\n            case Month.DECEMBER:\n            default:\n                return 335 + leap;\n        }\n    };\n    _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {\n        switch(this){\n            case Month.JANUARY:\n            case Month.FEBRUARY:\n            case Month.MARCH:\n                return Month.JANUARY;\n            case Month.APRIL:\n            case Month.MAY:\n            case Month.JUNE:\n                return Month.APRIL;\n            case Month.JULY:\n            case Month.AUGUST:\n            case Month.SEPTEMBER:\n                return Month.JULY;\n            case Month.OCTOBER:\n            case Month.NOVEMBER:\n            case Month.DECEMBER:\n            default:\n                return Month.OCTOBER;\n        }\n    };\n    _proto.query = function query(_query) {\n        assert(_query != null, \"query() parameter must not be null\", DateTimeException);\n        if (_query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        }\n        return _TemporalAccessor.prototype.query.call(this, _query);\n    };\n    _proto.toString = function toString() {\n        switch(this){\n            case Month.JANUARY:\n                return \"JANUARY\";\n            case Month.FEBRUARY:\n                return \"FEBRUARY\";\n            case Month.MARCH:\n                return \"MARCH\";\n            case Month.APRIL:\n                return \"APRIL\";\n            case Month.MAY:\n                return \"MAY\";\n            case Month.JUNE:\n                return \"JUNE\";\n            case Month.JULY:\n                return \"JULY\";\n            case Month.AUGUST:\n                return \"AUGUST\";\n            case Month.SEPTEMBER:\n                return \"SEPTEMBER\";\n            case Month.OCTOBER:\n                return \"OCTOBER\";\n            case Month.NOVEMBER:\n                return \"NOVEMBER\";\n            case Month.DECEMBER:\n                return \"DECEMBER\";\n            default:\n                return \"unknown Month, value: \" + this.value();\n        }\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, Month, \"other\");\n        return this._value - other._value;\n    };\n    _proto.equals = function equals(other) {\n        return this === other;\n    };\n    Month.valueOf = function valueOf(name) {\n        var ordinal = 0;\n        for(ordinal; ordinal < MONTHS.length; ordinal++){\n            if (MONTHS[ordinal].name() === name) {\n                break;\n            }\n        }\n        return Month.of(ordinal + 1);\n    };\n    Month.values = function values() {\n        return MONTHS.slice();\n    };\n    Month.of = function of(month) {\n        if (month < 1 || month > 12) {\n            assert(false, \"Invalid value for MonthOfYear: \" + month, DateTimeException);\n        }\n        return MONTHS[month - 1];\n    };\n    Month.from = function from(temporal) {\n        if (temporal instanceof Month) {\n            return temporal;\n        }\n        try {\n            return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain Month from TemporalAccessor: \" + temporal + \" of type \" + (temporal && temporal.constructor != null ? temporal.constructor.name : \"\"), ex);\n        }\n    };\n    return Month;\n}(TemporalAccessor);\nvar MONTHS;\nfunction _init$i() {\n    Month.JANUARY = new Month(1, \"JANUARY\");\n    Month.FEBRUARY = new Month(2, \"FEBRUARY\");\n    Month.MARCH = new Month(3, \"MARCH\");\n    Month.APRIL = new Month(4, \"APRIL\");\n    Month.MAY = new Month(5, \"MAY\");\n    Month.JUNE = new Month(6, \"JUNE\");\n    Month.JULY = new Month(7, \"JULY\");\n    Month.AUGUST = new Month(8, \"AUGUST\");\n    Month.SEPTEMBER = new Month(9, \"SEPTEMBER\");\n    Month.OCTOBER = new Month(10, \"OCTOBER\");\n    Month.NOVEMBER = new Month(11, \"NOVEMBER\");\n    Month.DECEMBER = new Month(12, \"DECEMBER\");\n    MONTHS = [\n        Month.JANUARY,\n        Month.FEBRUARY,\n        Month.MARCH,\n        Month.APRIL,\n        Month.MAY,\n        Month.JUNE,\n        Month.JULY,\n        Month.AUGUST,\n        Month.SEPTEMBER,\n        Month.OCTOBER,\n        Month.NOVEMBER,\n        Month.DECEMBER\n    ];\n}\nvar PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;\nvar Period = function(_TemporalAmount) {\n    _inheritsLoose(Period, _TemporalAmount);\n    function Period(years, months, days) {\n        var _this;\n        _this = _TemporalAmount.call(this) || this;\n        var _years = MathUtil.safeToInt(years);\n        var _months = MathUtil.safeToInt(months);\n        var _days = MathUtil.safeToInt(days);\n        if (_years === 0 && _months === 0 && _days === 0) {\n            if (!Period.ZERO) {\n                _this._years = _years;\n                _this._months = _months;\n                _this._days = _days;\n                Period.ZERO = _assertThisInitialized(_this);\n            }\n            return Period.ZERO || _assertThisInitialized(_this);\n        }\n        _this._years = _years;\n        _this._months = _months;\n        _this._days = _days;\n        return _this;\n    }\n    Period.ofYears = function ofYears(years) {\n        return Period.create(years, 0, 0);\n    };\n    Period.ofMonths = function ofMonths(months) {\n        return Period.create(0, months, 0);\n    };\n    Period.ofWeeks = function ofWeeks(weeks) {\n        return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));\n    };\n    Period.ofDays = function ofDays(days) {\n        return Period.create(0, 0, days);\n    };\n    Period.of = function of(years, months, days) {\n        return Period.create(years, months, days);\n    };\n    Period.from = function from(amount) {\n        if (amount instanceof Period) {\n            return amount;\n        }\n        requireNonNull(amount, \"amount\");\n        var years = 0;\n        var months = 0;\n        var days = 0;\n        var units = amount.units();\n        for(var i = 0; i < units.length; i++){\n            var unit = units[i];\n            var unitAmount = amount.get(unit);\n            if (unit === ChronoUnit.YEARS) {\n                years = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.MONTHS) {\n                months = MathUtil.safeToInt(unitAmount);\n            } else if (unit === ChronoUnit.DAYS) {\n                days = MathUtil.safeToInt(unitAmount);\n            } else {\n                throw new DateTimeException(\"Unit must be Years, Months or Days, but was \" + unit);\n            }\n        }\n        return Period.create(years, months, days);\n    };\n    Period.between = function between(startDate, endDate) {\n        requireNonNull(startDate, \"startDate\");\n        requireNonNull(endDate, \"endDate\");\n        requireInstance(startDate, LocalDate, \"startDate\");\n        requireInstance(endDate, LocalDate, \"endDate\");\n        return startDate.until(endDate);\n    };\n    Period.parse = function parse(text) {\n        requireNonNull(text, \"text\");\n        try {\n            return Period._parse(text);\n        } catch (ex) {\n            if (ex instanceof ArithmeticException) {\n                throw new DateTimeParseException(\"Text cannot be parsed to a Period\", text, 0, ex);\n            } else {\n                throw ex;\n            }\n        }\n    };\n    Period._parse = function _parse(text) {\n        var matches = PATTERN.exec(text);\n        if (matches != null) {\n            var negate = \"-\" === matches[1] ? -1 : 1;\n            var yearMatch = matches[2];\n            var monthMatch = matches[3];\n            var weekMatch = matches[4];\n            var dayMatch = matches[5];\n            if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {\n                var years = Period._parseNumber(text, yearMatch, negate);\n                var months = Period._parseNumber(text, monthMatch, negate);\n                var weeks = Period._parseNumber(text, weekMatch, negate);\n                var days = Period._parseNumber(text, dayMatch, negate);\n                days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));\n                return Period.create(years, months, days);\n            }\n        }\n        throw new DateTimeParseException(\"Text cannot be parsed to a Period\", text, 0);\n    };\n    Period._parseNumber = function _parseNumber(text, str, negate) {\n        if (str == null) {\n            return 0;\n        }\n        var val = MathUtil.parseInt(str);\n        return MathUtil.safeMultiply(val, negate);\n    };\n    Period.create = function create(years, months, days) {\n        return new Period(years, months, days);\n    };\n    var _proto = Period.prototype;\n    _proto.units = function units() {\n        return [\n            ChronoUnit.YEARS,\n            ChronoUnit.MONTHS,\n            ChronoUnit.DAYS\n        ];\n    };\n    _proto.chronology = function chronology() {\n        return IsoChronology.INSTANCE;\n    };\n    _proto.get = function get(unit) {\n        if (unit === ChronoUnit.YEARS) {\n            return this._years;\n        }\n        if (unit === ChronoUnit.MONTHS) {\n            return this._months;\n        }\n        if (unit === ChronoUnit.DAYS) {\n            return this._days;\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n    };\n    _proto.isZero = function isZero() {\n        return this === Period.ZERO;\n    };\n    _proto.isNegative = function isNegative() {\n        return this._years < 0 || this._months < 0 || this._days < 0;\n    };\n    _proto.years = function years() {\n        return this._years;\n    };\n    _proto.months = function months() {\n        return this._months;\n    };\n    _proto.days = function days() {\n        return this._days;\n    };\n    _proto.withYears = function withYears(years) {\n        if (years === this._years) {\n            return this;\n        }\n        return Period.create(years, this._months, this._days);\n    };\n    _proto.withMonths = function withMonths(months) {\n        if (months === this._months) {\n            return this;\n        }\n        return Period.create(this._years, months, this._days);\n    };\n    _proto.withDays = function withDays(days) {\n        if (days === this._days) {\n            return this;\n        }\n        return Period.create(this._years, this._months, days);\n    };\n    _proto.plus = function plus(amountToAdd) {\n        var amount = Period.from(amountToAdd);\n        return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));\n    };\n    _proto.plusYears = function plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);\n    };\n    _proto.plusMonths = function plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);\n    };\n    _proto.plusDays = function plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));\n    };\n    _proto.minus = function minus(amountToSubtract) {\n        var amount = Period.from(amountToSubtract);\n        return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));\n    };\n    _proto.minusYears = function minusYears(yearsToSubtract) {\n        return this.plusYears(-1 * yearsToSubtract);\n    };\n    _proto.minusMonths = function minusMonths(monthsToSubtract) {\n        return this.plusMonths(-1 * monthsToSubtract);\n    };\n    _proto.minusDays = function minusDays(daysToSubtract) {\n        return this.plusDays(-1 * daysToSubtract);\n    };\n    _proto.multipliedBy = function multipliedBy(scalar) {\n        if (this === Period.ZERO || scalar === 1) {\n            return this;\n        }\n        return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));\n    };\n    _proto.negated = function negated() {\n        return this.multipliedBy(-1);\n    };\n    _proto.normalized = function normalized() {\n        var totalMonths = this.toTotalMonths();\n        var splitYears = MathUtil.intDiv(totalMonths, 12);\n        var splitMonths = MathUtil.intMod(totalMonths, 12);\n        if (splitYears === this._years && splitMonths === this._months) {\n            return this;\n        }\n        return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);\n    };\n    _proto.toTotalMonths = function toTotalMonths() {\n        return this._years * 12 + this._months;\n    };\n    _proto.addTo = function addTo(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.plus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.plus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.plus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    };\n    _proto.subtractFrom = function subtractFrom(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (this._years !== 0) {\n            if (this._months !== 0) {\n                temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);\n            } else {\n                temporal = temporal.minus(this._years, ChronoUnit.YEARS);\n            }\n        } else if (this._months !== 0) {\n            temporal = temporal.minus(this._months, ChronoUnit.MONTHS);\n        }\n        if (this._days !== 0) {\n            temporal = temporal.minus(this._days, ChronoUnit.DAYS);\n        }\n        return temporal;\n    };\n    _proto.equals = function equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof Period) {\n            var other = obj;\n            return this._years === other._years && this._months === other._months && this._days === other._days;\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return MathUtil.hashCode(this._years, this._months, this._days);\n    };\n    _proto.toString = function toString() {\n        if (this === Period.ZERO) {\n            return \"P0D\";\n        } else {\n            var buf = \"P\";\n            if (this._years !== 0) {\n                buf += this._years + \"Y\";\n            }\n            if (this._months !== 0) {\n                buf += this._months + \"M\";\n            }\n            if (this._days !== 0) {\n                buf += this._days + \"D\";\n            }\n            return buf;\n        }\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return Period;\n}(TemporalAmount);\nfunction _init$h() {\n    Period.ofDays(0);\n}\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ParsePosition = function() {\n    function ParsePosition(index) {\n        this._index = index;\n        this._errorIndex = -1;\n    }\n    var _proto = ParsePosition.prototype;\n    _proto.getIndex = function getIndex() {\n        return this._index;\n    };\n    _proto.setIndex = function setIndex(index) {\n        this._index = index;\n    };\n    _proto.getErrorIndex = function getErrorIndex() {\n        return this._errorIndex;\n    };\n    _proto.setErrorIndex = function setErrorIndex(errorIndex) {\n        this._errorIndex = errorIndex;\n    };\n    return ParsePosition;\n}();\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var EnumMap = function() {\n    function EnumMap() {\n        this._map = {};\n    }\n    var _proto = EnumMap.prototype;\n    _proto.putAll = function putAll(otherMap) {\n        for(var key in otherMap._map){\n            this._map[key] = otherMap._map[key];\n        }\n        return this;\n    };\n    _proto.containsKey = function containsKey(key) {\n        return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;\n    };\n    _proto.get = function get(key) {\n        return this._map[key.name()];\n    };\n    _proto.put = function put(key, val) {\n        return this.set(key, val);\n    };\n    _proto.set = function set(key, val) {\n        this._map[key.name()] = val;\n        return this;\n    };\n    _proto.retainAll = function retainAll(keyList) {\n        var map = {};\n        for(var i = 0; i < keyList.length; i++){\n            var key = keyList[i].name();\n            map[key] = this._map[key];\n        }\n        this._map = map;\n        return this;\n    };\n    _proto.remove = function remove(key) {\n        var keyName = key.name();\n        var val = this._map[keyName];\n        this._map[keyName] = undefined;\n        return val;\n    };\n    _proto.keySet = function keySet() {\n        return this._map;\n    };\n    _proto.clear = function clear() {\n        this._map = {};\n    };\n    return EnumMap;\n}();\nvar ResolverStyle = function(_Enum) {\n    _inheritsLoose(ResolverStyle, _Enum);\n    function ResolverStyle() {\n        return _Enum.apply(this, arguments) || this;\n    }\n    return ResolverStyle;\n}(Enum);\nResolverStyle.STRICT = new ResolverStyle(\"STRICT\");\nResolverStyle.SMART = new ResolverStyle(\"SMART\");\nResolverStyle.LENIENT = new ResolverStyle(\"LENIENT\");\nvar Temporal = function(_TemporalAccessor) {\n    _inheritsLoose(Temporal, _TemporalAccessor);\n    function Temporal() {\n        return _TemporalAccessor.apply(this, arguments) || this;\n    }\n    var _proto = Temporal.prototype;\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        abstractMethodFail(\"isSupported\");\n    };\n    _proto.minus = function minus(amount, unit) {\n        if (arguments.length < 2) {\n            return this._minusAmount(amount);\n        } else {\n            return this._minusUnit(amount, unit);\n        }\n    };\n    _proto._minusAmount = function _minusAmount(amount) {\n        requireNonNull(amount, \"amount\");\n        requireInstance(amount, TemporalAmount, \"amount\");\n        return amount.subtractFrom(this);\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, \"amountToSubtract\");\n        requireNonNull(unit, \"unit\");\n        requireInstance(unit, TemporalUnit, \"unit\");\n        return this._plusUnit(-amountToSubtract, unit);\n    };\n    _proto.plus = function plus(amount, unit) {\n        if (arguments.length < 2) {\n            return this._plusAmount(amount);\n        } else {\n            return this._plusUnit(amount, unit);\n        }\n    };\n    _proto._plusAmount = function _plusAmount(amount) {\n        requireNonNull(amount, \"amount\");\n        requireInstance(amount, TemporalAmount, \"amount\");\n        return amount.addTo(this);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        abstractMethodFail(\"_plusUnit\");\n    };\n    _proto.until = function until(endTemporal, unit) {\n        abstractMethodFail(\"until\");\n    };\n    _proto.with = function _with(adjusterOrField, newValue) {\n        if (arguments.length < 2) {\n            return this._withAdjuster(adjusterOrField);\n        } else {\n            return this._withField(adjusterOrField, newValue);\n        }\n    };\n    _proto._withAdjuster = function _withAdjuster(adjuster) {\n        requireNonNull(adjuster, \"adjuster\");\n        assert(typeof adjuster.adjustInto === \"function\", \"adjuster must be a TemporalAdjuster\", IllegalArgumentException);\n        return adjuster.adjustInto(this);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        abstractMethodFail(\"_withField\");\n    };\n    return Temporal;\n}(TemporalAccessor);\nif (typeof Symbol !== \"undefined\" && Symbol.toPrimitive) {\n    Temporal.prototype[Symbol.toPrimitive] = function(hint) {\n        if (hint !== \"number\") {\n            return this.toString();\n        }\n        throw new TypeError(\"A conversion from Temporal to a number is not allowed. \" + \"To compare use the methods .equals(), .compareTo(), .isBefore() \" + \"or one that is more suitable to your use case.\");\n    };\n}\nvar ChronoLocalDate = function(_Temporal) {\n    _inheritsLoose(ChronoLocalDate, _Temporal);\n    function ChronoLocalDate() {\n        return _Temporal.apply(this, arguments) || this;\n    }\n    var _proto = ChronoLocalDate.prototype;\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    };\n    _proto.query = function query(_query) {\n        if (_query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.DAYS;\n        } else if (_query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toEpochDay());\n        } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n            return null;\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        requireInstance(formatter, DateTimeFormatter, \"formatter\");\n        return formatter.format(this);\n    };\n    return ChronoLocalDate;\n}(Temporal);\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var StringUtil = function() {\n    function StringUtil() {}\n    StringUtil.startsWith = function startsWith(text, pattern) {\n        return text.indexOf(pattern) === 0;\n    };\n    StringUtil.hashCode = function hashCode(text) {\n        var len = text.length;\n        if (len === 0) {\n            return 0;\n        }\n        var hash = 0;\n        for(var i = 0; i < len; i++){\n            var chr = text.charCodeAt(i);\n            hash = (hash << 5) - hash + chr;\n            hash |= 0;\n        }\n        return MathUtil.smi(hash);\n    };\n    return StringUtil;\n}();\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ZoneId = function() {\n    function ZoneId() {}\n    ZoneId.systemDefault = function systemDefault() {\n        throw new DateTimeException(\"not supported operation\");\n    };\n    ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {\n        throw new DateTimeException(\"not supported operation\");\n    };\n    ZoneId.of = function of(zoneId) {\n        throw new DateTimeException(\"not supported operation\" + zoneId);\n    };\n    ZoneId.ofOffset = function ofOffset(prefix, offset) {\n        throw new DateTimeException(\"not supported operation\" + prefix + offset);\n    };\n    ZoneId.from = function from(temporal) {\n        throw new DateTimeException(\"not supported operation\" + temporal);\n    };\n    var _proto = ZoneId.prototype;\n    _proto.id = function id() {\n        abstractMethodFail(\"ZoneId.id\");\n    };\n    _proto.rules = function rules() {\n        abstractMethodFail(\"ZoneId.rules\");\n    };\n    _proto.normalized = function normalized() {\n        var rules = this.rules();\n        if (rules.isFixedOffset()) {\n            return rules.offset(Instant.EPOCH);\n        }\n        return this;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZoneId) {\n            return this.id() === other.id();\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return StringUtil.hashCode(this.id());\n    };\n    _proto.toString = function toString() {\n        return this.id();\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return ZoneId;\n}();\nvar ZoneRules = function() {\n    function ZoneRules() {}\n    ZoneRules.of = function of(offset) {\n        requireNonNull(offset, \"offset\");\n        return new Fixed(offset);\n    };\n    var _proto = ZoneRules.prototype;\n    _proto.isFixedOffset = function isFixedOffset() {\n        abstractMethodFail(\"ZoneRules.isFixedOffset\");\n    };\n    _proto.offset = function offset(instantOrLocalDateTime) {\n        if (instantOrLocalDateTime instanceof Instant) {\n            return this.offsetOfInstant(instantOrLocalDateTime);\n        } else {\n            return this.offsetOfLocalDateTime(instantOrLocalDateTime);\n        }\n    };\n    _proto.offsetOfInstant = function offsetOfInstant(instant) {\n        abstractMethodFail(\"ZoneRules.offsetInstant\");\n    };\n    _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n        abstractMethodFail(\"ZoneRules.offsetOfEpochMilli\");\n    };\n    _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n        abstractMethodFail(\"ZoneRules.offsetLocalDateTime\");\n    };\n    _proto.validOffsets = function validOffsets(localDateTime) {\n        abstractMethodFail(\"ZoneRules.validOffsets\");\n    };\n    _proto.transition = function transition(localDateTime) {\n        abstractMethodFail(\"ZoneRules.transition\");\n    };\n    _proto.standardOffset = function standardOffset(instant) {\n        abstractMethodFail(\"ZoneRules.standardOffset\");\n    };\n    _proto.daylightSavings = function daylightSavings(instant) {\n        abstractMethodFail(\"ZoneRules.daylightSavings\");\n    };\n    _proto.isDaylightSavings = function isDaylightSavings(instant) {\n        abstractMethodFail(\"ZoneRules.isDaylightSavings\");\n    };\n    _proto.isValidOffset = function isValidOffset(localDateTime, offset) {\n        abstractMethodFail(\"ZoneRules.isValidOffset\");\n    };\n    _proto.nextTransition = function nextTransition(instant) {\n        abstractMethodFail(\"ZoneRules.nextTransition\");\n    };\n    _proto.previousTransition = function previousTransition(instant) {\n        abstractMethodFail(\"ZoneRules.previousTransition\");\n    };\n    _proto.transitions = function transitions() {\n        abstractMethodFail(\"ZoneRules.transitions\");\n    };\n    _proto.transitionRules = function transitionRules() {\n        abstractMethodFail(\"ZoneRules.transitionRules\");\n    };\n    _proto.toString = function toString() {\n        abstractMethodFail(\"ZoneRules.toString\");\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return ZoneRules;\n}();\nvar Fixed = function(_ZoneRules) {\n    _inheritsLoose(Fixed, _ZoneRules);\n    function Fixed(offset) {\n        var _this;\n        _this = _ZoneRules.call(this) || this;\n        _this._offset = offset;\n        return _this;\n    }\n    var _proto2 = Fixed.prototype;\n    _proto2.isFixedOffset = function isFixedOffset() {\n        return true;\n    };\n    _proto2.offsetOfInstant = function offsetOfInstant() {\n        return this._offset;\n    };\n    _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {\n        return this._offset;\n    };\n    _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {\n        return this._offset;\n    };\n    _proto2.validOffsets = function validOffsets() {\n        return [\n            this._offset\n        ];\n    };\n    _proto2.transition = function transition() {\n        return null;\n    };\n    _proto2.standardOffset = function standardOffset() {\n        return this._offset;\n    };\n    _proto2.daylightSavings = function daylightSavings() {\n        return Duration.ZERO;\n    };\n    _proto2.isDaylightSavings = function isDaylightSavings() {\n        return false;\n    };\n    _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {\n        return this._offset.equals(offset);\n    };\n    _proto2.nextTransition = function nextTransition() {\n        return null;\n    };\n    _proto2.previousTransition = function previousTransition() {\n        return null;\n    };\n    _proto2.transitions = function transitions() {\n        return [];\n    };\n    _proto2.transitionRules = function transitionRules() {\n        return [];\n    };\n    _proto2.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Fixed) {\n            return this._offset.equals(other._offset);\n        }\n        return false;\n    };\n    _proto2.toString = function toString() {\n        return \"FixedRules:\" + this._offset.toString();\n    };\n    return Fixed;\n}(ZoneRules);\nvar SECONDS_CACHE = {};\nvar ID_CACHE = {};\nvar ZoneOffset = function(_ZoneId) {\n    _inheritsLoose(ZoneOffset, _ZoneId);\n    function ZoneOffset(totalSeconds) {\n        var _this;\n        _this = _ZoneId.call(this) || this;\n        ZoneOffset._validateTotalSeconds(totalSeconds);\n        _this._totalSeconds = MathUtil.safeToInt(totalSeconds);\n        _this._rules = ZoneRules.of(_assertThisInitialized(_this));\n        _this._id = ZoneOffset._buildId(totalSeconds);\n        return _this;\n    }\n    var _proto = ZoneOffset.prototype;\n    _proto.totalSeconds = function totalSeconds() {\n        return this._totalSeconds;\n    };\n    _proto.id = function id() {\n        return this._id;\n    };\n    ZoneOffset._buildId = function _buildId(totalSeconds) {\n        if (totalSeconds === 0) {\n            return \"Z\";\n        } else {\n            var absTotalSeconds = Math.abs(totalSeconds);\n            var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);\n            var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n            var buf = \"\" + (totalSeconds < 0 ? \"-\" : \"+\") + (absHours < 10 ? \"0\" : \"\") + absHours + (absMinutes < 10 ? \":0\" : \":\") + absMinutes;\n            var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);\n            if (absSeconds !== 0) {\n                buf += (absSeconds < 10 ? \":0\" : \":\") + absSeconds;\n            }\n            return buf;\n        }\n    };\n    ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {\n        if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {\n            throw new DateTimeException(\"Zone offset not in valid range: -18:00 to +18:00\");\n        }\n    };\n    ZoneOffset._validate = function _validate(hours, minutes, seconds) {\n        if (hours < -18 || hours > 18) {\n            throw new DateTimeException(\"Zone offset hours not in valid range: value \" + hours + \" is not in the range -18 to 18\");\n        }\n        if (hours > 0) {\n            if (minutes < 0 || seconds < 0) {\n                throw new DateTimeException(\"Zone offset minutes and seconds must be positive because hours is positive\");\n            }\n        } else if (hours < 0) {\n            if (minutes > 0 || seconds > 0) {\n                throw new DateTimeException(\"Zone offset minutes and seconds must be negative because hours is negative\");\n            }\n        } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {\n            throw new DateTimeException(\"Zone offset minutes and seconds must have the same sign\");\n        }\n        if (Math.abs(minutes) > 59) {\n            throw new DateTimeException(\"Zone offset minutes not in valid range: abs(value) \" + Math.abs(minutes) + \" is not in the range 0 to 59\");\n        }\n        if (Math.abs(seconds) > 59) {\n            throw new DateTimeException(\"Zone offset seconds not in valid range: abs(value) \" + Math.abs(seconds) + \" is not in the range 0 to 59\");\n        }\n        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {\n            throw new DateTimeException(\"Zone offset not in valid range: -18:00 to +18:00\");\n        }\n    };\n    ZoneOffset.of = function of(offsetId) {\n        requireNonNull(offsetId, \"offsetId\");\n        var offset = ID_CACHE[offsetId];\n        if (offset != null) {\n            return offset;\n        }\n        var hours, minutes, seconds;\n        switch(offsetId.length){\n            case 2:\n                offsetId = offsetId[0] + \"0\" + offsetId[1];\n            case 3:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = 0;\n                seconds = 0;\n                break;\n            case 5:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = 0;\n                break;\n            case 6:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = 0;\n                break;\n            case 7:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 3, false);\n                seconds = ZoneOffset._parseNumber(offsetId, 5, false);\n                break;\n            case 9:\n                hours = ZoneOffset._parseNumber(offsetId, 1, false);\n                minutes = ZoneOffset._parseNumber(offsetId, 4, true);\n                seconds = ZoneOffset._parseNumber(offsetId, 7, true);\n                break;\n            default:\n                throw new DateTimeException(\"Invalid ID for ZoneOffset, invalid format: \" + offsetId);\n        }\n        var first = offsetId[0];\n        if (first !== \"+\" && first !== \"-\") {\n            throw new DateTimeException(\"Invalid ID for ZoneOffset, plus/minus not found when expected: \" + offsetId);\n        }\n        if (first === \"-\") {\n            return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);\n        } else {\n            return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);\n        }\n    };\n    ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {\n        if (precededByColon && offsetId[pos - 1] !== \":\") {\n            throw new DateTimeException(\"Invalid ID for ZoneOffset, colon not found when expected: \" + offsetId);\n        }\n        var ch1 = offsetId[pos];\n        var ch2 = offsetId[pos + 1];\n        if (ch1 < \"0\" || ch1 > \"9\" || ch2 < \"0\" || ch2 > \"9\") {\n            throw new DateTimeException(\"Invalid ID for ZoneOffset, non numeric characters found: \" + offsetId);\n        }\n        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n    };\n    ZoneOffset.ofHours = function ofHours(hours) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);\n    };\n    ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {\n        return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);\n    };\n    ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {\n        ZoneOffset._validate(hours, minutes, seconds);\n        var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    };\n    ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {\n        var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;\n        return ZoneOffset.ofTotalSeconds(totalSeconds);\n    };\n    ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {\n        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {\n            var totalSecs = totalSeconds;\n            var result = SECONDS_CACHE[totalSecs];\n            if (result == null) {\n                result = new ZoneOffset(totalSeconds);\n                SECONDS_CACHE[totalSecs] = result;\n                ID_CACHE[result.id()] = result;\n            }\n            return result;\n        } else {\n            return new ZoneOffset(totalSeconds);\n        }\n    };\n    _proto.rules = function rules() {\n        return this._rules;\n    };\n    _proto.get = function get(field) {\n        return this.getLong(field);\n    };\n    _proto.getLong = function getLong(field) {\n        if (field === ChronoField.OFFSET_SECONDS) {\n            return this._totalSeconds;\n        } else if (field instanceof ChronoField) {\n            throw new DateTimeException(\"Unsupported field: \" + field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n            return this;\n        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return _query.queryFrom(this);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        return other._totalSeconds - this._totalSeconds;\n    };\n    _proto.equals = function equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof ZoneOffset) {\n            return this._totalSeconds === obj._totalSeconds;\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return this._totalSeconds;\n    };\n    _proto.toString = function toString() {\n        return this._id;\n    };\n    return ZoneOffset;\n}(ZoneId);\nfunction _init$g() {\n    ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;\n    ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);\n    ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);\n    ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);\n}\nvar DateTimeBuilder = function(_TemporalAccessor) {\n    _inheritsLoose(DateTimeBuilder, _TemporalAccessor);\n    DateTimeBuilder.create = function create(field, value) {\n        var dtb = new DateTimeBuilder();\n        dtb._addFieldValue(field, value);\n        return dtb;\n    };\n    function DateTimeBuilder() {\n        var _this;\n        _this = _TemporalAccessor.call(this) || this;\n        _this.fieldValues = new EnumMap();\n        _this.chrono = null;\n        _this.zone = null;\n        _this.date = null;\n        _this.time = null;\n        _this.leapSecond = false;\n        _this.excessDays = null;\n        return _this;\n    }\n    var _proto = DateTimeBuilder.prototype;\n    _proto.getFieldValue0 = function getFieldValue0(field) {\n        return this.fieldValues.get(field);\n    };\n    _proto._addFieldValue = function _addFieldValue(field, value) {\n        requireNonNull(field, \"field\");\n        var old = this.getFieldValue0(field);\n        if (old != null && old !== value) {\n            throw new DateTimeException(\"Conflict found: \" + field + \" \" + old + \" differs from \" + field + \" \" + value + \": \" + this);\n        }\n        return this._putFieldValue0(field, value);\n    };\n    _proto._putFieldValue0 = function _putFieldValue0(field, value) {\n        this.fieldValues.put(field, value);\n        return this;\n    };\n    _proto.resolve = function resolve(resolverStyle, resolverFields) {\n        if (resolverFields != null) {\n            this.fieldValues.retainAll(resolverFields);\n        }\n        this._mergeDate(resolverStyle);\n        this._mergeTime(resolverStyle);\n        this._resolveTimeInferZeroes(resolverStyle);\n        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {\n            this.date = this.date.plus(this.excessDays);\n            this.excessDays = Period.ZERO;\n        }\n        this._resolveInstant();\n        return this;\n    };\n    _proto._mergeDate = function _mergeDate(resolverStyle) {\n        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));\n    };\n    _proto._checkDate = function _checkDate(date) {\n        if (date != null) {\n            this._addObject(date);\n            for(var fieldName in this.fieldValues.keySet()){\n                var field = ChronoField.byName(fieldName);\n                if (field) {\n                    if (this.fieldValues.get(field) !== undefined) {\n                        if (field.isDateBased()) {\n                            var val1 = void 0;\n                            try {\n                                val1 = date.getLong(field);\n                            } catch (ex) {\n                                if (ex instanceof DateTimeException) {\n                                    continue;\n                                } else {\n                                    throw ex;\n                                }\n                            }\n                            var val2 = this.fieldValues.get(field);\n                            if (val1 !== val2) {\n                                throw new DateTimeException(\"Conflict found: Field \" + field + \" \" + val1 + \" differs from \" + field + \" \" + val2 + \" derived from \" + date);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    _proto._mergeTime = function _mergeTime(resolverStyle) {\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {\n            var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && ch === 0) ;\n                else {\n                    ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);\n        }\n        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {\n            var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                if (resolverStyle === ResolverStyle.SMART && _ch === 0) ;\n                else {\n                    ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);\n                }\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {\n                ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));\n            }\n            if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n                ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {\n            var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);\n            var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);\n        }\n        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {\n            var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.NANO_OF_DAY.checkValidValue(nod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));\n            this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {\n            var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MICRO_OF_DAY.checkValidValue(cod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));\n            this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {\n            var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MILLI_OF_DAY.checkValidValue(lod);\n            }\n            this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));\n            this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {\n            var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.SECOND_OF_DAY.checkValidValue(sod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));\n            this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {\n            var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.MINUTE_OF_DAY.checkValidValue(mod);\n            }\n            this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));\n            this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n                ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));\n            }\n            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n                ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));\n            }\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));\n            this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {\n            var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n            this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));\n            this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n        }\n        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {\n            var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);\n        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {\n            var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);\n            this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);\n        }\n    };\n    _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {\n        var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);\n        var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);\n        var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);\n        var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);\n        if (hod == null) {\n            return;\n        }\n        if (moh == null && (som != null || nos != null)) {\n            return;\n        }\n        if (moh != null && som == null && nos != null) {\n            return;\n        }\n        if (resolverStyle !== ResolverStyle.LENIENT) {\n            if (hod != null) {\n                if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {\n                    hod = 0;\n                    this.excessDays = Period.ofDays(1);\n                }\n                var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);\n                if (moh != null) {\n                    var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);\n                    if (som != null) {\n                        var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);\n                        if (nos != null) {\n                            var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));\n                        } else {\n                            this._addObject(LocalTime.of(hodVal, mohVal, somVal));\n                        }\n                    } else {\n                        if (nos == null) {\n                            this._addObject(LocalTime.of(hodVal, mohVal));\n                        }\n                    }\n                } else {\n                    if (som == null && nos == null) {\n                        this._addObject(LocalTime.of(hodVal, 0));\n                    }\n                }\n            }\n        } else {\n            if (hod != null) {\n                var _hodVal = hod;\n                if (moh != null) {\n                    if (som != null) {\n                        if (nos == null) {\n                            nos = 0;\n                        }\n                        var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));\n                        totalNanos = MathUtil.safeAdd(totalNanos, nos);\n                        var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);\n                        var nod = MathUtil.floorMod(totalNanos, 86400000000000);\n                        this._addObject(LocalTime.ofNanoOfDay(nod));\n                        this.excessDays = Period.ofDays(excessDays);\n                    } else {\n                        var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);\n                        totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));\n                        var _excessDays = MathUtil.floorDiv(totalSecs, 86400);\n                        var sod = MathUtil.floorMod(totalSecs, 86400);\n                        this._addObject(LocalTime.ofSecondOfDay(sod));\n                        this.excessDays = Period.ofDays(_excessDays);\n                    }\n                } else {\n                    var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));\n                    _hodVal = MathUtil.floorMod(_hodVal, 24);\n                    this._addObject(LocalTime.of(_hodVal, 0));\n                    this.excessDays = Period.ofDays(_excessDays2);\n                }\n            }\n        }\n        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);\n        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);\n        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);\n        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);\n    };\n    _proto._addObject = function _addObject(dateOrTime) {\n        if (dateOrTime instanceof ChronoLocalDate) {\n            this.date = dateOrTime;\n        } else if (dateOrTime instanceof LocalTime) {\n            this.time = dateOrTime;\n        }\n    };\n    _proto._resolveInstant = function _resolveInstant() {\n        if (this.date != null && this.time != null) {\n            var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);\n            if (offsetSecs != null) {\n                var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n                var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);\n                this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);\n            } else if (this.zone != null) {\n                var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);\n                this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);\n            }\n        }\n    };\n    _proto.build = function build(type) {\n        return type.queryFrom(this);\n    };\n    _proto.isSupported = function isSupported(field) {\n        if (field == null) {\n            return false;\n        }\n        return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);\n    };\n    _proto.getLong = function getLong(field) {\n        requireNonNull(field, \"field\");\n        var value = this.getFieldValue0(field);\n        if (value == null) {\n            if (this.date != null && this.date.isSupported(field)) {\n                return this.date.getLong(field);\n            }\n            if (this.time != null && this.time.isSupported(field)) {\n                return this.time.getLong(field);\n            }\n            throw new DateTimeException(\"Field not found: \" + field);\n        }\n        return value;\n    };\n    _proto.query = function query(_query) {\n        if (_query === TemporalQueries.zoneId()) {\n            return this.zone;\n        } else if (_query === TemporalQueries.chronology()) {\n            return this.chrono;\n        } else if (_query === TemporalQueries.localDate()) {\n            return this.date != null ? LocalDate.from(this.date) : null;\n        } else if (_query === TemporalQueries.localTime()) {\n            return this.time;\n        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n            return _query.queryFrom(this);\n        } else if (_query === TemporalQueries.precision()) {\n            return null;\n        }\n        return _query.queryFrom(this);\n    };\n    return DateTimeBuilder;\n}(TemporalAccessor);\nvar DateTimeParseContext = function() {\n    function DateTimeParseContext() {\n        if (arguments.length === 1) {\n            if (arguments[0] instanceof DateTimeParseContext) {\n                this._constructorSelf.apply(this, arguments);\n                return;\n            } else {\n                this._constructorFormatter.apply(this, arguments);\n            }\n        } else {\n            this._constructorParam.apply(this, arguments);\n        }\n        this._caseSensitive = true;\n        this._strict = true;\n        this._parsed = [\n            new Parsed(this)\n        ];\n    }\n    var _proto = DateTimeParseContext.prototype;\n    _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {\n        this._locale = locale;\n        this._symbols = symbols;\n        this._overrideChronology = chronology;\n    };\n    _proto._constructorFormatter = function _constructorFormatter(formatter) {\n        this._locale = formatter.locale();\n        this._symbols = formatter.decimalStyle();\n        this._overrideChronology = formatter.chronology();\n    };\n    _proto._constructorSelf = function _constructorSelf(other) {\n        this._locale = other._locale;\n        this._symbols = other._symbols;\n        this._overrideChronology = other._overrideChronology;\n        this._overrideZone = other._overrideZone;\n        this._caseSensitive = other._caseSensitive;\n        this._strict = other._strict;\n        this._parsed = [\n            new Parsed(this)\n        ];\n    };\n    _proto.copy = function copy() {\n        return new DateTimeParseContext(this);\n    };\n    _proto.symbols = function symbols() {\n        return this._symbols;\n    };\n    _proto.isStrict = function isStrict() {\n        return this._strict;\n    };\n    _proto.setStrict = function setStrict(strict) {\n        this._strict = strict;\n    };\n    _proto.locale = function locale() {\n        return this._locale;\n    };\n    _proto.setLocale = function setLocale(locale) {\n        this._locale = locale;\n    };\n    _proto.startOptional = function startOptional() {\n        this._parsed.push(this.currentParsed().copy());\n    };\n    _proto.endOptional = function endOptional(successful) {\n        if (successful) {\n            this._parsed.splice(this._parsed.length - 2, 1);\n        } else {\n            this._parsed.splice(this._parsed.length - 1, 1);\n        }\n    };\n    _proto.isCaseSensitive = function isCaseSensitive() {\n        return this._caseSensitive;\n    };\n    _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {\n        this._caseSensitive = caseSensitive;\n    };\n    _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {\n        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {\n            return false;\n        }\n        if (!this.isCaseSensitive()) {\n            cs1 = cs1.toLowerCase();\n            cs2 = cs2.toLowerCase();\n        }\n        for(var i = 0; i < length; i++){\n            var ch1 = cs1[offset1 + i];\n            var ch2 = cs2[offset2 + i];\n            if (ch1 !== ch2) {\n                return false;\n            }\n        }\n        return true;\n    };\n    _proto.charEquals = function charEquals(ch1, ch2) {\n        if (this.isCaseSensitive()) {\n            return ch1 === ch2;\n        }\n        return this.charEqualsIgnoreCase(ch1, ch2);\n    };\n    _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {\n        return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();\n    };\n    _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {\n        var currentParsedFieldValues = this.currentParsed().fieldValues;\n        var old = currentParsedFieldValues.get(field);\n        currentParsedFieldValues.set(field, value);\n        return old != null && old !== value ? ~errorPos : successPos;\n    };\n    _proto.setParsedZone = function setParsedZone(zone) {\n        requireNonNull(zone, \"zone\");\n        this.currentParsed().zone = zone;\n    };\n    _proto.getParsed = function getParsed(field) {\n        return this.currentParsed().fieldValues.get(field);\n    };\n    _proto.toParsed = function toParsed() {\n        return this.currentParsed();\n    };\n    _proto.currentParsed = function currentParsed() {\n        return this._parsed[this._parsed.length - 1];\n    };\n    _proto.setParsedLeapSecond = function setParsedLeapSecond() {\n        this.currentParsed().leapSecond = true;\n    };\n    _proto.getEffectiveChronology = function getEffectiveChronology() {\n        var chrono = this.currentParsed().chrono;\n        if (chrono == null) {\n            chrono = this._overrideChronology;\n            if (chrono == null) {\n                chrono = IsoChronology.INSTANCE;\n            }\n        }\n        return chrono;\n    };\n    return DateTimeParseContext;\n}();\nvar Parsed = function(_Temporal) {\n    _inheritsLoose(Parsed, _Temporal);\n    function Parsed(dateTimeParseContext) {\n        var _this;\n        _this = _Temporal.call(this) || this;\n        _this.chrono = null;\n        _this.zone = null;\n        _this.fieldValues = new EnumMap();\n        _this.leapSecond = false;\n        _this.dateTimeParseContext = dateTimeParseContext;\n        return _this;\n    }\n    var _proto2 = Parsed.prototype;\n    _proto2.copy = function copy() {\n        var cloned = new Parsed();\n        cloned.chrono = this.chrono;\n        cloned.zone = this.zone;\n        cloned.fieldValues.putAll(this.fieldValues);\n        cloned.leapSecond = this.leapSecond;\n        cloned.dateTimeParseContext = this.dateTimeParseContext;\n        return cloned;\n    };\n    _proto2.toString = function toString() {\n        return this.fieldValues + \", \" + this.chrono + \", \" + this.zone;\n    };\n    _proto2.isSupported = function isSupported(field) {\n        return this.fieldValues.containsKey(field);\n    };\n    _proto2.get = function get(field) {\n        var val = this.fieldValues.get(field);\n        assert(val != null);\n        return val;\n    };\n    _proto2.query = function query(_query) {\n        if (_query === TemporalQueries.chronology()) {\n            return this.chrono;\n        }\n        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n            return this.zone;\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto2.toBuilder = function toBuilder() {\n        var builder = new DateTimeBuilder();\n        builder.fieldValues.putAll(this.fieldValues);\n        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();\n        if (this.zone != null) {\n            builder.zone = this.zone;\n        } else {\n            builder.zone = this.overrideZone;\n        }\n        builder.leapSecond = this.leapSecond;\n        builder.excessDays = this.excessDays;\n        return builder;\n    };\n    return Parsed;\n}(Temporal);\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var DateTimePrintContext = function() {\n    function DateTimePrintContext(temporal, localeOrFormatter, symbols) {\n        if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {\n            this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);\n            this._locale = localeOrFormatter.locale();\n            this._symbols = localeOrFormatter.decimalStyle();\n        } else {\n            this._temporal = temporal;\n            this._locale = localeOrFormatter;\n            this._symbols = symbols;\n        }\n        this._optional = 0;\n    }\n    DateTimePrintContext.adjust = function adjust(temporal, formatter) {\n        return temporal;\n    };\n    var _proto = DateTimePrintContext.prototype;\n    _proto.symbols = function symbols() {\n        return this._symbols;\n    };\n    _proto.startOptional = function startOptional() {\n        this._optional++;\n    };\n    _proto.endOptional = function endOptional() {\n        this._optional--;\n    };\n    _proto.getValueQuery = function getValueQuery(query) {\n        var result = this._temporal.query(query);\n        if (result == null && this._optional === 0) {\n            throw new DateTimeException(\"Unable to extract value: \" + this._temporal);\n        }\n        return result;\n    };\n    _proto.getValue = function getValue(field) {\n        try {\n            return this._temporal.getLong(field);\n        } catch (ex) {\n            if (ex instanceof DateTimeException && this._optional > 0) {\n                return null;\n            }\n            throw ex;\n        }\n    };\n    _proto.temporal = function temporal() {\n        return this._temporal;\n    };\n    _proto.locale = function locale() {\n        return this._locale;\n    };\n    _proto.setDateTime = function setDateTime(temporal) {\n        this._temporal = temporal;\n    };\n    _proto.setLocale = function setLocale(locale) {\n        this._locale = locale;\n    };\n    return DateTimePrintContext;\n}();\nvar IsoFields = {};\nvar QUARTER_DAYS = [\n    0,\n    90,\n    181,\n    273,\n    0,\n    91,\n    182,\n    274\n];\nvar Field = function(_TemporalField) {\n    _inheritsLoose(Field, _TemporalField);\n    function Field() {\n        return _TemporalField.apply(this, arguments) || this;\n    }\n    var _proto = Field.prototype;\n    _proto.isDateBased = function isDateBased() {\n        return true;\n    };\n    _proto.isTimeBased = function isTimeBased() {\n        return false;\n    };\n    _proto._isIso = function _isIso() {\n        return true;\n    };\n    Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {\n        var wby = Field._getWeekBasedYear(date);\n        return ValueRange.of(1, Field._getWeekRangeByYear(wby));\n    };\n    Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {\n        var date = LocalDate.of(wby, 1, 1);\n        if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {\n            return 53;\n        }\n        return 52;\n    };\n    Field._getWeek = function _getWeek(date) {\n        var dow0 = date.dayOfWeek().ordinal();\n        var doy0 = date.dayOfYear() - 1;\n        var doyThu0 = doy0 + (3 - dow0);\n        var alignedWeek = MathUtil.intDiv(doyThu0, 7);\n        var firstThuDoy0 = doyThu0 - alignedWeek * 7;\n        var firstMonDoy0 = firstThuDoy0 - 3;\n        if (firstMonDoy0 < -3) {\n            firstMonDoy0 += 7;\n        }\n        if (doy0 < firstMonDoy0) {\n            return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();\n        }\n        var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;\n        if (week === 53) {\n            if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {\n                week = 1;\n            }\n        }\n        return week;\n    };\n    Field._getWeekBasedYear = function _getWeekBasedYear(date) {\n        var year = date.year();\n        var doy = date.dayOfYear();\n        if (doy <= 3) {\n            var dow = date.dayOfWeek().ordinal();\n            if (doy - dow < -2) {\n                year--;\n            }\n        } else if (doy >= 363) {\n            var _dow = date.dayOfWeek().ordinal();\n            doy = doy - 363 - (date.isLeapYear() ? 1 : 0);\n            if (doy - _dow >= 0) {\n                year++;\n            }\n        }\n        return year;\n    };\n    _proto.displayName = function displayName() {\n        return this.toString();\n    };\n    _proto.resolve = function resolve() {\n        return null;\n    };\n    _proto.name = function name() {\n        return this.toString();\n    };\n    return Field;\n}(TemporalField);\nvar DAY_OF_QUARTER_FIELD = function(_Field) {\n    _inheritsLoose(DAY_OF_QUARTER_FIELD, _Field);\n    function DAY_OF_QUARTER_FIELD() {\n        return _Field.apply(this, arguments) || this;\n    }\n    var _proto2 = DAY_OF_QUARTER_FIELD.prototype;\n    _proto2.toString = function toString() {\n        return \"DayOfQuarter\";\n    };\n    _proto2.baseUnit = function baseUnit() {\n        return ChronoUnit.DAYS;\n    };\n    _proto2.rangeUnit = function rangeUnit() {\n        return QUARTER_YEARS;\n    };\n    _proto2.range = function range() {\n        return ValueRange.of(1, 90, 92);\n    };\n    _proto2.isSupportedBy = function isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);\n    };\n    _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: DayOfQuarter\");\n        }\n        var qoy = temporal.getLong(QUARTER_OF_YEAR);\n        if (qoy === 1) {\n            var year = temporal.getLong(ChronoField.YEAR);\n            return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);\n        } else if (qoy === 2) {\n            return ValueRange.of(1, 91);\n        } else if (qoy === 3 || qoy === 4) {\n            return ValueRange.of(1, 92);\n        }\n        return this.range();\n    };\n    _proto2.getFrom = function getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: DayOfQuarter\");\n        }\n        var doy = temporal.get(ChronoField.DAY_OF_YEAR);\n        var moy = temporal.get(ChronoField.MONTH_OF_YEAR);\n        var year = temporal.getLong(ChronoField.YEAR);\n        return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];\n    };\n    _proto2.adjustInto = function adjustInto(temporal, newValue) {\n        var curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));\n    };\n    _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n        var yearLong = fieldValues.get(ChronoField.YEAR);\n        var qoyLong = fieldValues.get(QUARTER_OF_YEAR);\n        if (yearLong == null || qoyLong == null) {\n            return null;\n        }\n        var y = ChronoField.YEAR.checkValidIntValue(yearLong);\n        var doq = fieldValues.get(DAY_OF_QUARTER);\n        var date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            var qoy = qoyLong;\n            date = LocalDate.of(y, 1, 1);\n            date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));\n            date = date.plusDays(MathUtil.safeSubtract(doq, 1));\n        } else {\n            var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                var max = 92;\n                if (_qoy === 1) {\n                    max = IsoChronology.isLeapYear(y) ? 91 : 90;\n                } else if (_qoy === 2) {\n                    max = 91;\n                }\n                ValueRange.of(1, max).checkValidValue(doq, this);\n            } else {\n                this.range().checkValidValue(doq, this);\n            }\n            date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(ChronoField.YEAR);\n        fieldValues.remove(QUARTER_OF_YEAR);\n        return date;\n    };\n    return DAY_OF_QUARTER_FIELD;\n}(Field);\nvar QUARTER_OF_YEAR_FIELD = function(_Field2) {\n    _inheritsLoose(QUARTER_OF_YEAR_FIELD, _Field2);\n    function QUARTER_OF_YEAR_FIELD() {\n        return _Field2.apply(this, arguments) || this;\n    }\n    var _proto3 = QUARTER_OF_YEAR_FIELD.prototype;\n    _proto3.toString = function toString() {\n        return \"QuarterOfYear\";\n    };\n    _proto3.baseUnit = function baseUnit() {\n        return QUARTER_YEARS;\n    };\n    _proto3.rangeUnit = function rangeUnit() {\n        return ChronoUnit.YEARS;\n    };\n    _proto3.range = function range() {\n        return ValueRange.of(1, 4);\n    };\n    _proto3.isSupportedBy = function isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);\n    };\n    _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {\n        return this.range();\n    };\n    _proto3.getFrom = function getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: QuarterOfYear\");\n        }\n        var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);\n        return MathUtil.intDiv(moy + 2, 3);\n    };\n    _proto3.adjustInto = function adjustInto(temporal, newValue) {\n        var curValue = this.getFrom(temporal);\n        this.range().checkValidValue(newValue, this);\n        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);\n    };\n    return QUARTER_OF_YEAR_FIELD;\n}(Field);\nvar WEEK_OF_WEEK_BASED_YEAR_FIELD = function(_Field3) {\n    _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);\n    function WEEK_OF_WEEK_BASED_YEAR_FIELD() {\n        return _Field3.apply(this, arguments) || this;\n    }\n    var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype;\n    _proto4.toString = function toString() {\n        return \"WeekOfWeekBasedYear\";\n    };\n    _proto4.baseUnit = function baseUnit() {\n        return ChronoUnit.WEEKS;\n    };\n    _proto4.rangeUnit = function rangeUnit() {\n        return WEEK_BASED_YEARS;\n    };\n    _proto4.range = function range() {\n        return ValueRange.of(1, 52, 53);\n    };\n    _proto4.isSupportedBy = function isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    };\n    _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: WeekOfWeekBasedYear\");\n        }\n        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));\n    };\n    _proto4.getFrom = function getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: WeekOfWeekBasedYear\");\n        }\n        return Field._getWeek(LocalDate.from(temporal));\n    };\n    _proto4.adjustInto = function adjustInto(temporal, newValue) {\n        this.range().checkValidValue(newValue, this);\n        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);\n    };\n    _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {\n        var wbyLong = fieldValues.get(WEEK_BASED_YEAR);\n        var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);\n        if (wbyLong == null || dowLong == null) {\n            return null;\n        }\n        var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);\n        var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);\n        var date;\n        if (resolverStyle === ResolverStyle.LENIENT) {\n            var dow = dowLong;\n            var weeks = 0;\n            if (dow > 7) {\n                weeks = MathUtil.intDiv(dow - 1, 7);\n                dow = MathUtil.intMod(dow - 1, 7) + 1;\n            } else if (dow < 1) {\n                weeks = MathUtil.intDiv(dow, 7) - 1;\n                dow = MathUtil.intMod(dow, 7) + 7;\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);\n        } else {\n            var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);\n            if (resolverStyle === ResolverStyle.STRICT) {\n                var temp = LocalDate.of(wby, 1, 4);\n                var range = Field._getWeekRangeByLocalDate(temp);\n                range.checkValidValue(wowby, this);\n            } else {\n                this.range().checkValidValue(wowby, this);\n            }\n            date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);\n        }\n        fieldValues.remove(this);\n        fieldValues.remove(WEEK_BASED_YEAR);\n        fieldValues.remove(ChronoField.DAY_OF_WEEK);\n        return date;\n    };\n    _proto4.displayName = function displayName() {\n        return \"Week\";\n    };\n    return WEEK_OF_WEEK_BASED_YEAR_FIELD;\n}(Field);\nvar WEEK_BASED_YEAR_FIELD = function(_Field4) {\n    _inheritsLoose(WEEK_BASED_YEAR_FIELD, _Field4);\n    function WEEK_BASED_YEAR_FIELD() {\n        return _Field4.apply(this, arguments) || this;\n    }\n    var _proto5 = WEEK_BASED_YEAR_FIELD.prototype;\n    _proto5.toString = function toString() {\n        return \"WeekBasedYear\";\n    };\n    _proto5.baseUnit = function baseUnit() {\n        return WEEK_BASED_YEARS;\n    };\n    _proto5.rangeUnit = function rangeUnit() {\n        return ChronoUnit.FOREVER;\n    };\n    _proto5.range = function range() {\n        return ChronoField.YEAR.range();\n    };\n    _proto5.isSupportedBy = function isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);\n    };\n    _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {\n        return ChronoField.YEAR.range();\n    };\n    _proto5.getFrom = function getFrom(temporal) {\n        if (temporal.isSupported(this) === false) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: WeekBasedYear\");\n        }\n        return Field._getWeekBasedYear(LocalDate.from(temporal));\n    };\n    _proto5.adjustInto = function adjustInto(temporal, newValue) {\n        if (this.isSupportedBy(temporal) === false) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: WeekBasedYear\");\n        }\n        var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);\n        var date = LocalDate.from(temporal);\n        var dow = date.get(ChronoField.DAY_OF_WEEK);\n        var week = Field._getWeek(date);\n        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {\n            week = 52;\n        }\n        var resolved = LocalDate.of(newWby, 1, 4);\n        var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;\n        resolved = resolved.plusDays(days);\n        return temporal.with(resolved);\n    };\n    return WEEK_BASED_YEAR_FIELD;\n}(Field);\nvar Unit = function(_TemporalUnit) {\n    _inheritsLoose(Unit, _TemporalUnit);\n    function Unit(name, estimatedDuration) {\n        var _this;\n        _this = _TemporalUnit.call(this) || this;\n        _this._name = name;\n        _this._duration = estimatedDuration;\n        return _this;\n    }\n    var _proto6 = Unit.prototype;\n    _proto6.duration = function duration() {\n        return this._duration;\n    };\n    _proto6.isDurationEstimated = function isDurationEstimated() {\n        return true;\n    };\n    _proto6.isDateBased = function isDateBased() {\n        return true;\n    };\n    _proto6.isTimeBased = function isTimeBased() {\n        return false;\n    };\n    _proto6.isSupportedBy = function isSupportedBy(temporal) {\n        return temporal.isSupported(ChronoField.EPOCH_DAY);\n    };\n    _proto6.addTo = function addTo(temporal, periodToAdd) {\n        switch(this){\n            case WEEK_BASED_YEARS:\n                {\n                    var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);\n                    return temporal.with(WEEK_BASED_YEAR, added);\n                }\n            case QUARTER_YEARS:\n                return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);\n            default:\n                throw new IllegalStateException(\"Unreachable\");\n        }\n    };\n    _proto6.between = function between(temporal1, temporal2) {\n        switch(this){\n            case WEEK_BASED_YEARS:\n                return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));\n            case QUARTER_YEARS:\n                return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);\n            default:\n                throw new IllegalStateException(\"Unreachable\");\n        }\n    };\n    _proto6.toString = function toString() {\n        return this._name;\n    };\n    return Unit;\n}(TemporalUnit);\nvar DAY_OF_QUARTER = null;\nvar QUARTER_OF_YEAR = null;\nvar WEEK_OF_WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEAR = null;\nvar WEEK_BASED_YEARS = null;\nvar QUARTER_YEARS = null;\nfunction _init$f() {\n    DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();\n    QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();\n    WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();\n    WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();\n    WEEK_BASED_YEARS = new Unit(\"WeekBasedYears\", Duration.ofSeconds(31556952));\n    QUARTER_YEARS = new Unit(\"QuarterYears\", Duration.ofSeconds(31556952 / 4));\n    IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;\n    IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;\n    IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;\n    IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;\n    IsoFields.QUARTER_YEARS = QUARTER_YEARS;\n    LocalDate.prototype.isoWeekOfWeekyear = function() {\n        return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);\n    };\n    LocalDate.prototype.isoWeekyear = function() {\n        return this.get(IsoFields.WEEK_BASED_YEAR);\n    };\n}\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var DecimalStyle = function() {\n    function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {\n        this._zeroDigit = zeroChar;\n        this._zeroDigitCharCode = zeroChar.charCodeAt(0);\n        this._positiveSign = positiveSignChar;\n        this._negativeSign = negativeSignChar;\n        this._decimalSeparator = decimalPointChar;\n    }\n    var _proto = DecimalStyle.prototype;\n    _proto.positiveSign = function positiveSign() {\n        return this._positiveSign;\n    };\n    _proto.withPositiveSign = function withPositiveSign(positiveSign) {\n        if (positiveSign === this._positiveSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);\n    };\n    _proto.negativeSign = function negativeSign() {\n        return this._negativeSign;\n    };\n    _proto.withNegativeSign = function withNegativeSign(negativeSign) {\n        if (negativeSign === this._negativeSign) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);\n    };\n    _proto.zeroDigit = function zeroDigit() {\n        return this._zeroDigit;\n    };\n    _proto.withZeroDigit = function withZeroDigit(zeroDigit) {\n        if (zeroDigit === this._zeroDigit) {\n            return this;\n        }\n        return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);\n    };\n    _proto.decimalSeparator = function decimalSeparator() {\n        return this._decimalSeparator;\n    };\n    _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {\n        if (decimalSeparator === this._decimalSeparator) {\n            return this;\n        }\n        return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);\n    };\n    _proto.convertToDigit = function convertToDigit(char) {\n        var val = char.charCodeAt(0) - this._zeroDigitCharCode;\n        return val >= 0 && val <= 9 ? val : -1;\n    };\n    _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {\n        if (this._zeroDigit === \"0\") {\n            return numericText;\n        }\n        var diff = this._zeroDigitCharCode - \"0\".charCodeAt(0);\n        var convertedText = \"\";\n        for(var i = 0; i < numericText.length; i++){\n            convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);\n        }\n        return convertedText;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof DecimalStyle) {\n            return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;\n    };\n    _proto.toString = function toString() {\n        return \"DecimalStyle[\" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + \"]\";\n    };\n    DecimalStyle.of = function of() {\n        throw new Error(\"not yet supported\");\n    };\n    DecimalStyle.availableLocales = function availableLocales() {\n        throw new Error(\"not yet supported\");\n    };\n    return DecimalStyle;\n}();\nDecimalStyle.STANDARD = new DecimalStyle(\"0\", \"+\", \"-\", \".\");\nvar SignStyle = function(_Enum) {\n    _inheritsLoose(SignStyle, _Enum);\n    function SignStyle() {\n        return _Enum.apply(this, arguments) || this;\n    }\n    var _proto = SignStyle.prototype;\n    _proto.parse = function parse(positive, strict, fixedWidth) {\n        switch(this){\n            case SignStyle.NORMAL:\n                return !positive || !strict;\n            case SignStyle.ALWAYS:\n            case SignStyle.EXCEEDS_PAD:\n                return true;\n            default:\n                return !strict && !fixedWidth;\n        }\n    };\n    return SignStyle;\n}(Enum);\nSignStyle.NORMAL = new SignStyle(\"NORMAL\");\nSignStyle.NEVER = new SignStyle(\"NEVER\");\nSignStyle.ALWAYS = new SignStyle(\"ALWAYS\");\nSignStyle.EXCEEDS_PAD = new SignStyle(\"EXCEEDS_PAD\");\nSignStyle.NOT_NEGATIVE = new SignStyle(\"NOT_NEGATIVE\");\nvar TextStyle = function(_Enum) {\n    _inheritsLoose(TextStyle, _Enum);\n    function TextStyle() {\n        return _Enum.apply(this, arguments) || this;\n    }\n    var _proto = TextStyle.prototype;\n    _proto.isStandalone = function isStandalone() {\n        switch(this){\n            case TextStyle.FULL_STANDALONE:\n            case TextStyle.SHORT_STANDALONE:\n            case TextStyle.NARROW_STANDALONE:\n                return true;\n            default:\n                return false;\n        }\n    };\n    _proto.asStandalone = function asStandalone() {\n        switch(this){\n            case TextStyle.FULL:\n                return TextStyle.FULL_STANDALONE;\n            case TextStyle.SHORT:\n                return TextStyle.SHORT_STANDALONE;\n            case TextStyle.NARROW:\n                return TextStyle.NARROW_STANDALONE;\n            default:\n                return this;\n        }\n    };\n    _proto.asNormal = function asNormal() {\n        switch(this){\n            case TextStyle.FULL_STANDALONE:\n                return TextStyle.FULL;\n            case TextStyle.SHORT_STANDALONE:\n                return TextStyle.SHORT;\n            case TextStyle.NARROW_STANDALONE:\n                return TextStyle.NARROW;\n            default:\n                return this;\n        }\n    };\n    return TextStyle;\n}(Enum);\nTextStyle.FULL = new TextStyle(\"FULL\");\nTextStyle.FULL_STANDALONE = new TextStyle(\"FULL_STANDALONE\");\nTextStyle.SHORT = new TextStyle(\"SHORT\");\nTextStyle.SHORT_STANDALONE = new TextStyle(\"SHORT_STANDALONE\");\nTextStyle.NARROW = new TextStyle(\"NARROW\");\nTextStyle.NARROW_STANDALONE = new TextStyle(\"NARROW_STANDALONE\");\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var CharLiteralPrinterParser = function() {\n    function CharLiteralPrinterParser(literal) {\n        if (literal.length > 1) {\n            throw new IllegalArgumentException('invalid literal, too long: \"' + literal + '\"');\n        }\n        this._literal = literal;\n    }\n    var _proto = CharLiteralPrinterParser.prototype;\n    _proto.print = function print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        var length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        var ch = text.charAt(position);\n        if (context.charEquals(this._literal, ch) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    };\n    _proto.toString = function toString() {\n        if (this._literal === \"'\") {\n            return \"''\";\n        }\n        return \"'\" + this._literal + \"'\";\n    };\n    return CharLiteralPrinterParser;\n}();\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var CompositePrinterParser = function() {\n    function CompositePrinterParser(printerParsers, optional) {\n        this._printerParsers = printerParsers;\n        this._optional = optional;\n    }\n    var _proto = CompositePrinterParser.prototype;\n    _proto.withOptional = function withOptional(optional) {\n        if (optional === this._optional) {\n            return this;\n        }\n        return new CompositePrinterParser(this._printerParsers, optional);\n    };\n    _proto.print = function print(context, buf) {\n        var length = buf.length();\n        if (this._optional) {\n            context.startOptional();\n        }\n        try {\n            for(var i = 0; i < this._printerParsers.length; i++){\n                var pp = this._printerParsers[i];\n                if (pp.print(context, buf) === false) {\n                    buf.setLength(length);\n                    return true;\n                }\n            }\n        } finally{\n            if (this._optional) {\n                context.endOptional();\n            }\n        }\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        if (this._optional) {\n            context.startOptional();\n            var pos = position;\n            for(var i = 0; i < this._printerParsers.length; i++){\n                var pp = this._printerParsers[i];\n                pos = pp.parse(context, text, pos);\n                if (pos < 0) {\n                    context.endOptional(false);\n                    return position;\n                }\n            }\n            context.endOptional(true);\n            return pos;\n        } else {\n            for(var _i = 0; _i < this._printerParsers.length; _i++){\n                var _pp = this._printerParsers[_i];\n                position = _pp.parse(context, text, position);\n                if (position < 0) {\n                    break;\n                }\n            }\n            return position;\n        }\n    };\n    _proto.toString = function toString() {\n        var buf = \"\";\n        if (this._printerParsers != null) {\n            buf += this._optional ? \"[\" : \"(\";\n            for(var i = 0; i < this._printerParsers.length; i++){\n                var pp = this._printerParsers[i];\n                buf += pp.toString();\n            }\n            buf += this._optional ? \"]\" : \")\";\n        }\n        return buf;\n    };\n    return CompositePrinterParser;\n}();\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var FractionPrinterParser = function() {\n    function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {\n        requireNonNull(field, \"field\");\n        if (field.range().isFixed() === false) {\n            throw new IllegalArgumentException(\"Field must have a fixed set of values: \" + field);\n        }\n        if (minWidth < 0 || minWidth > 9) {\n            throw new IllegalArgumentException(\"Minimum width must be from 0 to 9 inclusive but was \" + minWidth);\n        }\n        if (maxWidth < 1 || maxWidth > 9) {\n            throw new IllegalArgumentException(\"Maximum width must be from 1 to 9 inclusive but was \" + maxWidth);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException(\"Maximum width must exceed or equal the minimum width but \" + maxWidth + \" < \" + minWidth);\n        }\n        this.field = field;\n        this.minWidth = minWidth;\n        this.maxWidth = maxWidth;\n        this.decimalPoint = decimalPoint;\n    }\n    var _proto = FractionPrinterParser.prototype;\n    _proto.print = function print(context, buf) {\n        var value = context.getValue(this.field);\n        if (value === null) {\n            return false;\n        }\n        var symbols = context.symbols();\n        if (value === 0) {\n            if (this.minWidth > 0) {\n                if (this.decimalPoint) {\n                    buf.append(symbols.decimalSeparator());\n                }\n                for(var i = 0; i < this.minWidth; i++){\n                    buf.append(symbols.zeroDigit());\n                }\n            }\n        } else {\n            var fraction = this.convertToFraction(value, symbols.zeroDigit());\n            var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);\n            fraction = fraction.substr(0, outputScale);\n            if (fraction * 1 > 0) {\n                while(fraction.length > this.minWidth && fraction[fraction.length - 1] === \"0\"){\n                    fraction = fraction.substr(0, fraction.length - 1);\n                }\n            }\n            var str = fraction;\n            str = symbols.convertNumberToI18N(str);\n            if (this.decimalPoint) {\n                buf.append(symbols.decimalSeparator());\n            }\n            buf.append(str);\n        }\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        var effectiveMin = context.isStrict() ? this.minWidth : 0;\n        var effectiveMax = context.isStrict() ? this.maxWidth : 9;\n        var length = text.length;\n        if (position === length) {\n            return effectiveMin > 0 ? ~position : position;\n        }\n        if (this.decimalPoint) {\n            if (text[position] !== context.symbols().decimalSeparator()) {\n                return effectiveMin > 0 ? ~position : position;\n            }\n            position++;\n        }\n        var minEndPos = position + effectiveMin;\n        if (minEndPos > length) {\n            return ~position;\n        }\n        var maxEndPos = Math.min(position + effectiveMax, length);\n        var total = 0;\n        var pos = position;\n        while(pos < maxEndPos){\n            var ch = text.charAt(pos++);\n            var digit = context.symbols().convertToDigit(ch);\n            if (digit < 0) {\n                if (pos < minEndPos) {\n                    return ~position;\n                }\n                pos--;\n                break;\n            }\n            total = total * 10 + digit;\n        }\n        var moveLeft = pos - position;\n        var scale = Math.pow(10, moveLeft);\n        var value = this.convertFromFraction(total, scale);\n        return context.setParsedField(this.field, value, position, pos);\n    };\n    _proto.convertToFraction = function convertToFraction(value, zeroDigit) {\n        var range = this.field.range();\n        range.checkValidValue(value, this.field);\n        var _min = range.minimum();\n        var _range = range.maximum() - _min + 1;\n        var _value = value - _min;\n        var _scaled = MathUtil.intDiv(_value * 1000000000, _range);\n        var fraction = \"\" + _scaled;\n        while(fraction.length < 9){\n            fraction = zeroDigit + fraction;\n        }\n        return fraction;\n    };\n    _proto.convertFromFraction = function convertFromFraction(total, scale) {\n        var range = this.field.range();\n        var _min = range.minimum();\n        var _range = range.maximum() - _min + 1;\n        var _value = MathUtil.intDiv(total * _range, scale);\n        return _value;\n    };\n    _proto.toString = function toString() {\n        var decimal = this.decimalPoint ? \",DecimalPoint\" : \"\";\n        return \"Fraction(\" + this.field + \",\" + this.minWidth + \",\" + this.maxWidth + decimal + \")\";\n    };\n    return FractionPrinterParser;\n}();\nvar MAX_WIDTH$1 = 15;\nvar EXCEED_POINTS = [\n    0,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000\n];\nvar NumberPrinterParser = function() {\n    function NumberPrinterParser(field, minWidth, maxWidth, signStyle, subsequentWidth) {\n        if (subsequentWidth === void 0) {\n            subsequentWidth = 0;\n        }\n        this._field = field;\n        this._minWidth = minWidth;\n        this._maxWidth = maxWidth;\n        this._signStyle = signStyle;\n        this._subsequentWidth = subsequentWidth;\n    }\n    var _proto = NumberPrinterParser.prototype;\n    _proto.field = function field() {\n        return this._field;\n    };\n    _proto.minWidth = function minWidth() {\n        return this._minWidth;\n    };\n    _proto.maxWidth = function maxWidth() {\n        return this._maxWidth;\n    };\n    _proto.signStyle = function signStyle() {\n        return this._signStyle;\n    };\n    _proto.withFixedWidth = function withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);\n    };\n    _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n        return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);\n    };\n    _proto._isFixedWidth = function _isFixedWidth() {\n        return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;\n    };\n    _proto.print = function print(context, buf) {\n        var contextValue = context.getValue(this._field);\n        if (contextValue == null) {\n            return false;\n        }\n        var value = this._getValue(context, contextValue);\n        var symbols = context.symbols();\n        var str = \"\" + Math.abs(value);\n        if (str.length > this._maxWidth) {\n            throw new DateTimeException(\"Field \" + this._field + \" cannot be printed as the value \" + value + \" exceeds the maximum print width of \" + this._maxWidth);\n        }\n        str = symbols.convertNumberToI18N(str);\n        if (value >= 0) {\n            switch(this._signStyle){\n                case SignStyle.EXCEEDS_PAD:\n                    if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {\n                        buf.append(symbols.positiveSign());\n                    }\n                    break;\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.positiveSign());\n                    break;\n            }\n        } else {\n            switch(this._signStyle){\n                case SignStyle.NORMAL:\n                case SignStyle.EXCEEDS_PAD:\n                case SignStyle.ALWAYS:\n                    buf.append(symbols.negativeSign());\n                    break;\n                case SignStyle.NOT_NEGATIVE:\n                    throw new DateTimeException(\"Field \" + this._field + \" cannot be printed as the value \" + value + \" cannot be negative according to the SignStyle\");\n            }\n        }\n        for(var i = 0; i < this._minWidth - str.length; i++){\n            buf.append(symbols.zeroDigit());\n        }\n        buf.append(str);\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        var length = text.length;\n        if (position === length) {\n            return ~position;\n        }\n        assert(position >= 0 && position < length);\n        var sign = text.charAt(position);\n        var negative = false;\n        var positive = false;\n        if (sign === context.symbols().positiveSign()) {\n            if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            positive = true;\n            position++;\n        } else if (sign === context.symbols().negativeSign()) {\n            if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {\n                return ~position;\n            }\n            negative = true;\n            position++;\n        } else {\n            if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {\n                return ~position;\n            }\n        }\n        var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;\n        var minEndPos = position + effMinWidth;\n        if (minEndPos > length) {\n            return ~position;\n        }\n        var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);\n        var total = 0;\n        var pos = position;\n        for(var pass = 0; pass < 2; pass++){\n            var maxEndPos = Math.min(pos + effMaxWidth, length);\n            while(pos < maxEndPos){\n                var ch = text.charAt(pos++);\n                var digit = context.symbols().convertToDigit(ch);\n                if (digit < 0) {\n                    pos--;\n                    if (pos < minEndPos) {\n                        return ~position;\n                    }\n                    break;\n                }\n                if (pos - position > MAX_WIDTH$1) {\n                    throw new ArithmeticException(\"number text exceeds length\");\n                } else {\n                    total = total * 10 + digit;\n                }\n            }\n            if (this._subsequentWidth > 0 && pass === 0) {\n                var parseLen = pos - position;\n                effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);\n                pos = position;\n                total = 0;\n            } else {\n                break;\n            }\n        }\n        if (negative) {\n            if (total === 0 && context.isStrict()) {\n                return ~(position - 1);\n            }\n            if (total !== 0) {\n                total = -total;\n            }\n        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {\n            var _parseLen = pos - position;\n            if (positive) {\n                if (_parseLen <= this._minWidth) {\n                    return ~(position - 1);\n                }\n            } else {\n                if (_parseLen > this._minWidth) {\n                    return ~position;\n                }\n            }\n        }\n        return this._setValue(context, total, position, pos);\n    };\n    _proto._getValue = function _getValue(context, value) {\n        return value;\n    };\n    _proto._setValue = function _setValue(context, value, errorPos, successPos) {\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    };\n    _proto.toString = function toString() {\n        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {\n            return \"Value(\" + this._field + \")\";\n        }\n        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {\n            return \"Value(\" + this._field + \",\" + this._minWidth + \")\";\n        }\n        return \"Value(\" + this._field + \",\" + this._minWidth + \",\" + this._maxWidth + \",\" + this._signStyle + \")\";\n    };\n    return NumberPrinterParser;\n}();\nvar ReducedPrinterParser = function(_NumberPrinterParser) {\n    _inheritsLoose(ReducedPrinterParser, _NumberPrinterParser);\n    function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {\n        var _this;\n        _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;\n        if (width < 1 || width > 10) {\n            throw new IllegalArgumentException(\"The width must be from 1 to 10 inclusive but was \" + width);\n        }\n        if (maxWidth < 1 || maxWidth > 10) {\n            throw new IllegalArgumentException(\"The maxWidth must be from 1 to 10 inclusive but was \" + maxWidth);\n        }\n        if (maxWidth < width) {\n            throw new IllegalArgumentException(\"The maxWidth must be greater than the width\");\n        }\n        if (baseDate === null) {\n            if (field.range().isValidValue(baseValue) === false) {\n                throw new IllegalArgumentException(\"The base value must be within the range of the field\");\n            }\n            if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {\n                throw new DateTimeException(\"Unable to add printer-parser as the range exceeds the capacity of an int\");\n            }\n        }\n        _this._baseValue = baseValue;\n        _this._baseDate = baseDate;\n        return _this;\n    }\n    var _proto2 = ReducedPrinterParser.prototype;\n    _proto2._getValue = function _getValue(context, value) {\n        var absValue = Math.abs(value);\n        var baseValue = this._baseValue;\n        if (this._baseDate !== null) {\n            context.temporal();\n            var chrono = IsoChronology.INSTANCE;\n            baseValue = chrono.date(this._baseDate).get(this._field);\n        }\n        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {\n            return absValue % EXCEED_POINTS[this._minWidth];\n        }\n        return absValue % EXCEED_POINTS[this._maxWidth];\n    };\n    _proto2._setValue = function _setValue(context, value, errorPos, successPos) {\n        var baseValue = this._baseValue;\n        if (this._baseDate != null) {\n            var chrono = context.getEffectiveChronology();\n            baseValue = chrono.date(this._baseDate).get(this._field);\n        }\n        var parseLen = successPos - errorPos;\n        if (parseLen === this._minWidth && value >= 0) {\n            var range = EXCEED_POINTS[this._minWidth];\n            var lastPart = baseValue % range;\n            var basePart = baseValue - lastPart;\n            if (baseValue > 0) {\n                value = basePart + value;\n            } else {\n                value = basePart - value;\n            }\n            if (value < baseValue) {\n                value += range;\n            }\n        }\n        return context.setParsedField(this._field, value, errorPos, successPos);\n    };\n    _proto2.withFixedWidth = function withFixedWidth() {\n        if (this._subsequentWidth === -1) {\n            return this;\n        }\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);\n    };\n    _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {\n        return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);\n    };\n    _proto2.isFixedWidth = function isFixedWidth(context) {\n        if (context.isStrict() === false) {\n            return false;\n        }\n        return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);\n    };\n    _proto2.toString = function toString() {\n        return \"ReducedValue(\" + this._field + \",\" + this._minWidth + \",\" + this._maxWidth + \",\" + (this._baseDate != null ? this._baseDate : this._baseValue) + \")\";\n    };\n    return ReducedPrinterParser;\n}(NumberPrinterParser);\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var PATTERNS = [\n    \"+HH\",\n    \"+HHmm\",\n    \"+HH:mm\",\n    \"+HHMM\",\n    \"+HH:MM\",\n    \"+HHMMss\",\n    \"+HH:MM:ss\",\n    \"+HHMMSS\",\n    \"+HH:MM:SS\"\n];\nvar OffsetIdPrinterParser = function() {\n    function OffsetIdPrinterParser(noOffsetText, pattern) {\n        requireNonNull(noOffsetText, \"noOffsetText\");\n        requireNonNull(pattern, \"pattern\");\n        this.noOffsetText = noOffsetText;\n        this.type = this._checkPattern(pattern);\n    }\n    var _proto = OffsetIdPrinterParser.prototype;\n    _proto._checkPattern = function _checkPattern(pattern) {\n        for(var i = 0; i < PATTERNS.length; i++){\n            if (PATTERNS[i] === pattern) {\n                return i;\n            }\n        }\n        throw new IllegalArgumentException(\"Invalid zone offset pattern: \" + pattern);\n    };\n    _proto.print = function print(context, buf) {\n        var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);\n        if (offsetSecs == null) {\n            return false;\n        }\n        var totalSecs = MathUtil.safeToInt(offsetSecs);\n        if (totalSecs === 0) {\n            buf.append(this.noOffsetText);\n        } else {\n            var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));\n            var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));\n            var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));\n            var bufPos = buf.length();\n            var output = absHours;\n            buf.append(totalSecs < 0 ? \"-\" : \"+\").appendChar(MathUtil.intDiv(absHours, 10) + \"0\").appendChar(MathUtil.intMod(absHours, 10) + \"0\");\n            if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {\n                buf.append(this.type % 2 === 0 ? \":\" : \"\").appendChar(MathUtil.intDiv(absMinutes, 10) + \"0\").appendChar(absMinutes % 10 + \"0\");\n                output += absMinutes;\n                if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {\n                    buf.append(this.type % 2 === 0 ? \":\" : \"\").appendChar(MathUtil.intDiv(absSeconds, 10) + \"0\").appendChar(absSeconds % 10 + \"0\");\n                    output += absSeconds;\n                }\n            }\n            if (output === 0) {\n                buf.setLength(bufPos);\n                buf.append(this.noOffsetText);\n            }\n        }\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        var length = text.length;\n        var noOffsetLen = this.noOffsetText.length;\n        if (noOffsetLen === 0) {\n            if (position === length) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);\n            }\n        } else {\n            if (position === length) {\n                return ~position;\n            }\n            if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n            }\n        }\n        var sign = text[position];\n        if (sign === \"+\" || sign === \"-\") {\n            var negative = sign === \"-\" ? -1 : 1;\n            var array = [\n                0,\n                0,\n                0,\n                0\n            ];\n            array[0] = position + 1;\n            if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {\n                var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));\n                return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);\n            }\n        }\n        if (noOffsetLen === 0) {\n            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);\n        }\n        return ~position;\n    };\n    _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {\n        if ((this.type + 3) / 2 < arrayIndex) {\n            return false;\n        }\n        var pos = array[0];\n        if (this.type % 2 === 0 && arrayIndex > 1) {\n            if (pos + 1 > parseText.length || parseText[pos] !== \":\") {\n                return required;\n            }\n            pos++;\n        }\n        if (pos + 2 > parseText.length) {\n            return required;\n        }\n        var ch1 = parseText[pos++];\n        var ch2 = parseText[pos++];\n        if (ch1 < \"0\" || ch1 > \"9\" || ch2 < \"0\" || ch2 > \"9\") {\n            return required;\n        }\n        var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);\n        if (value < 0 || value > 59) {\n            return required;\n        }\n        array[arrayIndex] = value;\n        array[0] = pos;\n        return false;\n    };\n    _proto.toString = function toString() {\n        var converted = this.noOffsetText.replace(\"'\", \"''\");\n        return \"Offset(\" + PATTERNS[this.type] + \",'\" + converted + \"')\";\n    };\n    return OffsetIdPrinterParser;\n}();\nOffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser(\"Z\", \"+HH:MM:ss\");\nOffsetIdPrinterParser.PATTERNS = PATTERNS;\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var PadPrinterParserDecorator = function() {\n    function PadPrinterParserDecorator(printerParser, padWidth, padChar) {\n        this._printerParser = printerParser;\n        this._padWidth = padWidth;\n        this._padChar = padChar;\n    }\n    var _proto = PadPrinterParserDecorator.prototype;\n    _proto.print = function print(context, buf) {\n        var preLen = buf.length();\n        if (this._printerParser.print(context, buf) === false) {\n            return false;\n        }\n        var len = buf.length() - preLen;\n        if (len > this._padWidth) {\n            throw new DateTimeException(\"Cannot print as output of \" + len + \" characters exceeds pad width of \" + this._padWidth);\n        }\n        for(var i = 0; i < this._padWidth - len; i++){\n            buf.insert(preLen, this._padChar);\n        }\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        var strict = context.isStrict();\n        var caseSensitive = context.isCaseSensitive();\n        assert(!(position > text.length));\n        assert(position >= 0);\n        if (position === text.length) {\n            return ~position;\n        }\n        var endPos = position + this._padWidth;\n        if (endPos > text.length) {\n            if (strict) {\n                return ~position;\n            }\n            endPos = text.length;\n        }\n        var pos = position;\n        while(pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))){\n            pos++;\n        }\n        text = text.substring(0, endPos);\n        var resultPos = this._printerParser.parse(context, text, pos);\n        if (resultPos !== endPos && strict) {\n            return ~(position + pos);\n        }\n        return resultPos;\n    };\n    _proto.toString = function toString() {\n        return \"Pad(\" + this._printerParser + \",\" + this._padWidth + (this._padChar === \" \" ? \")\" : \",'\" + this._padChar + \"')\");\n    };\n    return PadPrinterParserDecorator;\n}();\nvar SettingsParser = function(_Enum) {\n    _inheritsLoose(SettingsParser, _Enum);\n    function SettingsParser() {\n        return _Enum.apply(this, arguments) || this;\n    }\n    var _proto = SettingsParser.prototype;\n    _proto.print = function print() {\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        switch(this){\n            case SettingsParser.SENSITIVE:\n                context.setCaseSensitive(true);\n                break;\n            case SettingsParser.INSENSITIVE:\n                context.setCaseSensitive(false);\n                break;\n            case SettingsParser.STRICT:\n                context.setStrict(true);\n                break;\n            case SettingsParser.LENIENT:\n                context.setStrict(false);\n                break;\n        }\n        return position;\n    };\n    _proto.toString = function toString() {\n        switch(this){\n            case SettingsParser.SENSITIVE:\n                return \"ParseCaseSensitive(true)\";\n            case SettingsParser.INSENSITIVE:\n                return \"ParseCaseSensitive(false)\";\n            case SettingsParser.STRICT:\n                return \"ParseStrict(true)\";\n            case SettingsParser.LENIENT:\n                return \"ParseStrict(false)\";\n        }\n    };\n    return SettingsParser;\n}(Enum);\nSettingsParser.SENSITIVE = new SettingsParser(\"SENSITIVE\");\nSettingsParser.INSENSITIVE = new SettingsParser(\"INSENSITIVE\");\nSettingsParser.STRICT = new SettingsParser(\"STRICT\");\nSettingsParser.LENIENT = new SettingsParser(\"LENIENT\");\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var StringLiteralPrinterParser = function() {\n    function StringLiteralPrinterParser(literal) {\n        this._literal = literal;\n    }\n    var _proto = StringLiteralPrinterParser.prototype;\n    _proto.print = function print(context, buf) {\n        buf.append(this._literal);\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        var length = text.length;\n        assert(!(position > length || position < 0));\n        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {\n            return ~position;\n        }\n        return position + this._literal.length;\n    };\n    _proto.toString = function toString() {\n        var converted = this._literal.replace(\"'\", \"''\");\n        return \"'\" + converted + \"'\";\n    };\n    return StringLiteralPrinterParser;\n}();\n/*\n * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ZoneRulesProvider = function() {\n    function ZoneRulesProvider() {}\n    ZoneRulesProvider.getRules = function getRules(zoneId) {\n        throw new DateTimeException(\"unsupported ZoneId:\" + zoneId);\n    };\n    ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {\n        return [];\n    };\n    return ZoneRulesProvider;\n}();\nvar ZoneRegion = function(_ZoneId) {\n    _inheritsLoose(ZoneRegion, _ZoneId);\n    ZoneRegion.ofId = function ofId(zoneId) {\n        var rules = ZoneRulesProvider.getRules(zoneId);\n        return new ZoneRegion(zoneId, rules);\n    };\n    function ZoneRegion(id, rules) {\n        var _this;\n        _this = _ZoneId.call(this) || this;\n        _this._id = id;\n        _this._rules = rules;\n        return _this;\n    }\n    var _proto = ZoneRegion.prototype;\n    _proto.id = function id() {\n        return this._id;\n    };\n    _proto.rules = function rules() {\n        return this._rules;\n    };\n    return ZoneRegion;\n}(ZoneId);\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ZoneIdPrinterParser = function() {\n    function ZoneIdPrinterParser(query, description) {\n        this.query = query;\n        this.description = description;\n    }\n    var _proto = ZoneIdPrinterParser.prototype;\n    _proto.print = function print(context, buf) {\n        var zone = context.getValueQuery(this.query);\n        if (zone == null) {\n            return false;\n        }\n        buf.append(zone.id());\n        return true;\n    };\n    _proto.parse = function parse(context, text, position) {\n        var length = text.length;\n        if (position > length) {\n            return ~position;\n        }\n        if (position === length) {\n            return ~position;\n        }\n        var nextChar = text.charAt(position);\n        if (nextChar === \"+\" || nextChar === \"-\") {\n            var newContext = context.copy();\n            var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n            if (endPos < 0) {\n                return endPos;\n            }\n            var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n            var zone = ZoneOffset.ofTotalSeconds(offset);\n            context.setParsedZone(zone);\n            return endPos;\n        } else if (length >= position + 2) {\n            var nextNextChar = text.charAt(position + 1);\n            if (context.charEquals(nextChar, \"U\") && context.charEquals(nextNextChar, \"T\")) {\n                if (length >= position + 3 && context.charEquals(text.charAt(position + 2), \"C\")) {\n                    return this._parsePrefixedOffset(context, text, position, position + 3);\n                }\n                return this._parsePrefixedOffset(context, text, position, position + 2);\n            } else if (context.charEquals(nextChar, \"G\") && length >= position + 3 && context.charEquals(nextNextChar, \"M\") && context.charEquals(text.charAt(position + 2), \"T\")) {\n                return this._parsePrefixedOffset(context, text, position, position + 3);\n            }\n        }\n        if (text.substr(position, 6) === \"SYSTEM\") {\n            context.setParsedZone(ZoneId.systemDefault());\n            return position + 6;\n        }\n        if (context.charEquals(nextChar, \"Z\")) {\n            context.setParsedZone(ZoneOffset.UTC);\n            return position + 1;\n        }\n        var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();\n        if (zoneIdTree.size !== availableZoneIds.length) {\n            zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);\n        }\n        var maxParseLength = length - position;\n        var treeMap = zoneIdTree.treeMap;\n        var parsedZoneId = null;\n        var parseLength = 0;\n        while(treeMap != null){\n            var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));\n            treeMap = treeMap.get(parsedSubZoneId);\n            if (treeMap != null && treeMap.isLeaf) {\n                parsedZoneId = parsedSubZoneId;\n                parseLength = treeMap.length;\n            }\n        }\n        if (parsedZoneId != null) {\n            context.setParsedZone(ZoneRegion.ofId(parsedZoneId));\n            return position + parseLength;\n        }\n        return ~position;\n    };\n    _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {\n        var prefix = text.substring(prefixPos, position).toUpperCase();\n        var newContext = context.copy();\n        if (position < text.length && context.charEquals(text.charAt(position), \"Z\")) {\n            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);\n        if (endPos < 0) {\n            context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));\n            return position;\n        }\n        var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);\n        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);\n        context.setParsedZone(ZoneId.ofOffset(prefix, offset));\n        return endPos;\n    };\n    _proto.toString = function toString() {\n        return this.description;\n    };\n    return ZoneIdPrinterParser;\n}();\nvar ZoneIdTree = function() {\n    ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {\n        var sortedZoneIds = availableZoneIds.sort(function(a, b) {\n            return a.length - b.length;\n        });\n        var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);\n        for(var i = 0; i < sortedZoneIds.length; i++){\n            treeMap.add(sortedZoneIds[i]);\n        }\n        return new ZoneIdTree(sortedZoneIds.length, treeMap);\n    };\n    function ZoneIdTree(size, treeMap) {\n        this.size = size;\n        this.treeMap = treeMap;\n    }\n    return ZoneIdTree;\n}();\nvar ZoneIdTreeMap = function() {\n    function ZoneIdTreeMap(length, isLeaf) {\n        if (length === void 0) {\n            length = 0;\n        }\n        if (isLeaf === void 0) {\n            isLeaf = false;\n        }\n        this.length = length;\n        this.isLeaf = isLeaf;\n        this._treeMap = {};\n    }\n    var _proto2 = ZoneIdTreeMap.prototype;\n    _proto2.add = function add(zoneId) {\n        var idLength = zoneId.length;\n        if (idLength === this.length) {\n            this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);\n        } else if (idLength > this.length) {\n            var subZoneId = zoneId.substr(0, this.length);\n            var subTreeMap = this._treeMap[subZoneId];\n            if (subTreeMap == null) {\n                subTreeMap = new ZoneIdTreeMap(idLength, false);\n                this._treeMap[subZoneId] = subTreeMap;\n            }\n            subTreeMap.add(zoneId);\n        }\n    };\n    _proto2.get = function get(zoneId) {\n        return this._treeMap[zoneId];\n    };\n    return ZoneIdTreeMap;\n}();\nvar zoneIdTree = new ZoneIdTree([]);\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var MAX_WIDTH = 15;\nvar DateTimeFormatterBuilder = function() {\n    function DateTimeFormatterBuilder() {\n        this._active = this;\n        this._parent = null;\n        this._printerParsers = [];\n        this._optional = false;\n        this._padNextWidth = 0;\n        this._padNextChar = null;\n        this._valueParserIndex = -1;\n    }\n    DateTimeFormatterBuilder._of = function _of(parent, optional) {\n        requireNonNull(parent, \"parent\");\n        requireNonNull(optional, \"optional\");\n        var dtFormatterBuilder = new DateTimeFormatterBuilder();\n        dtFormatterBuilder._parent = parent;\n        dtFormatterBuilder._optional = optional;\n        return dtFormatterBuilder;\n    };\n    var _proto = DateTimeFormatterBuilder.prototype;\n    _proto.parseCaseSensitive = function parseCaseSensitive() {\n        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);\n        return this;\n    };\n    _proto.parseCaseInsensitive = function parseCaseInsensitive() {\n        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);\n        return this;\n    };\n    _proto.parseStrict = function parseStrict() {\n        this._appendInternalPrinterParser(SettingsParser.STRICT);\n        return this;\n    };\n    _proto.parseLenient = function parseLenient() {\n        this._appendInternalPrinterParser(SettingsParser.LENIENT);\n        return this;\n    };\n    _proto.parseDefaulting = function parseDefaulting(field, value) {\n        requireNonNull(field);\n        this._appendInternal(new DefaultingParser(field, value));\n        return this;\n    };\n    _proto.appendValue = function appendValue() {\n        if (arguments.length === 1) {\n            return this._appendValue1.apply(this, arguments);\n        } else if (arguments.length === 2) {\n            return this._appendValue2.apply(this, arguments);\n        } else {\n            return this._appendValue4.apply(this, arguments);\n        }\n    };\n    _proto._appendValue1 = function _appendValue1(field) {\n        requireNonNull(field);\n        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));\n        return this;\n    };\n    _proto._appendValue2 = function _appendValue2(field, width) {\n        requireNonNull(field);\n        if (width < 1 || width > MAX_WIDTH) {\n            throw new IllegalArgumentException(\"The width must be from 1 to \" + MAX_WIDTH + \" inclusive but was \" + width);\n        }\n        var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);\n        this._appendValuePrinterParser(pp);\n        return this;\n    };\n    _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {\n        requireNonNull(field);\n        requireNonNull(signStyle);\n        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {\n            return this._appendValue2(field, maxWidth);\n        }\n        if (minWidth < 1 || minWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(\"The minimum width must be from 1 to \" + MAX_WIDTH + \" inclusive but was \" + minWidth);\n        }\n        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {\n            throw new IllegalArgumentException(\"The minimum width must be from 1 to \" + MAX_WIDTH + \" inclusive but was \" + maxWidth);\n        }\n        if (maxWidth < minWidth) {\n            throw new IllegalArgumentException(\"The maximum width must exceed or equal the minimum width but \" + maxWidth + \" < \" + minWidth);\n        }\n        var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);\n        this._appendValuePrinterParser(pp);\n        return this;\n    };\n    _proto.appendValueReduced = function appendValueReduced() {\n        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {\n            return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);\n        } else {\n            return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);\n        }\n    };\n    _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {\n        requireNonNull(field, \"field\");\n        var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);\n        this._appendValuePrinterParser(pp);\n        return this;\n    };\n    _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {\n        requireNonNull(field, \"field\");\n        requireNonNull(baseDate, \"baseDate\");\n        requireInstance(baseDate, ChronoLocalDate, \"baseDate\");\n        var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);\n        this._appendValuePrinterParser(pp);\n        return this;\n    };\n    _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {\n            var activeValueParser = this._active._valueParserIndex;\n            var basePP = this._active._printerParsers[activeValueParser];\n            if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {\n                basePP = basePP.withSubsequentWidth(pp.maxWidth());\n                this._appendInternal(pp.withFixedWidth());\n                this._active._valueParserIndex = activeValueParser;\n            } else {\n                basePP = basePP.withFixedWidth();\n                this._active._valueParserIndex = this._appendInternal(pp);\n            }\n            this._active._printerParsers[activeValueParser] = basePP;\n        } else {\n            this._active._valueParserIndex = this._appendInternal(pp);\n        }\n        return this;\n    };\n    _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {\n        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));\n        return this;\n    };\n    _proto.appendInstant = function appendInstant(fractionalDigits) {\n        if (fractionalDigits === void 0) {\n            fractionalDigits = -2;\n        }\n        if (fractionalDigits < -2 || fractionalDigits > 9) {\n            throw new IllegalArgumentException(\"Invalid fractional digits: \" + fractionalDigits);\n        }\n        this._appendInternal(new InstantPrinterParser(fractionalDigits));\n        return this;\n    };\n    _proto.appendOffsetId = function appendOffsetId() {\n        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);\n        return this;\n    };\n    _proto.appendOffset = function appendOffset(pattern, noOffsetText) {\n        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));\n        return this;\n    };\n    _proto.appendZoneId = function appendZoneId() {\n        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), \"ZoneId()\"));\n        return this;\n    };\n    _proto.appendPattern = function appendPattern(pattern) {\n        requireNonNull(pattern, \"pattern\");\n        this._parsePattern(pattern);\n        return this;\n    };\n    _proto.appendZoneText = function appendZoneText() {\n        throw new IllegalArgumentException(\"Pattern using (localized) text not implemented, use @js-joda/locale plugin!\");\n    };\n    _proto.appendText = function appendText() {\n        throw new IllegalArgumentException(\"Pattern using (localized) text not implemented, use @js-joda/locale plugin!\");\n    };\n    _proto.appendLocalizedOffset = function appendLocalizedOffset() {\n        throw new IllegalArgumentException(\"Pattern using (localized) text not implemented, use @js-joda/locale plugin!\");\n    };\n    _proto.appendWeekField = function appendWeekField() {\n        throw new IllegalArgumentException(\"Pattern using (localized) text not implemented, use @js-joda/locale plugin!\");\n    };\n    _proto._parsePattern = function _parsePattern(pattern) {\n        var FIELD_MAP = {\n            \"G\": ChronoField.ERA,\n            \"y\": ChronoField.YEAR_OF_ERA,\n            \"u\": ChronoField.YEAR,\n            \"Q\": IsoFields.QUARTER_OF_YEAR,\n            \"q\": IsoFields.QUARTER_OF_YEAR,\n            \"M\": ChronoField.MONTH_OF_YEAR,\n            \"L\": ChronoField.MONTH_OF_YEAR,\n            \"D\": ChronoField.DAY_OF_YEAR,\n            \"d\": ChronoField.DAY_OF_MONTH,\n            \"F\": ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,\n            \"E\": ChronoField.DAY_OF_WEEK,\n            \"c\": ChronoField.DAY_OF_WEEK,\n            \"e\": ChronoField.DAY_OF_WEEK,\n            \"a\": ChronoField.AMPM_OF_DAY,\n            \"H\": ChronoField.HOUR_OF_DAY,\n            \"k\": ChronoField.CLOCK_HOUR_OF_DAY,\n            \"K\": ChronoField.HOUR_OF_AMPM,\n            \"h\": ChronoField.CLOCK_HOUR_OF_AMPM,\n            \"m\": ChronoField.MINUTE_OF_HOUR,\n            \"s\": ChronoField.SECOND_OF_MINUTE,\n            \"S\": ChronoField.NANO_OF_SECOND,\n            \"A\": ChronoField.MILLI_OF_DAY,\n            \"n\": ChronoField.NANO_OF_SECOND,\n            \"N\": ChronoField.NANO_OF_DAY\n        };\n        for(var pos = 0; pos < pattern.length; pos++){\n            var cur = pattern.charAt(pos);\n            if (cur >= \"A\" && cur <= \"Z\" || cur >= \"a\" && cur <= \"z\") {\n                var start = pos++;\n                for(; pos < pattern.length && pattern.charAt(pos) === cur; pos++);\n                var count = pos - start;\n                if (cur === \"p\") {\n                    var pad = 0;\n                    if (pos < pattern.length) {\n                        cur = pattern.charAt(pos);\n                        if (cur >= \"A\" && cur <= \"Z\" || cur >= \"a\" && cur <= \"z\") {\n                            pad = count;\n                            start = pos++;\n                            for(; pos < pattern.length && pattern.charAt(pos) === cur; pos++);\n                            count = pos - start;\n                        }\n                    }\n                    if (pad === 0) {\n                        throw new IllegalArgumentException(\"Pad letter 'p' must be followed by valid pad pattern: \" + pattern);\n                    }\n                    this.padNext(pad);\n                }\n                var field = FIELD_MAP[cur];\n                if (field != null) {\n                    this._parseField(cur, count, field);\n                } else if (cur === \"z\") {\n                    if (count > 4) {\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                    } else if (count === 4) {\n                        this.appendZoneText(TextStyle.FULL);\n                    } else {\n                        this.appendZoneText(TextStyle.SHORT);\n                    }\n                } else if (cur === \"V\") {\n                    if (count !== 2) {\n                        throw new IllegalArgumentException(\"Pattern letter count must be 2: \" + cur);\n                    }\n                    this.appendZoneId();\n                } else if (cur === \"Z\") {\n                    if (count < 4) {\n                        this.appendOffset(\"+HHMM\", \"+0000\");\n                    } else if (count === 4) {\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else if (count === 5) {\n                        this.appendOffset(\"+HH:MM:ss\", \"Z\");\n                    } else {\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                    }\n                } else if (cur === \"O\") {\n                    if (count === 1) {\n                        this.appendLocalizedOffset(TextStyle.SHORT);\n                    } else if (count === 4) {\n                        this.appendLocalizedOffset(TextStyle.FULL);\n                    } else {\n                        throw new IllegalArgumentException(\"Pattern letter count must be 1 or 4: \" + cur);\n                    }\n                } else if (cur === \"X\") {\n                    if (count > 5) {\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                    }\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], \"Z\");\n                } else if (cur === \"x\") {\n                    if (count > 5) {\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                    }\n                    var zero = count === 1 ? \"+00\" : count % 2 === 0 ? \"+0000\" : \"+00:00\";\n                    this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);\n                } else if (cur === \"W\") {\n                    if (count > 1) {\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                    }\n                    this.appendWeekField(\"W\", count);\n                } else if (cur === \"w\") {\n                    if (count > 2) {\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                    }\n                    this.appendWeekField(\"w\", count);\n                } else if (cur === \"Y\") {\n                    this.appendWeekField(\"Y\", count);\n                } else {\n                    throw new IllegalArgumentException(\"Unknown pattern letter: \" + cur);\n                }\n                pos--;\n            } else if (cur === \"'\") {\n                var _start = pos++;\n                for(; pos < pattern.length; pos++){\n                    if (pattern.charAt(pos) === \"'\") {\n                        if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === \"'\") {\n                            pos++;\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                if (pos >= pattern.length) {\n                    throw new IllegalArgumentException(\"Pattern ends with an incomplete string literal: \" + pattern);\n                }\n                var str = pattern.substring(_start + 1, pos);\n                if (str.length === 0) {\n                    this.appendLiteral(\"'\");\n                } else {\n                    this.appendLiteral(str.replace(\"''\", \"'\"));\n                }\n            } else if (cur === \"[\") {\n                this.optionalStart();\n            } else if (cur === \"]\") {\n                if (this._active._parent === null) {\n                    throw new IllegalArgumentException(\"Pattern invalid as it contains ] without previous [\");\n                }\n                this.optionalEnd();\n            } else if (cur === \"{\" || cur === \"}\" || cur === \"#\") {\n                throw new IllegalArgumentException(\"Pattern includes reserved character: '\" + cur + \"'\");\n            } else {\n                this.appendLiteral(cur);\n            }\n        }\n    };\n    _proto._parseField = function _parseField(cur, count, field) {\n        switch(cur){\n            case \"u\":\n            case \"y\":\n                if (count === 2) {\n                    this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);\n                } else if (count < 4) {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);\n                } else {\n                    this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);\n                }\n                break;\n            case \"M\":\n            case \"Q\":\n                switch(count){\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"L\":\n            case \"q\":\n                switch(count){\n                    case 1:\n                        this.appendValue(field);\n                        break;\n                    case 2:\n                        this.appendValue(field, 2);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"e\":\n                switch(count){\n                    case 1:\n                    case 2:\n                        this.appendWeekField(\"e\", count);\n                        break;\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"c\":\n                switch(count){\n                    case 1:\n                        this.appendWeekField(\"c\", count);\n                        break;\n                    case 2:\n                        throw new IllegalArgumentException(\"Invalid number of pattern letters: \" + cur);\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT_STANDALONE);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL_STANDALONE);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW_STANDALONE);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"a\":\n                if (count === 1) {\n                    this.appendText(field, TextStyle.SHORT);\n                } else {\n                    throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"E\":\n            case \"G\":\n                switch(count){\n                    case 1:\n                    case 2:\n                    case 3:\n                        this.appendText(field, TextStyle.SHORT);\n                        break;\n                    case 4:\n                        this.appendText(field, TextStyle.FULL);\n                        break;\n                    case 5:\n                        this.appendText(field, TextStyle.NARROW);\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"S\":\n                this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);\n                break;\n            case \"F\":\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"d\":\n            case \"h\":\n            case \"H\":\n            case \"k\":\n            case \"K\":\n            case \"m\":\n            case \"s\":\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count === 2) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            case \"D\":\n                if (count === 1) {\n                    this.appendValue(field);\n                } else if (count <= 3) {\n                    this.appendValue(field, count);\n                } else {\n                    throw new IllegalArgumentException(\"Too many pattern letters: \" + cur);\n                }\n                break;\n            default:\n                if (count === 1) {\n                    this.appendValue(field);\n                } else {\n                    this.appendValue(field, count);\n                }\n                break;\n        }\n    };\n    _proto.padNext = function padNext() {\n        if (arguments.length === 1) {\n            return this._padNext1.apply(this, arguments);\n        } else {\n            return this._padNext2.apply(this, arguments);\n        }\n    };\n    _proto._padNext1 = function _padNext1(padWidth) {\n        return this._padNext2(padWidth, \" \");\n    };\n    _proto._padNext2 = function _padNext2(padWidth, padChar) {\n        if (padWidth < 1) {\n            throw new IllegalArgumentException(\"The pad width must be at least one but was \" + padWidth);\n        }\n        this._active._padNextWidth = padWidth;\n        this._active._padNextChar = padChar;\n        this._active._valueParserIndex = -1;\n        return this;\n    };\n    _proto.optionalStart = function optionalStart() {\n        this._active._valueParserIndex = -1;\n        this._active = DateTimeFormatterBuilder._of(this._active, true);\n        return this;\n    };\n    _proto.optionalEnd = function optionalEnd() {\n        if (this._active._parent == null) {\n            throw new IllegalStateException(\"Cannot call optionalEnd() as there was no previous call to optionalStart()\");\n        }\n        if (this._active._printerParsers.length > 0) {\n            var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);\n            this._active = this._active._parent;\n            this._appendInternal(cpp);\n        } else {\n            this._active = this._active._parent;\n        }\n        return this;\n    };\n    _proto._appendInternal = function _appendInternal(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    };\n    _proto.appendLiteral = function appendLiteral(literal) {\n        assert(literal != null);\n        if (literal.length > 0) {\n            if (literal.length === 1) {\n                this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));\n            } else {\n                this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));\n            }\n        }\n        return this;\n    };\n    _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {\n        assert(pp != null);\n        if (this._active._padNextWidth > 0) {\n            if (pp != null) {\n                pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);\n            }\n            this._active._padNextWidth = 0;\n            this._active._padNextChar = 0;\n        }\n        this._active._printerParsers.push(pp);\n        this._active._valueParserIndex = -1;\n        return this._active._printerParsers.length - 1;\n    };\n    _proto.append = function append(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        this._appendInternal(formatter._toPrinterParser(false));\n        return this;\n    };\n    _proto.toFormatter = function toFormatter(resolverStyle) {\n        if (resolverStyle === void 0) {\n            resolverStyle = ResolverStyle.SMART;\n        }\n        while(this._active._parent != null){\n            this.optionalEnd();\n        }\n        var pp = new CompositePrinterParser(this._printerParsers, false);\n        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);\n    };\n    return DateTimeFormatterBuilder;\n}();\nvar SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;\nvar SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;\nvar InstantPrinterParser = function() {\n    function InstantPrinterParser(fractionalDigits) {\n        this.fractionalDigits = fractionalDigits;\n    }\n    var _proto2 = InstantPrinterParser.prototype;\n    _proto2.print = function print(context, buf) {\n        var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);\n        var inNanos = 0;\n        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {\n            inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);\n        }\n        if (inSecs == null) {\n            return false;\n        }\n        var inSec = inSecs;\n        var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);\n        if (inSec >= -SECONDS_0000_TO_1970) {\n            var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;\n            var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;\n            var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);\n            var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            if (hi > 0) {\n                buf.append(\"+\").append(hi);\n            }\n            buf.append(ldt.toString());\n            if (ldt.second() === 0) {\n                buf.append(\":00\");\n            }\n        } else {\n            var _zeroSecs = inSec + SECONDS_0000_TO_1970;\n            var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);\n            var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);\n            var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);\n            var pos = buf.length();\n            buf.append(_ldt.toString());\n            if (_ldt.second() === 0) {\n                buf.append(\":00\");\n            }\n            if (_hi < 0) {\n                if (_ldt.year() === -10000) {\n                    buf.replace(pos, pos + 2, \"\" + (_hi - 1));\n                } else if (_lo === 0) {\n                    buf.insert(pos, _hi);\n                } else {\n                    buf.insert(pos + 1, Math.abs(_hi));\n                }\n            }\n        }\n        if (this.fractionalDigits === -2) {\n            if (inNano !== 0) {\n                buf.append(\".\");\n                if (MathUtil.intMod(inNano, 1000000) === 0) {\n                    buf.append((\"\" + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));\n                } else if (MathUtil.intMod(inNano, 1000) === 0) {\n                    buf.append((\"\" + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));\n                } else {\n                    buf.append((\"\" + (inNano + 1000000000)).substring(1));\n                }\n            }\n        } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {\n            buf.append(\".\");\n            var div = 100000000;\n            for(var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++){\n                var digit = MathUtil.intDiv(inNano, div);\n                buf.append(digit);\n                inNano = inNano - digit * div;\n                div = MathUtil.intDiv(div, 10);\n            }\n        }\n        buf.append(\"Z\");\n        return true;\n    };\n    _proto2.parse = function parse(context, text, position) {\n        var newContext = context.copy();\n        var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;\n        var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;\n        var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral(\"T\").appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(\":\").appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(\":\").appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral(\"Z\").toFormatter()._toPrinterParser(false);\n        var pos = parser.parse(newContext, text, position);\n        if (pos < 0) {\n            return pos;\n        }\n        var yearParsed = newContext.getParsed(ChronoField.YEAR);\n        var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);\n        var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);\n        var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);\n        var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);\n        var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);\n        var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);\n        var sec = secVal != null ? secVal : 0;\n        var nano = nanoVal != null ? nanoVal : 0;\n        var year = MathUtil.intMod(yearParsed, 10000);\n        var days = 0;\n        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {\n            hour = 0;\n            days = 1;\n        } else if (hour === 23 && min === 59 && sec === 60) {\n            context.setParsedLeapSecond();\n            sec = 59;\n        }\n        var instantSecs;\n        try {\n            var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);\n            instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);\n            instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);\n        } catch (ex) {\n            return ~position;\n        }\n        var successPos = pos;\n        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);\n        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);\n    };\n    _proto2.toString = function toString() {\n        return \"Instant()\";\n    };\n    return InstantPrinterParser;\n}();\nvar DefaultingParser = function() {\n    function DefaultingParser(field, value) {\n        this._field = field;\n        this._value = value;\n    }\n    var _proto3 = DefaultingParser.prototype;\n    _proto3.print = function print() {\n        return true;\n    };\n    _proto3.parse = function parse(context, text, position) {\n        if (context.getParsed(this._field) == null) {\n            context.setParsedField(this._field, this._value, position, position);\n        }\n        return position;\n    };\n    return DefaultingParser;\n}();\nfunction _init$e() {\n    ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);\n    DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;\n    DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;\n    DateTimeFormatterBuilder.SettingsParser = SettingsParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;\n    DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;\n    DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;\n    DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;\n    DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;\n    DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;\n    DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;\n}\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var StringBuilder = function() {\n    function StringBuilder() {\n        this._str = \"\";\n    }\n    var _proto = StringBuilder.prototype;\n    _proto.append = function append(str) {\n        this._str += str;\n        return this;\n    };\n    _proto.appendChar = function appendChar(str) {\n        this._str += str[0];\n        return this;\n    };\n    _proto.insert = function insert(offset, str) {\n        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);\n        return this;\n    };\n    _proto.replace = function replace(start, end, str) {\n        this._str = this._str.slice(0, start) + str + this._str.slice(end);\n        return this;\n    };\n    _proto.length = function length() {\n        return this._str.length;\n    };\n    _proto.setLength = function setLength(length) {\n        this._str = this._str.slice(0, length);\n        return this;\n    };\n    _proto.toString = function toString() {\n        return this._str;\n    };\n    return StringBuilder;\n}();\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var DateTimeFormatter = function() {\n    DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {\n        return DateTimeFormatter.PARSED_EXCESS_DAYS;\n    };\n    DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {\n        return DateTimeFormatter.PARSED_LEAP_SECOND;\n    };\n    DateTimeFormatter.ofPattern = function ofPattern(pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();\n    };\n    function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {\n        if (chrono === void 0) {\n            chrono = IsoChronology.INSTANCE;\n        }\n        assert(printerParser != null);\n        assert(decimalStyle != null);\n        assert(resolverStyle != null);\n        this._printerParser = printerParser;\n        this._locale = locale;\n        this._decimalStyle = decimalStyle;\n        this._resolverStyle = resolverStyle;\n        this._resolverFields = resolverFields;\n        this._chrono = chrono;\n        this._zone = zone;\n    }\n    var _proto = DateTimeFormatter.prototype;\n    _proto.locale = function locale() {\n        return this._locale;\n    };\n    _proto.decimalStyle = function decimalStyle() {\n        return this._decimalStyle;\n    };\n    _proto.chronology = function chronology() {\n        return this._chrono;\n    };\n    _proto.withChronology = function withChronology(chrono) {\n        if (this._chrono != null && this._chrono.equals(chrono)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);\n    };\n    _proto.withLocale = function withLocale() {\n        return this;\n    };\n    _proto.withResolverStyle = function withResolverStyle(resolverStyle) {\n        requireNonNull(resolverStyle, \"resolverStyle\");\n        if (resolverStyle.equals(this._resolverStyle)) {\n            return this;\n        }\n        return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);\n    };\n    _proto.format = function format(temporal) {\n        var buf = new StringBuilder(32);\n        this._formatTo(temporal, buf);\n        return buf.toString();\n    };\n    _proto._formatTo = function _formatTo(temporal, appendable) {\n        requireNonNull(temporal, \"temporal\");\n        requireNonNull(appendable, \"appendable\");\n        var context = new DateTimePrintContext(temporal, this);\n        this._printerParser.print(context, appendable);\n    };\n    _proto.parse = function parse(text, type) {\n        if (arguments.length === 1) {\n            return this.parse1(text);\n        } else {\n            return this.parse2(text, type);\n        }\n    };\n    _proto.parse1 = function parse1(text) {\n        requireNonNull(text, \"text\");\n        try {\n            return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n        } catch (ex) {\n            if (ex instanceof DateTimeParseException) {\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    };\n    _proto.parse2 = function parse2(text, type) {\n        requireNonNull(text, \"text\");\n        requireNonNull(type, \"type\");\n        try {\n            var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);\n            return builder.build(type);\n        } catch (ex) {\n            if (ex instanceof DateTimeParseException) {\n                throw ex;\n            } else {\n                throw this._createError(text, ex);\n            }\n        }\n    };\n    _proto._createError = function _createError(text, ex) {\n        var abbr = \"\";\n        if (text.length > 64) {\n            abbr = text.substring(0, 64) + \"...\";\n        } else {\n            abbr = text;\n        }\n        return new DateTimeParseException(\"Text '\" + abbr + \"' could not be parsed: \" + ex.message, text, 0, ex);\n    };\n    _proto._parseToBuilder = function _parseToBuilder(text, position) {\n        var pos = position != null ? position : new ParsePosition(0);\n        var result = this._parseUnresolved0(text, pos);\n        if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {\n            var abbr = \"\";\n            if (text.length > 64) {\n                abbr = text.substr(0, 64).toString() + \"...\";\n            } else {\n                abbr = text;\n            }\n            if (pos.getErrorIndex() >= 0) {\n                throw new DateTimeParseException(\"Text '\" + abbr + \"' could not be parsed at index \" + pos.getErrorIndex(), text, pos.getErrorIndex());\n            } else {\n                throw new DateTimeParseException(\"Text '\" + abbr + \"' could not be parsed, unparsed text found at index \" + pos.getIndex(), text, pos.getIndex());\n            }\n        }\n        return result.toBuilder();\n    };\n    _proto.parseUnresolved = function parseUnresolved(text, position) {\n        return this._parseUnresolved0(text, position);\n    };\n    _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {\n        assert(text != null, \"text\", NullPointerException);\n        assert(position != null, \"position\", NullPointerException);\n        var context = new DateTimeParseContext(this);\n        var pos = position.getIndex();\n        pos = this._printerParser.parse(context, text, pos);\n        if (pos < 0) {\n            position.setErrorIndex(~pos);\n            return null;\n        }\n        position.setIndex(pos);\n        return context.toParsed();\n    };\n    _proto._toPrinterParser = function _toPrinterParser(optional) {\n        return this._printerParser.withOptional(optional);\n    };\n    _proto.toString = function toString() {\n        var pattern = this._printerParser.toString();\n        return pattern.indexOf(\"[\") === 0 ? pattern : pattern.substring(1, pattern.length - 1);\n    };\n    return DateTimeFormatter;\n}();\nfunction _init$d() {\n    DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral(\"-\").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral(\"-\").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(\":\").appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(\":\").appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);\n    DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral(\"T\").append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);\n    DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral(\"[\").parseCaseSensitive().appendZoneId().appendLiteral(\"]\").toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral(\"-\").appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);\n    DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral(\"-W\").appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral(\"-\").appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);\n    DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);\n    DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);\n    DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery(\"PARSED_EXCESS_DAYS\", function(temporal) {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.excessDays;\n        } else {\n            return Period.ZERO;\n        }\n    });\n    DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery(\"PARSED_LEAP_SECOND\", function(temporal) {\n        if (temporal instanceof DateTimeBuilder) {\n            return temporal.leapSecond;\n        } else {\n            return false;\n        }\n    });\n}\nvar MonthDay = function(_TemporalAccessor) {\n    _inheritsLoose(MonthDay, _TemporalAccessor);\n    MonthDay.now = function now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return MonthDay.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return MonthDay.nowZoneId(zoneIdOrClock);\n        } else {\n            return MonthDay.nowClock(zoneIdOrClock);\n        }\n    };\n    MonthDay.now0 = function now0() {\n        return this.nowClock(Clock.systemDefaultZone());\n    };\n    MonthDay.nowZoneId = function nowZoneId(zone) {\n        requireNonNull(zone, \"zone\");\n        return this.nowClock(Clock.system(zone));\n    };\n    MonthDay.nowClock = function nowClock(clock) {\n        requireNonNull(clock, \"clock\");\n        var now = LocalDate.now(clock);\n        return MonthDay.of(now.month(), now.dayOfMonth());\n    };\n    MonthDay.of = function of(monthOrNumber, number) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return MonthDay.ofMonthNumber(monthOrNumber, number);\n        } else {\n            return MonthDay.ofNumberNumber(monthOrNumber, number);\n        }\n    };\n    MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {\n        requireNonNull(month, \"month\");\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        if (dayOfMonth > month.maxLength()) {\n            throw new DateTimeException(\"Illegal value for DayOfMonth field, value \" + dayOfMonth + \" is not valid for month \" + month.toString());\n        }\n        return new MonthDay(month.value(), dayOfMonth);\n    };\n    MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {\n        requireNonNull(month, \"month\");\n        requireNonNull(dayOfMonth, \"dayOfMonth\");\n        return MonthDay.of(Month.of(month), dayOfMonth);\n    };\n    MonthDay.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        requireInstance(temporal, TemporalAccessor, \"temporal\");\n        if (temporal instanceof MonthDay) {\n            return temporal;\n        }\n        try {\n            return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain MonthDay from TemporalAccessor: \" + temporal + \", type \" + (temporal && temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n    };\n    MonthDay.parse = function parse(text, formatter) {\n        if (arguments.length === 1) {\n            return MonthDay.parseString(text);\n        } else {\n            return MonthDay.parseStringFormatter(text, formatter);\n        }\n    };\n    MonthDay.parseString = function parseString(text) {\n        return MonthDay.parseStringFormatter(text, PARSER$2);\n    };\n    MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {\n        requireNonNull(text, \"text\");\n        requireNonNull(formatter, \"formatter\");\n        requireInstance(formatter, DateTimeFormatter, \"formatter\");\n        return formatter.parse(text, MonthDay.FROM);\n    };\n    function MonthDay(month, dayOfMonth) {\n        var _this;\n        _this = _TemporalAccessor.call(this) || this;\n        _this._month = MathUtil.safeToInt(month);\n        _this._day = MathUtil.safeToInt(dayOfMonth);\n        return _this;\n    }\n    var _proto = MonthDay.prototype;\n    _proto.monthValue = function monthValue() {\n        return this._month;\n    };\n    _proto.month = function month() {\n        return Month.of(this._month);\n    };\n    _proto.dayOfMonth = function dayOfMonth() {\n        return this._day;\n    };\n    _proto.isSupported = function isSupported(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;\n        }\n        return field != null && field.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        if (field === ChronoField.MONTH_OF_YEAR) {\n            return field.range();\n        } else if (field === ChronoField.DAY_OF_MONTH) {\n            return ValueRange.of(1, this.month().minLength(), this.month().maxLength());\n        }\n        return _TemporalAccessor.prototype.range.call(this, field);\n    };\n    _proto.get = function get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    };\n    _proto.getLong = function getLong(field) {\n        requireNonNull(field, \"field\");\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.DAY_OF_MONTH:\n                    return this._day;\n                case ChronoField.MONTH_OF_YEAR:\n                    return this._month;\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.isValidYear = function isValidYear(year) {\n        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;\n    };\n    _proto.withMonth = function withMonth(month) {\n        return this.with(Month.of(month));\n    };\n    _proto.with = function _with(month) {\n        requireNonNull(month, \"month\");\n        if (month.value() === this._month) {\n            return this;\n        }\n        var day = Math.min(this._day, month.maxLength());\n        return new MonthDay(month.value(), day);\n    };\n    _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n        if (dayOfMonth === this._day) {\n            return this;\n        }\n        return MonthDay.of(this._month, dayOfMonth);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        requireInstance(_query, TemporalQuery, \"query\");\n        if (_query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        }\n        return _TemporalAccessor.prototype.query.call(this, _query);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);\n        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));\n    };\n    _proto.atYear = function atYear(year) {\n        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, MonthDay, \"other\");\n        var cmp = this._month - other.monthValue();\n        if (cmp === 0) {\n            cmp = this._day - other.dayOfMonth();\n        }\n        return cmp;\n    };\n    _proto.isAfter = function isAfter(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, MonthDay, \"other\");\n        return this.compareTo(other) > 0;\n    };\n    _proto.isBefore = function isBefore(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, MonthDay, \"other\");\n        return this.compareTo(other) < 0;\n    };\n    _proto.equals = function equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof MonthDay) {\n            var other = obj;\n            return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();\n        }\n        return false;\n    };\n    _proto.toString = function toString() {\n        return \"--\" + (this._month < 10 ? \"0\" : \"\") + this._month + (this._day < 10 ? \"-0\" : \"-\") + this._day;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        requireInstance(formatter, DateTimeFormatter, \"formatter\");\n        return formatter.format(this);\n    };\n    return MonthDay;\n}(TemporalAccessor);\nvar PARSER$2;\nfunction _init$c() {\n    PARSER$2 = new DateTimeFormatterBuilder().appendLiteral(\"--\").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral(\"-\").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();\n    MonthDay.FROM = createTemporalQuery(\"MonthDay.FROM\", function(temporal) {\n        return MonthDay.from(temporal);\n    });\n}\nvar YearMonth = function(_Temporal) {\n    _inheritsLoose(YearMonth, _Temporal);\n    YearMonth.now = function now(zoneIdOrClock) {\n        if (arguments.length === 0) {\n            return YearMonth.now0();\n        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {\n            return YearMonth.nowZoneId(zoneIdOrClock);\n        } else {\n            return YearMonth.nowClock(zoneIdOrClock);\n        }\n    };\n    YearMonth.now0 = function now0() {\n        return YearMonth.nowClock(Clock.systemDefaultZone());\n    };\n    YearMonth.nowZoneId = function nowZoneId(zone) {\n        return YearMonth.nowClock(Clock.system(zone));\n    };\n    YearMonth.nowClock = function nowClock(clock) {\n        var now = LocalDate.now(clock);\n        return YearMonth.of(now.year(), now.month());\n    };\n    YearMonth.of = function of(year, monthOrNumber) {\n        if (arguments.length === 2 && monthOrNumber instanceof Month) {\n            return YearMonth.ofNumberMonth(year, monthOrNumber);\n        } else {\n            return YearMonth.ofNumberNumber(year, monthOrNumber);\n        }\n    };\n    YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {\n        requireNonNull(month, \"month\");\n        requireInstance(month, Month, \"month\");\n        return YearMonth.ofNumberNumber(year, month.value());\n    };\n    YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {\n        requireNonNull(year, \"year\");\n        requireNonNull(month, \"month\");\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return new YearMonth(year, month);\n    };\n    YearMonth.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (temporal instanceof YearMonth) {\n            return temporal;\n        }\n        try {\n            return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain YearMonth from TemporalAccessor: \" + temporal + \", type \" + (temporal && temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n    };\n    YearMonth.parse = function parse(text, formatter) {\n        if (arguments.length === 1) {\n            return YearMonth.parseString(text);\n        } else {\n            return YearMonth.parseStringFormatter(text, formatter);\n        }\n    };\n    YearMonth.parseString = function parseString(text) {\n        return YearMonth.parseStringFormatter(text, PARSER$1);\n    };\n    YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {\n        requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, YearMonth.FROM);\n    };\n    function YearMonth(year, month) {\n        var _this;\n        _this = _Temporal.call(this) || this;\n        _this._year = MathUtil.safeToInt(year);\n        _this._month = MathUtil.safeToInt(month);\n        return _this;\n    }\n    var _proto = YearMonth.prototype;\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    };\n    _proto.isSupportedField = function isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    };\n    _proto.isSupportedUnit = function isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        if (field === ChronoField.YEAR_OF_ERA) {\n            return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n        }\n        return _Temporal.prototype.range.call(this, field);\n    };\n    _proto.get = function get(field) {\n        requireNonNull(field, \"field\");\n        requireInstance(field, TemporalField, \"field\");\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    };\n    _proto.getLong = function getLong(field) {\n        requireNonNull(field, \"field\");\n        requireInstance(field, TemporalField, \"field\");\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.MONTH_OF_YEAR:\n                    return this._month;\n                case ChronoField.PROLEPTIC_MONTH:\n                    return this._getProlepticMonth();\n                case ChronoField.YEAR_OF_ERA:\n                    return this._year < 1 ? 1 - this._year : this._year;\n                case ChronoField.YEAR:\n                    return this._year;\n                case ChronoField.ERA:\n                    return this._year < 1 ? 0 : 1;\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.getFrom(this);\n    };\n    _proto._getProlepticMonth = function _getProlepticMonth() {\n        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);\n    };\n    _proto.year = function year() {\n        return this._year;\n    };\n    _proto.monthValue = function monthValue() {\n        return this._month;\n    };\n    _proto.month = function month() {\n        return Month.of(this._month);\n    };\n    _proto.isLeapYear = function isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    };\n    _proto.isValidDay = function isValidDay(dayOfMonth) {\n        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();\n    };\n    _proto.lengthOfMonth = function lengthOfMonth() {\n        return this.month().length(this.isLeapYear());\n    };\n    _proto.lengthOfYear = function lengthOfYear() {\n        return this.isLeapYear() ? 366 : 365;\n    };\n    _proto.with = function _with(adjusterOrField, value) {\n        if (arguments.length === 1) {\n            return this._withAdjuster(adjusterOrField);\n        } else {\n            return this._withField(adjusterOrField, value);\n        }\n    };\n    _proto._withField = function _withField(field, newValue) {\n        requireNonNull(field, \"field\");\n        requireInstance(field, TemporalField, \"field\");\n        if (field instanceof ChronoField) {\n            var f = field;\n            f.checkValidValue(newValue);\n            switch(f){\n                case ChronoField.MONTH_OF_YEAR:\n                    return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH:\n                    return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA:\n                    return this.withYear(this._year < 1 ? 1 - newValue : newValue);\n                case ChronoField.YEAR:\n                    return this.withYear(newValue);\n                case ChronoField.ERA:\n                    return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto.withYear = function withYear(year) {\n        ChronoField.YEAR.checkValidValue(year);\n        return new YearMonth(year, this._month);\n    };\n    _proto.withMonth = function withMonth(month) {\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        return new YearMonth(this._year, month);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        requireNonNull(unit, \"unit\");\n        requireInstance(unit, TemporalUnit, \"unit\");\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.MONTHS:\n                    return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS:\n                    return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS:\n                    return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusYears = function plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n        return this.withYear(newYear);\n    };\n    _proto.plusMonths = function plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        var monthCount = this._year * 12 + (this._month - 1);\n        var calcMonths = monthCount + monthsToAdd;\n        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return new YearMonth(newYear, newMonth);\n    };\n    _proto.minusYears = function minusYears(yearsToSubtract) {\n        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n    };\n    _proto.minusMonths = function minusMonths(monthsToSubtract) {\n        return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        requireInstance(_query, TemporalQuery, \"query\");\n        if (_query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.MONTHS;\n        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n            return null;\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        requireInstance(temporal, Temporal, \"temporal\");\n        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());\n    };\n    _proto.until = function until(endExclusive, unit) {\n        requireNonNull(endExclusive, \"endExclusive\");\n        requireNonNull(unit, \"unit\");\n        requireInstance(endExclusive, Temporal, \"endExclusive\");\n        requireInstance(unit, TemporalUnit, \"unit\");\n        var end = YearMonth.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();\n            switch(unit){\n                case ChronoUnit.MONTHS:\n                    return monthsUntil;\n                case ChronoUnit.YEARS:\n                    return MathUtil.intDiv(monthsUntil, 12);\n                case ChronoUnit.DECADES:\n                    return MathUtil.intDiv(monthsUntil, 120);\n                case ChronoUnit.CENTURIES:\n                    return MathUtil.intDiv(monthsUntil, 1200);\n                case ChronoUnit.MILLENNIA:\n                    return MathUtil.intDiv(monthsUntil, 12000);\n                case ChronoUnit.ERAS:\n                    return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    };\n    _proto.atDay = function atDay(dayOfMonth) {\n        requireNonNull(dayOfMonth, \"dayOfMonth\");\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    };\n    _proto.atEndOfMonth = function atEndOfMonth() {\n        return LocalDate.of(this._year, this._month, this.lengthOfMonth());\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, YearMonth, \"other\");\n        var cmp = this._year - other.year();\n        if (cmp === 0) {\n            cmp = this._month - other.monthValue();\n        }\n        return cmp;\n    };\n    _proto.isAfter = function isAfter(other) {\n        return this.compareTo(other) > 0;\n    };\n    _proto.isBefore = function isBefore(other) {\n        return this.compareTo(other) < 0;\n    };\n    _proto.equals = function equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (obj instanceof YearMonth) {\n            var other = obj;\n            return this.year() === other.year() && this.monthValue() === other.monthValue();\n        }\n        return false;\n    };\n    _proto.toString = function toString() {\n        return PARSER$1.format(this);\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    };\n    return YearMonth;\n}(Temporal);\nvar PARSER$1;\nfunction _init$b() {\n    PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral(\"-\").appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();\n    YearMonth.FROM = createTemporalQuery(\"YearMonth.FROM\", function(temporal) {\n        return YearMonth.from(temporal);\n    });\n}\nvar Year = function(_Temporal) {\n    _inheritsLoose(Year, _Temporal);\n    function Year(value) {\n        var _this;\n        _this = _Temporal.call(this) || this;\n        _this._year = MathUtil.safeToInt(value);\n        return _this;\n    }\n    var _proto = Year.prototype;\n    _proto.value = function value() {\n        return this._year;\n    };\n    Year.now = function now(zoneIdOrClock) {\n        if (zoneIdOrClock === void 0) {\n            zoneIdOrClock = undefined;\n        }\n        if (zoneIdOrClock === undefined) {\n            return Year.now0();\n        } else if (zoneIdOrClock instanceof ZoneId) {\n            return Year.nowZoneId(zoneIdOrClock);\n        } else {\n            return Year.nowClock(zoneIdOrClock);\n        }\n    };\n    Year.now0 = function now0() {\n        return Year.nowClock(Clock.systemDefaultZone());\n    };\n    Year.nowZoneId = function nowZoneId(zone) {\n        requireNonNull(zone, \"zone\");\n        requireInstance(zone, ZoneId, \"zone\");\n        return Year.nowClock(Clock.system(zone));\n    };\n    Year.nowClock = function nowClock(clock) {\n        requireNonNull(clock, \"clock\");\n        requireInstance(clock, Clock, \"clock\");\n        var now = LocalDate.now(clock);\n        return Year.of(now.year());\n    };\n    Year.of = function of(isoYear) {\n        requireNonNull(isoYear, \"isoYear\");\n        ChronoField.YEAR.checkValidValue(isoYear);\n        return new Year(isoYear);\n    };\n    Year.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        requireInstance(temporal, TemporalAccessor, \"temporal\");\n        if (temporal instanceof Year) {\n            return temporal;\n        }\n        try {\n            return Year.of(temporal.get(ChronoField.YEAR));\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain Year from TemporalAccessor: \" + temporal + \", type \" + (temporal && temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n    };\n    Year.parse = function parse(text, formatter) {\n        if (arguments.length <= 1) {\n            return Year.parseText(text);\n        } else {\n            return Year.parseTextFormatter(text, formatter);\n        }\n    };\n    Year.parseText = function parseText(text) {\n        requireNonNull(text, \"text\");\n        return Year.parse(text, PARSER);\n    };\n    Year.parseTextFormatter = function parseTextFormatter(text, formatter) {\n        if (formatter === void 0) {\n            formatter = PARSER;\n        }\n        requireNonNull(text, \"text\");\n        requireNonNull(formatter, \"formatter\");\n        requireInstance(formatter, DateTimeFormatter, \"formatter\");\n        return formatter.parse(text, Year.FROM);\n    };\n    Year.isLeap = function isLeap(year) {\n        return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);\n    };\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {\n            return this.isSupportedField(fieldOrUnit);\n        } else {\n            return this.isSupportedUnit(fieldOrUnit);\n        }\n    };\n    _proto.isSupportedField = function isSupportedField(field) {\n        if (field instanceof ChronoField) {\n            return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;\n        }\n        return field != null && field.isSupportedBy(this);\n    };\n    _proto.isSupportedUnit = function isSupportedUnit(unit) {\n        if (unit instanceof ChronoUnit) {\n            return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;\n        }\n        return unit != null && unit.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        if (this.isSupported(field)) {\n            return field.range();\n        } else if (field instanceof ChronoField) {\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return _Temporal.prototype.range.call(this, field);\n    };\n    _proto.get = function get(field) {\n        return this.range(field).checkValidIntValue(this.getLong(field), field);\n    };\n    _proto.getLong = function getLong(field) {\n        requireNonNull(field, \"field\");\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.YEAR_OF_ERA:\n                    return this._year < 1 ? 1 - this._year : this._year;\n                case ChronoField.YEAR:\n                    return this._year;\n                case ChronoField.ERA:\n                    return this._year < 1 ? 0 : 1;\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.isLeap = function isLeap() {\n        return Year.isLeap(this._year);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        requireNonNull(field, \"field\");\n        requireInstance(field, TemporalField, \"field\");\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch(field){\n                case ChronoField.YEAR_OF_ERA:\n                    return Year.of(this._year < 1 ? 1 - newValue : newValue);\n                case ChronoField.YEAR:\n                    return Year.of(newValue);\n                case ChronoField.ERA:\n                    return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, \"amountToAdd\");\n        requireNonNull(unit, \"unit\");\n        requireInstance(unit, TemporalUnit, \"unit\");\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.YEARS:\n                    return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS:\n                    return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusYears = function plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));\n    };\n    _proto.minusYears = function minusYears(yearsToSubtract) {\n        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        return temporal.with(ChronoField.YEAR, this._year);\n    };\n    _proto.isValidMonthDay = function isValidMonthDay(monthDay) {\n        return monthDay != null && monthDay.isValidYear(this._year);\n    };\n    _proto.length = function length() {\n        return this.isLeap() ? 366 : 365;\n    };\n    _proto.atDay = function atDay(dayOfYear) {\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    };\n    _proto.atMonth = function atMonth(monthOrNumber) {\n        if (arguments.length === 1 && monthOrNumber instanceof Month) {\n            return this.atMonthMonth(monthOrNumber);\n        } else {\n            return this.atMonthNumber(monthOrNumber);\n        }\n    };\n    _proto.atMonthMonth = function atMonthMonth(month) {\n        requireNonNull(month, \"month\");\n        requireInstance(month, Month, \"month\");\n        return YearMonth.of(this._year, month);\n    };\n    _proto.atMonthNumber = function atMonthNumber(month) {\n        requireNonNull(month, \"month\");\n        return YearMonth.of(this._year, month);\n    };\n    _proto.atMonthDay = function atMonthDay(monthDay) {\n        requireNonNull(monthDay, \"monthDay\");\n        requireInstance(monthDay, MonthDay, \"monthDay\");\n        return monthDay.atYear(this._year);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query()\");\n        requireInstance(_query, TemporalQuery, \"query()\");\n        if (_query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.YEARS;\n        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n            return null;\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, Year, \"other\");\n        return this._year - other._year;\n    };\n    _proto.isAfter = function isAfter(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, Year, \"other\");\n        return this._year > other._year;\n    };\n    _proto.isBefore = function isBefore(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, Year, \"other\");\n        return this._year < other._year;\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        requireInstance(formatter, DateTimeFormatter, \"formatter\");\n        return formatter.format(this);\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Year) {\n            return this.value() === other.value();\n        }\n        return false;\n    };\n    _proto.toString = function toString() {\n        return \"\" + this._year;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.until = function until(endExclusive, unit) {\n        var end = Year.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            var yearsUntil = end.value() - this.value();\n            switch(unit){\n                case ChronoUnit.YEARS:\n                    return yearsUntil;\n                case ChronoUnit.DECADES:\n                    return MathUtil.intDiv(yearsUntil, 10);\n                case ChronoUnit.CENTURIES:\n                    return MathUtil.intDiv(yearsUntil, 100);\n                case ChronoUnit.MILLENNIA:\n                    return MathUtil.intDiv(yearsUntil, 1000);\n                case ChronoUnit.ERAS:\n                    return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    };\n    return Year;\n}(Temporal);\nvar PARSER;\nfunction _init$a() {\n    Year.MIN_VALUE = YearConstants.MIN_VALUE;\n    Year.MAX_VALUE = YearConstants.MAX_VALUE;\n    PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();\n    Year.FROM = createTemporalQuery(\"Year.FROM\", function(temporal) {\n        return Year.from(temporal);\n    });\n}\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var TemporalAdjuster = function() {\n    function TemporalAdjuster() {}\n    var _proto = TemporalAdjuster.prototype;\n    _proto.adjustInto = function adjustInto(temporal) {\n        abstractMethodFail(\"adjustInto\");\n    };\n    return TemporalAdjuster;\n}();\nvar TemporalAdjusters = function() {\n    function TemporalAdjusters() {}\n    TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {\n        return Impl.FIRST_DAY_OF_MONTH;\n    };\n    TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {\n        return Impl.LAST_DAY_OF_MONTH;\n    };\n    TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {\n        return Impl.FIRST_DAY_OF_NEXT_MONTH;\n    };\n    TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {\n        return Impl.FIRST_DAY_OF_YEAR;\n    };\n    TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {\n        return Impl.LAST_DAY_OF_YEAR;\n    };\n    TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {\n        return Impl.FIRST_DAY_OF_NEXT_YEAR;\n    };\n    TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, \"dayOfWeek\");\n        return new DayOfWeekInMonth(1, dayOfWeek);\n    };\n    TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {\n        requireNonNull(dayOfWeek, \"dayOfWeek\");\n        return new DayOfWeekInMonth(-1, dayOfWeek);\n    };\n    TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {\n        requireNonNull(dayOfWeek, \"dayOfWeek\");\n        return new DayOfWeekInMonth(ordinal, dayOfWeek);\n    };\n    TemporalAdjusters.next = function next(dayOfWeek) {\n        return new RelativeDayOfWeek(2, dayOfWeek);\n    };\n    TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(0, dayOfWeek);\n    };\n    TemporalAdjusters.previous = function previous(dayOfWeek) {\n        return new RelativeDayOfWeek(3, dayOfWeek);\n    };\n    TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {\n        return new RelativeDayOfWeek(1, dayOfWeek);\n    };\n    return TemporalAdjusters;\n}();\nvar Impl = function(_TemporalAdjuster) {\n    _inheritsLoose(Impl, _TemporalAdjuster);\n    function Impl(ordinal) {\n        var _this;\n        _this = _TemporalAdjuster.call(this) || this;\n        _this._ordinal = ordinal;\n        return _this;\n    }\n    var _proto = Impl.prototype;\n    _proto.adjustInto = function adjustInto(temporal) {\n        switch(this._ordinal){\n            case 0:\n                return temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            case 1:\n                return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            case 2:\n                return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);\n            case 3:\n                return temporal.with(ChronoField.DAY_OF_YEAR, 1);\n            case 4:\n                return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());\n            case 5:\n                return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);\n        }\n        throw new IllegalStateException(\"Unreachable\");\n    };\n    return Impl;\n}(TemporalAdjuster);\nImpl.FIRST_DAY_OF_MONTH = new Impl(0);\nImpl.LAST_DAY_OF_MONTH = new Impl(1);\nImpl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);\nImpl.FIRST_DAY_OF_YEAR = new Impl(3);\nImpl.LAST_DAY_OF_YEAR = new Impl(4);\nImpl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);\nvar DayOfWeekInMonth = function(_TemporalAdjuster2) {\n    _inheritsLoose(DayOfWeekInMonth, _TemporalAdjuster2);\n    function DayOfWeekInMonth(ordinal, dow) {\n        var _this2;\n        _this2 = _TemporalAdjuster2.call(this) || this;\n        _this2._ordinal = ordinal;\n        _this2._dowValue = dow.value();\n        return _this2;\n    }\n    var _proto2 = DayOfWeekInMonth.prototype;\n    _proto2.adjustInto = function adjustInto(temporal) {\n        if (this._ordinal >= 0) {\n            var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);\n            var curDow = temp.get(ChronoField.DAY_OF_WEEK);\n            var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);\n            dowDiff += (this._ordinal - 1) * 7;\n            return temp.plus(dowDiff, ChronoUnit.DAYS);\n        } else {\n            var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());\n            var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);\n            var daysDiff = this._dowValue - _curDow;\n            daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;\n            daysDiff -= (-this._ordinal - 1) * 7;\n            return _temp.plus(daysDiff, ChronoUnit.DAYS);\n        }\n    };\n    return DayOfWeekInMonth;\n}(TemporalAdjuster);\nvar RelativeDayOfWeek = function(_TemporalAdjuster3) {\n    _inheritsLoose(RelativeDayOfWeek, _TemporalAdjuster3);\n    function RelativeDayOfWeek(relative, dayOfWeek) {\n        var _this3;\n        _this3 = _TemporalAdjuster3.call(this) || this;\n        requireNonNull(dayOfWeek, \"dayOfWeek\");\n        _this3._relative = relative;\n        _this3._dowValue = dayOfWeek.value();\n        return _this3;\n    }\n    var _proto3 = RelativeDayOfWeek.prototype;\n    _proto3.adjustInto = function adjustInto(temporal) {\n        var calDow = temporal.get(ChronoField.DAY_OF_WEEK);\n        if (this._relative < 2 && calDow === this._dowValue) {\n            return temporal;\n        }\n        if ((this._relative & 1) === 0) {\n            var daysDiff = calDow - this._dowValue;\n            return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);\n        } else {\n            var _daysDiff = this._dowValue - calDow;\n            return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);\n        }\n    };\n    return RelativeDayOfWeek;\n}(TemporalAdjuster);\nvar IsoChronology = function(_Enum) {\n    _inheritsLoose(IsoChronology, _Enum);\n    function IsoChronology() {\n        return _Enum.apply(this, arguments) || this;\n    }\n    IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {\n        return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);\n    };\n    var _proto = IsoChronology.prototype;\n    _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {\n        requireNonNull(fieldValues, \"fieldValues\");\n        requireNonNull(field, \"field\");\n        var current = fieldValues.get(field);\n        if (current != null && current !== value) {\n            throw new DateTimeException(\"Invalid state, field: \" + field + \" \" + current + \" conflicts with \" + field + \" \" + value);\n        }\n        fieldValues.put(field, value);\n    };\n    _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {\n        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));\n        }\n        var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);\n        if (prolepticMonth != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);\n            }\n            this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);\n            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));\n        }\n        var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);\n        if (yoeLong != null) {\n            if (resolverStyle !== ResolverStyle.LENIENT) {\n                ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);\n            }\n            var era = fieldValues.remove(ChronoField.ERA);\n            if (era == null) {\n                var year = fieldValues.get(ChronoField.YEAR);\n                if (resolverStyle === ResolverStyle.STRICT) {\n                    if (year != null) {\n                        this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n                    } else {\n                        fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);\n                    }\n                } else {\n                    this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));\n                }\n            } else if (era === 1) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);\n            } else if (era === 0) {\n                this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));\n            } else {\n                throw new DateTimeException(\"Invalid value for era: \" + era);\n            }\n        } else if (fieldValues.containsKey(ChronoField.ERA)) {\n            ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));\n        }\n        if (fieldValues.containsKey(ChronoField.YEAR)) {\n            if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {\n                    var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);\n                    var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        var months = moy - 1;\n                        var days = dom - 1;\n                        return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);\n                    } else if (resolverStyle === ResolverStyle.SMART) {\n                        ChronoField.DAY_OF_MONTH.checkValidValue(dom);\n                        if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {\n                            dom = Math.min(dom, 30);\n                        } else if (moy === 2) {\n                            dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));\n                        }\n                        return LocalDate.of(y, moy, dom);\n                    } else {\n                        return LocalDate.of(y, moy, dom);\n                    }\n                }\n            }\n            if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {\n                var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                if (resolverStyle === ResolverStyle.LENIENT) {\n                    var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);\n                    return LocalDate.ofYearDay(_y, 1).plusDays(_days);\n                }\n                var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));\n                return LocalDate.ofYearDay(_y, doy);\n            }\n            if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {\n                if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {\n                    var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);\n                        return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);\n                    }\n                    var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                    var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));\n                    if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {\n                        throw new DateTimeException(\"Strict mode rejected date parsed to a different year\");\n                    }\n                    return date;\n                }\n                if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {\n                    var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));\n                    if (resolverStyle === ResolverStyle.LENIENT) {\n                        var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);\n                        var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);\n                        return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);\n                    }\n                    var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                    var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));\n                    var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));\n                    if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {\n                        throw new DateTimeException(\"Strict mode rejected date parsed to a different month\");\n                    }\n                    return _date;\n                }\n            }\n        }\n        return null;\n    };\n    _proto.date = function date(temporal) {\n        return LocalDate.from(temporal);\n    };\n    return IsoChronology;\n}(Enum);\nfunction _init$9() {\n    IsoChronology.INSTANCE = new IsoChronology(\"IsoChronology\");\n}\nvar OffsetTime = function(_Temporal) {\n    _inheritsLoose(OffsetTime, _Temporal);\n    OffsetTime.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (temporal instanceof OffsetTime) {\n            return temporal;\n        } else if (temporal instanceof OffsetDateTime) {\n            return temporal.toOffsetTime();\n        }\n        try {\n            var time = LocalTime.from(temporal);\n            var offset = ZoneOffset.from(temporal);\n            return new OffsetTime(time, offset);\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n    };\n    OffsetTime.now = function now(clockOrZone) {\n        if (arguments.length === 0) {\n            return OffsetTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock) {\n            return OffsetTime._now(clockOrZone);\n        } else {\n            return OffsetTime._now(Clock.system(clockOrZone));\n        }\n    };\n    OffsetTime._now = function _now(clock) {\n        requireNonNull(clock, \"clock\");\n        var now = clock.instant();\n        return OffsetTime.ofInstant(now, clock.zone().rules().offset(now));\n    };\n    OffsetTime.of = function of() {\n        if (arguments.length <= 2) {\n            return OffsetTime.ofTimeAndOffset.apply(this, arguments);\n        } else {\n            return OffsetTime.ofNumbers.apply(this, arguments);\n        }\n    };\n    OffsetTime.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {\n        var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new OffsetTime(time, offset);\n    };\n    OffsetTime.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {\n        return new OffsetTime(time, offset);\n    };\n    OffsetTime.ofInstant = function ofInstant(instant, zone) {\n        requireNonNull(instant, \"instant\");\n        requireInstance(instant, Instant, \"instant\");\n        requireNonNull(zone, \"zone\");\n        requireInstance(zone, ZoneId, \"zone\");\n        var rules = zone.rules();\n        var offset = rules.offset(instant);\n        var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;\n        secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;\n        if (secsOfDay < 0) {\n            secsOfDay += LocalTime.SECONDS_PER_DAY;\n        }\n        var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n        return new OffsetTime(time, offset);\n    };\n    OffsetTime.parse = function parse(text, formatter) {\n        if (formatter === void 0) {\n            formatter = DateTimeFormatter.ISO_OFFSET_TIME;\n        }\n        requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetTime.FROM);\n    };\n    function OffsetTime(time, offset) {\n        var _this;\n        _this = _Temporal.call(this) || this;\n        requireNonNull(time, \"time\");\n        requireInstance(time, LocalTime, \"time\");\n        requireNonNull(offset, \"offset\");\n        requireInstance(offset, ZoneOffset, \"offset\");\n        _this._time = time;\n        _this._offset = offset;\n        return _this;\n    }\n    var _proto = OffsetTime.prototype;\n    _proto.adjustInto = function adjustInto(temporal) {\n        return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n    };\n    _proto.atDate = function atDate(date) {\n        return OffsetDateTime.of(date, this._time, this._offset);\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        return formatter.format(this, OffsetTime.FROM);\n    };\n    _proto.get = function get(field) {\n        return _Temporal.prototype.get.call(this, field);\n    };\n    _proto.getLong = function getLong(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return this._offset.totalSeconds();\n            }\n            return this._time.getLong(field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.hour = function hour() {\n        return this._time.hour();\n    };\n    _proto.minute = function minute() {\n        return this._time.minute();\n    };\n    _proto.second = function second() {\n        return this._time.second();\n    };\n    _proto.nano = function nano() {\n        return this._time.nano();\n    };\n    _proto.offset = function offset() {\n        return this._offset;\n    };\n    _proto.isAfter = function isAfter(other) {\n        requireNonNull(other, \"other\");\n        return this._toEpochNano() > other._toEpochNano();\n    };\n    _proto.isBefore = function isBefore(other) {\n        requireNonNull(other, \"other\");\n        return this._toEpochNano() < other._toEpochNano();\n    };\n    _proto.isEqual = function isEqual(other) {\n        requireNonNull(other, \"other\");\n        return this._toEpochNano() === other._toEpochNano();\n    };\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    };\n    _proto.minusHours = function minusHours(hours) {\n        return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);\n    };\n    _proto.minusMinutes = function minusMinutes(minutes) {\n        return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);\n    };\n    _proto.minusSeconds = function minusSeconds(seconds) {\n        return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);\n    };\n    _proto.minusNanos = function minusNanos(nanos) {\n        return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);\n    };\n    _proto._minusAmount = function _minusAmount(amount) {\n        requireNonNull(amount);\n        return amount.subtractFrom(this);\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        return this.plus(-1 * amountToSubtract, unit);\n    };\n    _proto._plusAmount = function _plusAmount(amount) {\n        requireNonNull(amount);\n        return amount.addTo(this);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusHours = function plusHours(hours) {\n        return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);\n    };\n    _proto.plusMinutes = function plusMinutes(minutes) {\n        return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);\n    };\n    _proto.plusSeconds = function plusSeconds(seconds) {\n        return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);\n    };\n    _proto.plusNanos = function plusNanos(nanos) {\n        return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n            return this.offset();\n        } else if (_query === TemporalQueries.localTime()) {\n            return this._time;\n        } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto.range = function range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._time.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    };\n    _proto.toLocalTime = function toLocalTime() {\n        return this._time;\n    };\n    _proto.truncatedTo = function truncatedTo(unit) {\n        return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);\n    };\n    _proto.until = function until(endExclusive, unit) {\n        requireNonNull(endExclusive, \"endExclusive\");\n        requireNonNull(unit, \"unit\");\n        var end = OffsetTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            var nanosUntil = end._toEpochNano() - this._toEpochNano();\n            switch(unit){\n                case ChronoUnit.NANOS:\n                    return nanosUntil;\n                case ChronoUnit.MICROS:\n                    return MathUtil.intDiv(nanosUntil, 1000);\n                case ChronoUnit.MILLIS:\n                    return MathUtil.intDiv(nanosUntil, 1000000);\n                case ChronoUnit.SECONDS:\n                    return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n                case ChronoUnit.MINUTES:\n                    return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n                case ChronoUnit.HOURS:\n                    return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS:\n                    return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    };\n    _proto.withHour = function withHour(hour) {\n        return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);\n    };\n    _proto.withMinute = function withMinute(minute) {\n        return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);\n    };\n    _proto.withSecond = function withSecond(second) {\n        return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);\n    };\n    _proto.withNano = function withNano(nano) {\n        return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);\n    };\n    _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {\n        requireNonNull(offset, \"offset\");\n        if (offset.equals(this._offset)) {\n            return this;\n        }\n        var difference = offset.totalSeconds() - this._offset.totalSeconds();\n        var adjusted = this._time.plusSeconds(difference);\n        return new OffsetTime(adjusted, offset);\n    };\n    _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {\n        return offset != null && offset.equals(this._offset) ? this : new OffsetTime(this._time, offset);\n    };\n    _proto._toEpochNano = function _toEpochNano() {\n        var nod = this._time.toNanoOfDay();\n        var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;\n        return nod - offsetNanos;\n    };\n    _proto._withAdjuster = function _withAdjuster(adjuster) {\n        requireNonNull(adjuster, \"adjuster\");\n        if (adjuster instanceof LocalTime) {\n            return this._withLocalTimeOffset(adjuster, this._offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._withLocalTimeOffset(this._time, adjuster);\n        } else if (adjuster instanceof OffsetTime) {\n            return adjuster;\n        }\n        return adjuster.adjustInto(this);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        requireNonNull(field, \"field\");\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.OFFSET_SECONDS) {\n                return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));\n            }\n            return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {\n        if (this._time === time && this._offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetTime(time, offset);\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, OffsetTime, \"other\");\n        if (this._offset.equals(other._offset)) {\n            return this._time.compareTo(other._time);\n        }\n        var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());\n        if (compare === 0) {\n            return this._time.compareTo(other._time);\n        }\n        return compare;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof OffsetTime) {\n            return this._time.equals(other._time) && this._offset.equals(other._offset);\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return this._time.hashCode() ^ this._offset.hashCode();\n    };\n    _proto.toString = function toString() {\n        return this._time.toString() + this._offset.toString();\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return OffsetTime;\n}(Temporal);\nfunction _init$8() {\n    OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);\n    OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);\n    OffsetTime.FROM = createTemporalQuery(\"OffsetTime.FROM\", function(temporal) {\n        return OffsetTime.from(temporal);\n    });\n}\nvar ChronoZonedDateTime = function(_Temporal) {\n    _inheritsLoose(ChronoZonedDateTime, _Temporal);\n    function ChronoZonedDateTime() {\n        return _Temporal.apply(this, arguments) || this;\n    }\n    var _proto = ChronoZonedDateTime.prototype;\n    _proto.query = function query(_query) {\n        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {\n            return this.zone();\n        } else if (_query === TemporalQueries.chronology()) {\n            return this.toLocalDate().chronology();\n        } else if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (_query === TemporalQueries.offset()) {\n            return this.offset();\n        } else if (_query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (_query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    };\n    _proto.toInstant = function toInstant() {\n        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());\n    };\n    _proto.toEpochSecond = function toEpochSecond() {\n        var epochDay = this.toLocalDate().toEpochDay();\n        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= this.offset().totalSeconds();\n        return secs;\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n        if (cmp === 0) {\n            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n            if (cmp === 0) {\n                cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n                if (cmp === 0) {\n                    cmp = strcmp(this.zone().id(), other.zone().id());\n                }\n            }\n        }\n        return cmp;\n    };\n    _proto.isAfter = function isAfter(other) {\n        requireNonNull(other, \"other\");\n        var thisEpochSec = this.toEpochSecond();\n        var otherEpochSec = other.toEpochSecond();\n        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();\n    };\n    _proto.isBefore = function isBefore(other) {\n        requireNonNull(other, \"other\");\n        var thisEpochSec = this.toEpochSecond();\n        var otherEpochSec = other.toEpochSecond();\n        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();\n    };\n    _proto.isEqual = function isEqual(other) {\n        requireNonNull(other, \"other\");\n        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ChronoZonedDateTime) {\n            return this.compareTo(other) === 0;\n        }\n        return false;\n    };\n    return ChronoZonedDateTime;\n}(Temporal);\nfunction strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nvar ZonedDateTime = function(_ChronoZonedDateTime) {\n    _inheritsLoose(ZonedDateTime, _ChronoZonedDateTime);\n    ZonedDateTime.now = function now(clockOrZone) {\n        var clock;\n        if (clockOrZone instanceof ZoneId) {\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;\n        }\n        return ZonedDateTime.ofInstant(clock.instant(), clock.zone());\n    };\n    ZonedDateTime.of = function of() {\n        if (arguments.length <= 2) {\n            return ZonedDateTime.of2.apply(this, arguments);\n        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {\n            return ZonedDateTime.of3.apply(this, arguments);\n        } else {\n            return ZonedDateTime.of8.apply(this, arguments);\n        }\n    };\n    ZonedDateTime.of3 = function of3(date, time, zone) {\n        return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);\n    };\n    ZonedDateTime.of2 = function of2(localDateTime, zone) {\n        return ZonedDateTime.ofLocal(localDateTime, zone, null);\n    };\n    ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {\n        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return ZonedDateTime.ofLocal(dt, zone, null);\n    };\n    ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {\n        requireNonNull(localDateTime, \"localDateTime\");\n        requireNonNull(zone, \"zone\");\n        if (zone instanceof ZoneOffset) {\n            return new ZonedDateTime(localDateTime, zone, zone);\n        }\n        var offset = null;\n        var rules = zone.rules();\n        var validOffsets = rules.validOffsets(localDateTime);\n        if (validOffsets.length === 1) {\n            offset = validOffsets[0];\n        } else if (validOffsets.length === 0) {\n            var trans = rules.transition(localDateTime);\n            localDateTime = localDateTime.plusSeconds(trans.duration().seconds());\n            offset = trans.offsetAfter();\n        } else {\n            if (preferredOffset != null && validOffsets.some(function(validOffset) {\n                return validOffset.equals(preferredOffset);\n            })) {\n                offset = preferredOffset;\n            } else {\n                offset = requireNonNull(validOffsets[0], \"offset\");\n            }\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    };\n    ZonedDateTime.ofInstant = function ofInstant() {\n        if (arguments.length === 2) {\n            return ZonedDateTime.ofInstant2.apply(this, arguments);\n        } else {\n            return ZonedDateTime.ofInstant3.apply(this, arguments);\n        }\n    };\n    ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {\n        requireNonNull(instant, \"instant\");\n        requireNonNull(zone, \"zone\");\n        return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);\n    };\n    ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, \"localDateTime\");\n        requireNonNull(offset, \"offset\");\n        requireNonNull(zone, \"zone\");\n        return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);\n    };\n    ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {\n        var rules = zone.rules();\n        var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);\n        var offset = rules.offset(instant);\n        var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);\n        return new ZonedDateTime(ldt, offset, zone);\n    };\n    ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, \"localDateTime\");\n        requireNonNull(offset, \"offset\");\n        requireNonNull(zone, \"zone\");\n        var rules = zone.rules();\n        if (rules.isValidOffset(localDateTime, offset) === false) {\n            var trans = rules.transition(localDateTime);\n            if (trans != null && trans.isGap()) {\n                throw new DateTimeException(\"LocalDateTime \" + localDateTime + \" does not exist in zone \" + zone + \" due to a gap in the local time-line, typically caused by daylight savings\");\n            }\n            throw new DateTimeException('ZoneOffset \"' + offset + '\" is not valid for LocalDateTime \"' + localDateTime + '\" in zone \"' + zone + '\"');\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    };\n    ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {\n        requireNonNull(localDateTime, \"localDateTime\");\n        requireNonNull(offset, \"offset\");\n        requireNonNull(zone, \"zone\");\n        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {\n            throw new IllegalArgumentException(\"ZoneId must match ZoneOffset\");\n        }\n        return new ZonedDateTime(localDateTime, offset, zone);\n    };\n    ZonedDateTime.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (temporal instanceof ZonedDateTime) {\n            return temporal;\n        }\n        var zone = ZoneId.from(temporal);\n        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {\n            var zdt = ZonedDateTime._from(temporal, zone);\n            if (zdt != null) return zdt;\n        }\n        var ldt = LocalDateTime.from(temporal);\n        return ZonedDateTime.of2(ldt, zone);\n    };\n    ZonedDateTime._from = function _from(temporal, zone) {\n        try {\n            return ZonedDateTime.__from(temporal, zone);\n        } catch (ex) {\n            if (!(ex instanceof DateTimeException)) throw ex;\n        }\n    };\n    ZonedDateTime.__from = function __from(temporal, zone) {\n        var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);\n        var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n        return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);\n    };\n    ZonedDateTime.parse = function parse(text, formatter) {\n        if (formatter === void 0) {\n            formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;\n        }\n        requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, ZonedDateTime.FROM);\n    };\n    function ZonedDateTime(dateTime, offset, zone) {\n        var _this;\n        requireNonNull(dateTime, \"dateTime\");\n        requireNonNull(offset, \"offset\");\n        requireNonNull(zone, \"zone\");\n        _this = _ChronoZonedDateTime.call(this) || this;\n        _this._dateTime = dateTime;\n        _this._offset = offset;\n        _this._zone = zone;\n        return _this;\n    }\n    var _proto = ZonedDateTime.prototype;\n    _proto._resolveLocal = function _resolveLocal(newDateTime) {\n        requireNonNull(newDateTime, \"newDateTime\");\n        return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);\n    };\n    _proto._resolveInstant = function _resolveInstant(newDateTime) {\n        return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);\n    };\n    _proto._resolveOffset = function _resolveOffset(offset) {\n        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {\n            return new ZonedDateTime(this._dateTime, offset, this._zone);\n        }\n        return this;\n    };\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return true;\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    };\n    _proto.get = function get(field) {\n        return this.getLong(field);\n    };\n    _proto.getLong = function getLong(field) {\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.INSTANT_SECONDS:\n                    return this.toEpochSecond();\n                case ChronoField.OFFSET_SECONDS:\n                    return this._offset.totalSeconds();\n            }\n            return this._dateTime.getLong(field);\n        }\n        requireNonNull(field, \"field\");\n        return field.getFrom(this);\n    };\n    _proto.offset = function offset() {\n        return this._offset;\n    };\n    _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {\n        var trans = this._zone.rules().transition(this._dateTime);\n        if (trans != null && trans.isOverlap()) {\n            var earlierOffset = trans.offsetBefore();\n            if (earlierOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);\n            }\n        }\n        return this;\n    };\n    _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {\n        var trans = this._zone.rules().transition(this.toLocalDateTime());\n        if (trans != null) {\n            var laterOffset = trans.offsetAfter();\n            if (laterOffset.equals(this._offset) === false) {\n                return new ZonedDateTime(this._dateTime, laterOffset, this._zone);\n            }\n        }\n        return this;\n    };\n    _proto.zone = function zone() {\n        return this._zone;\n    };\n    _proto.withZoneSameLocal = function withZoneSameLocal(zone) {\n        requireNonNull(zone, \"zone\");\n        return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n    };\n    _proto.withZoneSameInstant = function withZoneSameInstant(zone) {\n        requireNonNull(zone, \"zone\");\n        return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);\n    };\n    _proto.withFixedOffsetZone = function withFixedOffsetZone() {\n        return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);\n    };\n    _proto.year = function year() {\n        return this._dateTime.year();\n    };\n    _proto.monthValue = function monthValue() {\n        return this._dateTime.monthValue();\n    };\n    _proto.month = function month() {\n        return this._dateTime.month();\n    };\n    _proto.dayOfMonth = function dayOfMonth() {\n        return this._dateTime.dayOfMonth();\n    };\n    _proto.dayOfYear = function dayOfYear() {\n        return this._dateTime.dayOfYear();\n    };\n    _proto.dayOfWeek = function dayOfWeek() {\n        return this._dateTime.dayOfWeek();\n    };\n    _proto.hour = function hour() {\n        return this._dateTime.hour();\n    };\n    _proto.minute = function minute() {\n        return this._dateTime.minute();\n    };\n    _proto.second = function second() {\n        return this._dateTime.second();\n    };\n    _proto.nano = function nano() {\n        return this._dateTime.nano();\n    };\n    _proto._withAdjuster = function _withAdjuster(adjuster) {\n        if (adjuster instanceof LocalDate) {\n            return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));\n        } else if (adjuster instanceof LocalTime) {\n            return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));\n        } else if (adjuster instanceof LocalDateTime) {\n            return this._resolveLocal(adjuster);\n        } else if (adjuster instanceof Instant) {\n            var instant = adjuster;\n            return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._resolveOffset(adjuster);\n        }\n        return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.INSTANT_SECONDS:\n                    return ZonedDateTime._create(newValue, this.nano(), this._zone);\n                case ChronoField.OFFSET_SECONDS:\n                    {\n                        var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));\n                        return this._resolveOffset(offset);\n                    }\n            }\n            return this._resolveLocal(this._dateTime.with(field, newValue));\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto.withYear = function withYear(year) {\n        return this._resolveLocal(this._dateTime.withYear(year));\n    };\n    _proto.withMonth = function withMonth(month) {\n        return this._resolveLocal(this._dateTime.withMonth(month));\n    };\n    _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));\n    };\n    _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));\n    };\n    _proto.withHour = function withHour(hour) {\n        return this._resolveLocal(this._dateTime.withHour(hour));\n    };\n    _proto.withMinute = function withMinute(minute) {\n        return this._resolveLocal(this._dateTime.withMinute(minute));\n    };\n    _proto.withSecond = function withSecond(second) {\n        return this._resolveLocal(this._dateTime.withSecond(second));\n    };\n    _proto.withNano = function withNano(nanoOfSecond) {\n        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));\n    };\n    _proto.truncatedTo = function truncatedTo(unit) {\n        return this._resolveLocal(this._dateTime.truncatedTo(unit));\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            if (unit.isDateBased()) {\n                return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));\n            } else {\n                return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));\n            }\n        }\n        requireNonNull(unit, \"unit\");\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusYears = function plusYears(years) {\n        return this._resolveLocal(this._dateTime.plusYears(years));\n    };\n    _proto.plusMonths = function plusMonths(months) {\n        return this._resolveLocal(this._dateTime.plusMonths(months));\n    };\n    _proto.plusWeeks = function plusWeeks(weeks) {\n        return this._resolveLocal(this._dateTime.plusWeeks(weeks));\n    };\n    _proto.plusDays = function plusDays(days) {\n        return this._resolveLocal(this._dateTime.plusDays(days));\n    };\n    _proto.plusHours = function plusHours(hours) {\n        return this._resolveInstant(this._dateTime.plusHours(hours));\n    };\n    _proto.plusMinutes = function plusMinutes(minutes) {\n        return this._resolveInstant(this._dateTime.plusMinutes(minutes));\n    };\n    _proto.plusSeconds = function plusSeconds(seconds) {\n        return this._resolveInstant(this._dateTime.plusSeconds(seconds));\n    };\n    _proto.plusNanos = function plusNanos(nanos) {\n        return this._resolveInstant(this._dateTime.plusNanos(nanos));\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    };\n    _proto.minusYears = function minusYears(years) {\n        return this.plusYears(-1 * years);\n    };\n    _proto.minusMonths = function minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    };\n    _proto.minusWeeks = function minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    };\n    _proto.minusDays = function minusDays(days) {\n        return this.plusDays(-1 * days);\n    };\n    _proto.minusHours = function minusHours(hours) {\n        return this.plusHours(-1 * hours);\n    };\n    _proto.minusMinutes = function minusMinutes(minutes) {\n        return this.plusMinutes(-1 * minutes);\n    };\n    _proto.minusSeconds = function minusSeconds(seconds) {\n        return this.plusSeconds(-1 * seconds);\n    };\n    _proto.minusNanos = function minusNanos(nanos) {\n        return this.plusNanos(-1 * nanos);\n    };\n    _proto.query = function query(_query) {\n        if (_query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        requireNonNull(_query, \"query\");\n        return _ChronoZonedDateTime.prototype.query.call(this, _query);\n    };\n    _proto.until = function until(endExclusive, unit) {\n        var end = ZonedDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withZoneSameInstant(this._zone);\n            if (unit.isDateBased()) {\n                return this._dateTime.until(end._dateTime, unit);\n            } else {\n                var difference = this._offset.totalSeconds() - end._offset.totalSeconds();\n                var adjustedEnd = end._dateTime.plusSeconds(difference);\n                return this._dateTime.until(adjustedEnd, unit);\n            }\n        }\n        return unit.between(this, end);\n    };\n    _proto.toLocalDateTime = function toLocalDateTime() {\n        return this._dateTime;\n    };\n    _proto.toLocalDate = function toLocalDate() {\n        return this._dateTime.toLocalDate();\n    };\n    _proto.toLocalTime = function toLocalTime() {\n        return this._dateTime.toLocalTime();\n    };\n    _proto.toOffsetDateTime = function toOffsetDateTime() {\n        return OffsetDateTime.of(this._dateTime, this._offset);\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ZonedDateTime) {\n            return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());\n    };\n    _proto.toString = function toString() {\n        var str = this._dateTime.toString() + this._offset.toString();\n        if (this._offset !== this._zone) {\n            str += \"[\" + this._zone.toString() + \"]\";\n        }\n        return str;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.format = function format(formatter) {\n        return _ChronoZonedDateTime.prototype.format.call(this, formatter);\n    };\n    return ZonedDateTime;\n}(ChronoZonedDateTime);\nfunction _init$7() {\n    ZonedDateTime.FROM = createTemporalQuery(\"ZonedDateTime.FROM\", function(temporal) {\n        return ZonedDateTime.from(temporal);\n    });\n}\nvar OffsetDateTime = function(_Temporal) {\n    _inheritsLoose(OffsetDateTime, _Temporal);\n    OffsetDateTime.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (temporal instanceof OffsetDateTime) {\n            return temporal;\n        }\n        try {\n            var offset = ZoneOffset.from(temporal);\n            try {\n                var ldt = LocalDateTime.from(temporal);\n                return OffsetDateTime.of(ldt, offset);\n            } catch (_) {\n                var instant = Instant.from(temporal);\n                return OffsetDateTime.ofInstant(instant, offset);\n            }\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain OffsetDateTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n    };\n    OffsetDateTime.now = function now(clockOrZone) {\n        if (arguments.length === 0) {\n            return OffsetDateTime.now(Clock.systemDefaultZone());\n        } else {\n            requireNonNull(clockOrZone, \"clockOrZone\");\n            if (clockOrZone instanceof ZoneId) {\n                return OffsetDateTime.now(Clock.system(clockOrZone));\n            } else if (clockOrZone instanceof Clock) {\n                var now = clockOrZone.instant();\n                return OffsetDateTime.ofInstant(now, clockOrZone.zone().rules().offset(now));\n            } else {\n                throw new IllegalArgumentException(\"clockOrZone must be an instance of ZoneId or Clock\");\n            }\n        }\n    };\n    OffsetDateTime.of = function of() {\n        if (arguments.length <= 2) {\n            return OffsetDateTime.ofDateTime.apply(this, arguments);\n        } else if (arguments.length === 3) {\n            return OffsetDateTime.ofDateAndTime.apply(this, arguments);\n        } else {\n            return OffsetDateTime.ofNumbers.apply(this, arguments);\n        }\n    };\n    OffsetDateTime.ofDateTime = function ofDateTime(dateTime, offset) {\n        return new OffsetDateTime(dateTime, offset);\n    };\n    OffsetDateTime.ofDateAndTime = function ofDateAndTime(date, time, offset) {\n        var dt = LocalDateTime.of(date, time);\n        return new OffsetDateTime(dt, offset);\n    };\n    OffsetDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {\n        if (hour === void 0) {\n            hour = 0;\n        }\n        if (minute === void 0) {\n            minute = 0;\n        }\n        if (second === void 0) {\n            second = 0;\n        }\n        if (nanoOfSecond === void 0) {\n            nanoOfSecond = 0;\n        }\n        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);\n        return new OffsetDateTime(dt, offset);\n    };\n    OffsetDateTime.ofInstant = function ofInstant(instant, zone) {\n        requireNonNull(instant, \"instant\");\n        requireNonNull(zone, \"zone\");\n        var rules = zone.rules();\n        var offset = rules.offset(instant);\n        var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n        return new OffsetDateTime(ldt, offset);\n    };\n    OffsetDateTime.parse = function parse(text, formatter) {\n        if (formatter === void 0) {\n            formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n        }\n        requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, OffsetDateTime.FROM);\n    };\n    function OffsetDateTime(dateTime, offset) {\n        var _this;\n        _this = _Temporal.call(this) || this;\n        requireNonNull(dateTime, \"dateTime\");\n        requireInstance(dateTime, LocalDateTime, \"dateTime\");\n        requireNonNull(offset, \"offset\");\n        requireInstance(offset, ZoneOffset, \"offset\");\n        _this._dateTime = dateTime;\n        _this._offset = offset;\n        return _this;\n    }\n    var _proto = OffsetDateTime.prototype;\n    _proto.adjustInto = function adjustInto(temporal) {\n        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());\n    };\n    _proto.until = function until(endExclusive, unit) {\n        var end = OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withOffsetSameInstant(this._offset);\n            return this._dateTime.until(end._dateTime, unit);\n        }\n        return unit.between(this, end);\n    };\n    _proto.atZoneSameInstant = function atZoneSameInstant(zone) {\n        return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);\n    };\n    _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {\n        return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        if (_query === TemporalQueries.chronology()) {\n            return IsoChronology.INSTANCE;\n        } else if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {\n            return this.offset();\n        } else if (_query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        } else if (_query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        } else if (_query === TemporalQueries.zoneId()) {\n            return null;\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto.get = function get(field) {\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.INSTANT_SECONDS:\n                    throw new DateTimeException(\"Field too large for an int: \" + field);\n                case ChronoField.OFFSET_SECONDS:\n                    return this.offset().totalSeconds();\n            }\n            return this._dateTime.get(field);\n        }\n        return _Temporal.prototype.get.call(this, field);\n    };\n    _proto.getLong = function getLong(field) {\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.INSTANT_SECONDS:\n                    return this.toEpochSecond();\n                case ChronoField.OFFSET_SECONDS:\n                    return this.offset().totalSeconds();\n            }\n            return this._dateTime.getLong(field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.offset = function offset() {\n        return this._offset;\n    };\n    _proto.year = function year() {\n        return this._dateTime.year();\n    };\n    _proto.monthValue = function monthValue() {\n        return this._dateTime.monthValue();\n    };\n    _proto.month = function month() {\n        return this._dateTime.month();\n    };\n    _proto.dayOfMonth = function dayOfMonth() {\n        return this._dateTime.dayOfMonth();\n    };\n    _proto.dayOfYear = function dayOfYear() {\n        return this._dateTime.dayOfYear();\n    };\n    _proto.dayOfWeek = function dayOfWeek() {\n        return this._dateTime.dayOfWeek();\n    };\n    _proto.hour = function hour() {\n        return this._dateTime.hour();\n    };\n    _proto.minute = function minute() {\n        return this._dateTime.minute();\n    };\n    _proto.second = function second() {\n        return this._dateTime.second();\n    };\n    _proto.nano = function nano() {\n        return this._dateTime.nano();\n    };\n    _proto.toLocalDateTime = function toLocalDateTime() {\n        return this._dateTime;\n    };\n    _proto.toLocalDate = function toLocalDate() {\n        return this._dateTime.toLocalDate();\n    };\n    _proto.toLocalTime = function toLocalTime() {\n        return this._dateTime.toLocalTime();\n    };\n    _proto.toOffsetTime = function toOffsetTime() {\n        return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);\n    };\n    _proto.toZonedDateTime = function toZonedDateTime() {\n        return ZonedDateTime.of(this._dateTime, this._offset);\n    };\n    _proto.toInstant = function toInstant() {\n        return this._dateTime.toInstant(this._offset);\n    };\n    _proto.toEpochSecond = function toEpochSecond() {\n        return this._dateTime.toEpochSecond(this._offset);\n    };\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        if (field instanceof ChronoField) {\n            if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {\n                return field.range();\n            }\n            return this._dateTime.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    };\n    _proto._withAdjuster = function _withAdjuster(adjuster) {\n        requireNonNull(adjuster);\n        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {\n            return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);\n        } else if (adjuster instanceof Instant) {\n            return OffsetDateTime.ofInstant(adjuster, this._offset);\n        } else if (adjuster instanceof ZoneOffset) {\n            return this._withDateTimeOffset(this._dateTime, adjuster);\n        } else if (adjuster instanceof OffsetDateTime) {\n            return adjuster;\n        }\n        return adjuster.adjustInto(this);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        requireNonNull(field);\n        if (field instanceof ChronoField) {\n            var f = field;\n            switch(f){\n                case ChronoField.INSTANT_SECONDS:\n                    return OffsetDateTime.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);\n                case ChronoField.OFFSET_SECONDS:\n                    {\n                        return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));\n                    }\n            }\n            return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {\n        if (this._dateTime === dateTime && this._offset.equals(offset)) {\n            return this;\n        }\n        return new OffsetDateTime(dateTime, offset);\n    };\n    _proto.withYear = function withYear(year) {\n        return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);\n    };\n    _proto.withMonth = function withMonth(month) {\n        return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);\n    };\n    _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n        return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);\n    };\n    _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n        return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);\n    };\n    _proto.withHour = function withHour(hour) {\n        return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);\n    };\n    _proto.withMinute = function withMinute(minute) {\n        return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);\n    };\n    _proto.withSecond = function withSecond(second) {\n        return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);\n    };\n    _proto.withNano = function withNano(nanoOfSecond) {\n        return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);\n    };\n    _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {\n        requireNonNull(offset, \"offset\");\n        return this._withDateTimeOffset(this._dateTime, offset);\n    };\n    _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {\n        requireNonNull(offset, \"offset\");\n        if (offset.equals(this._offset)) {\n            return this;\n        }\n        var difference = offset.totalSeconds() - this._offset.totalSeconds();\n        var adjusted = this._dateTime.plusSeconds(difference);\n        return new OffsetDateTime(adjusted, offset);\n    };\n    _proto.truncatedTo = function truncatedTo(unit) {\n        return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);\n    };\n    _proto._plusAmount = function _plusAmount(amount) {\n        requireNonNull(amount, \"amount\");\n        return amount.addTo(this);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        if (unit instanceof ChronoUnit) {\n            return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusYears = function plusYears(years) {\n        return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);\n    };\n    _proto.plusMonths = function plusMonths(months) {\n        return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);\n    };\n    _proto.plusWeeks = function plusWeeks(weeks) {\n        return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);\n    };\n    _proto.plusDays = function plusDays(days) {\n        return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);\n    };\n    _proto.plusHours = function plusHours(hours) {\n        return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);\n    };\n    _proto.plusMinutes = function plusMinutes(minutes) {\n        return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);\n    };\n    _proto.plusSeconds = function plusSeconds(seconds) {\n        return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);\n    };\n    _proto.plusNanos = function plusNanos(nanos) {\n        return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);\n    };\n    _proto._minusAmount = function _minusAmount(amount) {\n        requireNonNull(amount);\n        return amount.subtractFrom(this);\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        return this.plus(-1 * amountToSubtract, unit);\n    };\n    _proto.minusYears = function minusYears(years) {\n        return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);\n    };\n    _proto.minusMonths = function minusMonths(months) {\n        return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);\n    };\n    _proto.minusWeeks = function minusWeeks(weeks) {\n        return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);\n    };\n    _proto.minusDays = function minusDays(days) {\n        return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);\n    };\n    _proto.minusHours = function minusHours(hours) {\n        return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);\n    };\n    _proto.minusMinutes = function minusMinutes(minutes) {\n        return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);\n    };\n    _proto.minusSeconds = function minusSeconds(seconds) {\n        return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);\n    };\n    _proto.minusNanos = function minusNanos(nanos) {\n        return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, OffsetDateTime, \"other\");\n        if (this.offset().equals(other.offset())) {\n            return this.toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());\n        if (cmp === 0) {\n            cmp = this.toLocalTime().nano() - other.toLocalTime().nano();\n            if (cmp === 0) {\n                cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());\n            }\n        }\n        return cmp;\n    };\n    _proto.isAfter = function isAfter(other) {\n        requireNonNull(other, \"other\");\n        var thisEpochSec = this.toEpochSecond();\n        var otherEpochSec = other.toEpochSecond();\n        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();\n    };\n    _proto.isBefore = function isBefore(other) {\n        requireNonNull(other, \"other\");\n        var thisEpochSec = this.toEpochSecond();\n        var otherEpochSec = other.toEpochSecond();\n        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();\n    };\n    _proto.isEqual = function isEqual(other) {\n        requireNonNull(other, \"other\");\n        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof OffsetDateTime) {\n            return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return this._dateTime.hashCode() ^ this._offset.hashCode();\n    };\n    _proto.toString = function toString() {\n        return this._dateTime.toString() + this._offset.toString();\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    };\n    return OffsetDateTime;\n}(Temporal);\nfunction _init$6() {\n    OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);\n    OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);\n    OffsetDateTime.FROM = createTemporalQuery(\"OffsetDateTime.FROM\", function(temporal) {\n        return OffsetDateTime.from(temporal);\n    });\n}\nvar DAYS_PER_CYCLE = 146097;\nvar DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);\nvar LocalDate = function(_ChronoLocalDate) {\n    _inheritsLoose(LocalDate, _ChronoLocalDate);\n    LocalDate.now = function now(clockOrZone) {\n        var clock;\n        if (clockOrZone == null) {\n            clock = Clock.systemDefaultZone();\n        } else if (clockOrZone instanceof ZoneId) {\n            clock = Clock.system(clockOrZone);\n        } else {\n            clock = clockOrZone;\n        }\n        return LocalDate.ofInstant(clock.instant(), clock.zone());\n    };\n    LocalDate.ofInstant = function ofInstant(instant, zone) {\n        if (zone === void 0) {\n            zone = ZoneId.systemDefault();\n        }\n        requireNonNull(instant, \"instant\");\n        var offset = zone.rules().offset(instant);\n        var epochSec = instant.epochSecond() + offset.totalSeconds();\n        var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);\n        return LocalDate.ofEpochDay(epochDay);\n    };\n    LocalDate.of = function of(year, month, dayOfMonth) {\n        return new LocalDate(year, month, dayOfMonth);\n    };\n    LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {\n        ChronoField.YEAR.checkValidValue(year);\n        var leap = IsoChronology.isLeapYear(year);\n        if (dayOfYear === 366 && leap === false) {\n            assert(false, \"Invalid date 'DayOfYear 366' as '\" + year + \"' is not a leap year\", DateTimeException);\n        }\n        var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));\n        var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;\n        if (dayOfYear > monthEnd) {\n            moy = moy.plus(1);\n        }\n        var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;\n        return new LocalDate(year, moy.value(), dom);\n    };\n    LocalDate.ofEpochDay = function ofEpochDay(epochDay) {\n        if (epochDay === void 0) {\n            epochDay = 0;\n        }\n        var adjust, adjustCycles, doyEst, yearEst, zeroDay;\n        zeroDay = epochDay + DAYS_0000_TO_1970;\n        zeroDay -= 60;\n        adjust = 0;\n        if (zeroDay < 0) {\n            adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;\n            adjust = adjustCycles * 400;\n            zeroDay += -adjustCycles * DAYS_PER_CYCLE;\n        }\n        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);\n        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        if (doyEst < 0) {\n            yearEst--;\n            doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));\n        }\n        yearEst += adjust;\n        var marchDoy0 = doyEst;\n        var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);\n        var month = (marchMonth0 + 2) % 12 + 1;\n        var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;\n        yearEst += MathUtil.intDiv(marchMonth0, 10);\n        var year = yearEst;\n        return new LocalDate(year, month, dom);\n    };\n    LocalDate.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        var date = temporal.query(TemporalQueries.localDate());\n        if (date == null) {\n            throw new DateTimeException(\"Unable to obtain LocalDate from TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n        return date;\n    };\n    LocalDate.parse = function parse(text, formatter) {\n        if (formatter === void 0) {\n            formatter = DateTimeFormatter.ISO_LOCAL_DATE;\n        }\n        assert(formatter != null, \"formatter\", NullPointerException);\n        return formatter.parse(text, LocalDate.FROM);\n    };\n    LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {\n        switch(month){\n            case 2:\n                day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);\n                break;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                day = Math.min(day, 30);\n                break;\n        }\n        return LocalDate.of(year, month, day);\n    };\n    function LocalDate(year, month, dayOfMonth) {\n        var _this;\n        _this = _ChronoLocalDate.call(this) || this;\n        requireNonNull(year, \"year\");\n        requireNonNull(month, \"month\");\n        requireNonNull(dayOfMonth, \"dayOfMonth\");\n        if (month instanceof Month) {\n            month = month.value();\n        }\n        _this._year = MathUtil.safeToInt(year);\n        _this._month = MathUtil.safeToInt(month);\n        _this._day = MathUtil.safeToInt(dayOfMonth);\n        LocalDate._validate(_this._year, _this._month, _this._day);\n        return _this;\n    }\n    LocalDate._validate = function _validate(year, month, dayOfMonth) {\n        var dom;\n        ChronoField.YEAR.checkValidValue(year);\n        ChronoField.MONTH_OF_YEAR.checkValidValue(month);\n        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);\n        if (dayOfMonth > 28) {\n            dom = 31;\n            switch(month){\n                case 2:\n                    dom = IsoChronology.isLeapYear(year) ? 29 : 28;\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    dom = 30;\n            }\n            if (dayOfMonth > dom) {\n                if (dayOfMonth === 29) {\n                    assert(false, \"Invalid date 'February 29' as '\" + year + \"' is not a leap year\", DateTimeException);\n                } else {\n                    assert(false, \"Invalid date '\" + year + \"' '\" + month + \"' '\" + dayOfMonth + \"'\", DateTimeException);\n                }\n            }\n        }\n    };\n    var _proto = LocalDate.prototype;\n    _proto.isSupported = function isSupported(field) {\n        return _ChronoLocalDate.prototype.isSupported.call(this, field);\n    };\n    _proto.range = function range(field) {\n        if (field instanceof ChronoField) {\n            if (field.isDateBased()) {\n                switch(field){\n                    case ChronoField.DAY_OF_MONTH:\n                        return ValueRange.of(1, this.lengthOfMonth());\n                    case ChronoField.DAY_OF_YEAR:\n                        return ValueRange.of(1, this.lengthOfYear());\n                    case ChronoField.ALIGNED_WEEK_OF_MONTH:\n                        return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);\n                    case ChronoField.YEAR_OF_ERA:\n                        return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);\n                }\n                return field.range();\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.rangeRefinedBy(this);\n    };\n    _proto.get = function get(field) {\n        return this.getLong(field);\n    };\n    _proto.getLong = function getLong(field) {\n        assert(field != null, \"\", NullPointerException);\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    };\n    _proto._get0 = function _get0(field) {\n        switch(field){\n            case ChronoField.DAY_OF_WEEK:\n                return this.dayOfWeek().value();\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n                return MathUtil.intMod(this._day - 1, 7) + 1;\n            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n                return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;\n            case ChronoField.DAY_OF_MONTH:\n                return this._day;\n            case ChronoField.DAY_OF_YEAR:\n                return this.dayOfYear();\n            case ChronoField.EPOCH_DAY:\n                return this.toEpochDay();\n            case ChronoField.ALIGNED_WEEK_OF_MONTH:\n                return MathUtil.intDiv(this._day - 1, 7) + 1;\n            case ChronoField.ALIGNED_WEEK_OF_YEAR:\n                return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;\n            case ChronoField.MONTH_OF_YEAR:\n                return this._month;\n            case ChronoField.PROLEPTIC_MONTH:\n                return this._prolepticMonth();\n            case ChronoField.YEAR_OF_ERA:\n                return this._year >= 1 ? this._year : 1 - this._year;\n            case ChronoField.YEAR:\n                return this._year;\n            case ChronoField.ERA:\n                return this._year >= 1 ? 1 : 0;\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    };\n    _proto._prolepticMonth = function _prolepticMonth() {\n        return this._year * 12 + (this._month - 1);\n    };\n    _proto.chronology = function chronology() {\n        return IsoChronology.INSTANCE;\n    };\n    _proto.year = function year() {\n        return this._year;\n    };\n    _proto.monthValue = function monthValue() {\n        return this._month;\n    };\n    _proto.month = function month() {\n        return Month.of(this._month);\n    };\n    _proto.dayOfMonth = function dayOfMonth() {\n        return this._day;\n    };\n    _proto.dayOfYear = function dayOfYear() {\n        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;\n    };\n    _proto.dayOfWeek = function dayOfWeek() {\n        var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);\n        return DayOfWeek.of(dow0 + 1);\n    };\n    _proto.isLeapYear = function isLeapYear() {\n        return IsoChronology.isLeapYear(this._year);\n    };\n    _proto.lengthOfMonth = function lengthOfMonth() {\n        switch(this._month){\n            case 2:\n                return this.isLeapYear() ? 29 : 28;\n            case 4:\n            case 6:\n            case 9:\n            case 11:\n                return 30;\n            default:\n                return 31;\n        }\n    };\n    _proto.lengthOfYear = function lengthOfYear() {\n        return this.isLeapYear() ? 366 : 365;\n    };\n    _proto._withAdjuster = function _withAdjuster(adjuster) {\n        requireNonNull(adjuster, \"adjuster\");\n        if (adjuster instanceof LocalDate) {\n            return adjuster;\n        }\n        return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        assert(field != null, \"field\", NullPointerException);\n        if (field instanceof ChronoField) {\n            var f = field;\n            f.checkValidValue(newValue);\n            switch(f){\n                case ChronoField.DAY_OF_WEEK:\n                    return this.plusDays(newValue - this.dayOfWeek().value());\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:\n                    return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));\n                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:\n                    return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));\n                case ChronoField.DAY_OF_MONTH:\n                    return this.withDayOfMonth(newValue);\n                case ChronoField.DAY_OF_YEAR:\n                    return this.withDayOfYear(newValue);\n                case ChronoField.EPOCH_DAY:\n                    return LocalDate.ofEpochDay(newValue);\n                case ChronoField.ALIGNED_WEEK_OF_MONTH:\n                    return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));\n                case ChronoField.ALIGNED_WEEK_OF_YEAR:\n                    return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));\n                case ChronoField.MONTH_OF_YEAR:\n                    return this.withMonth(newValue);\n                case ChronoField.PROLEPTIC_MONTH:\n                    return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));\n                case ChronoField.YEAR_OF_ERA:\n                    return this.withYear(this._year >= 1 ? newValue : 1 - newValue);\n                case ChronoField.YEAR:\n                    return this.withYear(newValue);\n                case ChronoField.ERA:\n                    return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto.withYear = function withYear(year) {\n        if (this._year === year) {\n            return this;\n        }\n        ChronoField.YEAR.checkValidValue(year);\n        return LocalDate._resolvePreviousValid(year, this._month, this._day);\n    };\n    _proto.withMonth = function withMonth(month) {\n        var m = month instanceof Month ? month.value() : month;\n        if (this._month === m) {\n            return this;\n        }\n        ChronoField.MONTH_OF_YEAR.checkValidValue(m);\n        return LocalDate._resolvePreviousValid(this._year, m, this._day);\n    };\n    _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n        if (this._day === dayOfMonth) {\n            return this;\n        }\n        return LocalDate.of(this._year, this._month, dayOfMonth);\n    };\n    _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n        if (this.dayOfYear() === dayOfYear) {\n            return this;\n        }\n        return LocalDate.ofYearDay(this._year, dayOfYear);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, \"amountToAdd\");\n        requireNonNull(unit, \"unit\");\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.DAYS:\n                    return this.plusDays(amountToAdd);\n                case ChronoUnit.WEEKS:\n                    return this.plusWeeks(amountToAdd);\n                case ChronoUnit.MONTHS:\n                    return this.plusMonths(amountToAdd);\n                case ChronoUnit.YEARS:\n                    return this.plusYears(amountToAdd);\n                case ChronoUnit.DECADES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));\n                case ChronoUnit.CENTURIES:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));\n                case ChronoUnit.MILLENNIA:\n                    return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));\n                case ChronoUnit.ERAS:\n                    return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusYears = function plusYears(yearsToAdd) {\n        if (yearsToAdd === 0) {\n            return this;\n        }\n        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);\n        return LocalDate._resolvePreviousValid(newYear, this._month, this._day);\n    };\n    _proto.plusMonths = function plusMonths(monthsToAdd) {\n        if (monthsToAdd === 0) {\n            return this;\n        }\n        var monthCount = this._year * 12 + (this._month - 1);\n        var calcMonths = monthCount + monthsToAdd;\n        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));\n        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;\n        return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);\n    };\n    _proto.plusWeeks = function plusWeeks(weeksToAdd) {\n        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));\n    };\n    _proto.plusDays = function plusDays(daysToAdd) {\n        if (daysToAdd === 0) {\n            return this;\n        }\n        var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);\n        return LocalDate.ofEpochDay(mjDay);\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        requireNonNull(amountToSubtract, \"amountToSubtract\");\n        requireNonNull(unit, \"unit\");\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    };\n    _proto.minusYears = function minusYears(yearsToSubtract) {\n        return this.plusYears(yearsToSubtract * -1);\n    };\n    _proto.minusMonths = function minusMonths(monthsToSubtract) {\n        return this.plusMonths(monthsToSubtract * -1);\n    };\n    _proto.minusWeeks = function minusWeeks(weeksToSubtract) {\n        return this.plusWeeks(weeksToSubtract * -1);\n    };\n    _proto.minusDays = function minusDays(daysToSubtract) {\n        return this.plusDays(daysToSubtract * -1);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        if (_query === TemporalQueries.localDate()) {\n            return this;\n        }\n        return _ChronoLocalDate.prototype.query.call(this, _query);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);\n    };\n    _proto.until = function until(p1, p2) {\n        if (arguments.length < 2) {\n            return this.until1(p1);\n        } else {\n            return this.until2(p1, p2);\n        }\n    };\n    _proto.until2 = function until2(endExclusive, unit) {\n        var end = LocalDate.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.DAYS:\n                    return this.daysUntil(end);\n                case ChronoUnit.WEEKS:\n                    return MathUtil.intDiv(this.daysUntil(end), 7);\n                case ChronoUnit.MONTHS:\n                    return this._monthsUntil(end);\n                case ChronoUnit.YEARS:\n                    return MathUtil.intDiv(this._monthsUntil(end), 12);\n                case ChronoUnit.DECADES:\n                    return MathUtil.intDiv(this._monthsUntil(end), 120);\n                case ChronoUnit.CENTURIES:\n                    return MathUtil.intDiv(this._monthsUntil(end), 1200);\n                case ChronoUnit.MILLENNIA:\n                    return MathUtil.intDiv(this._monthsUntil(end), 12000);\n                case ChronoUnit.ERAS:\n                    return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    };\n    _proto.daysUntil = function daysUntil(end) {\n        return end.toEpochDay() - this.toEpochDay();\n    };\n    _proto._monthsUntil = function _monthsUntil(end) {\n        var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();\n        var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();\n        return MathUtil.intDiv(packed2 - packed1, 32);\n    };\n    _proto.until1 = function until1(endDate) {\n        var end = LocalDate.from(endDate);\n        var totalMonths = end._prolepticMonth() - this._prolepticMonth();\n        var days = end._day - this._day;\n        if (totalMonths > 0 && days < 0) {\n            totalMonths--;\n            var calcDate = this.plusMonths(totalMonths);\n            days = end.toEpochDay() - calcDate.toEpochDay();\n        } else if (totalMonths < 0 && days > 0) {\n            totalMonths++;\n            days -= end.lengthOfMonth();\n        }\n        var years = MathUtil.intDiv(totalMonths, 12);\n        var months = MathUtil.intMod(totalMonths, 12);\n        return Period.of(years, months, days);\n    };\n    _proto.atTime = function atTime() {\n        if (arguments.length === 1) {\n            return this.atTime1.apply(this, arguments);\n        } else {\n            return this.atTime4.apply(this, arguments);\n        }\n    };\n    _proto.atTime1 = function atTime1(time) {\n        requireNonNull(time, \"time\");\n        if (time instanceof LocalTime) {\n            return LocalDateTime.of(this, time);\n        } else if (time instanceof OffsetTime) {\n            return this._atTimeOffsetTime(time);\n        } else {\n            throw new IllegalArgumentException(\"time must be an instance of LocalTime or OffsetTime\" + (time && time.constructor && time.constructor.name ? \", but is \" + time.constructor.name : \"\"));\n        }\n    };\n    _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {\n        if (second === void 0) {\n            second = 0;\n        }\n        if (nanoOfSecond === void 0) {\n            nanoOfSecond = 0;\n        }\n        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));\n    };\n    _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {\n        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());\n    };\n    _proto.atStartOfDay = function atStartOfDay(zone) {\n        if (zone != null) {\n            return this._atStartOfDayWithZone(zone);\n        } else {\n            return LocalDateTime.of(this, LocalTime.MIDNIGHT);\n        }\n    };\n    _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {\n        requireNonNull(zone, \"zone\");\n        var ldt = this.atTime(LocalTime.MIDNIGHT);\n        if (zone instanceof ZoneOffset === false) {\n            var trans = zone.rules().transition(ldt);\n            if (trans != null && trans.isGap()) {\n                ldt = trans.dateTimeAfter();\n            }\n        }\n        return ZonedDateTime.of(ldt, zone);\n    };\n    _proto.toEpochDay = function toEpochDay() {\n        var y = this._year;\n        var m = this._month;\n        var total = 0;\n        total += 365 * y;\n        if (y >= 0) {\n            total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);\n        } else {\n            total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);\n        }\n        total += MathUtil.intDiv(367 * m - 362, 12);\n        total += this.dayOfMonth() - 1;\n        if (m > 2) {\n            total--;\n            if (!IsoChronology.isLeapYear(y)) {\n                total--;\n            }\n        }\n        return total - DAYS_0000_TO_1970;\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, LocalDate, \"other\");\n        return this._compareTo0(other);\n    };\n    _proto._compareTo0 = function _compareTo0(otherDate) {\n        var cmp = this._year - otherDate._year;\n        if (cmp === 0) {\n            cmp = this._month - otherDate._month;\n            if (cmp === 0) {\n                cmp = this._day - otherDate._day;\n            }\n        }\n        return cmp;\n    };\n    _proto.isAfter = function isAfter(other) {\n        return this.compareTo(other) > 0;\n    };\n    _proto.isBefore = function isBefore(other) {\n        return this.compareTo(other) < 0;\n    };\n    _proto.isEqual = function isEqual(other) {\n        return this.compareTo(other) === 0;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalDate) {\n            return this._compareTo0(other) === 0;\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        var yearValue = this._year;\n        var monthValue = this._month;\n        var dayValue = this._day;\n        return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);\n    };\n    _proto.toString = function toString() {\n        var dayString, monthString, yearString;\n        var yearValue = this._year;\n        var monthValue = this._month;\n        var dayValue = this._day;\n        var absYear = Math.abs(yearValue);\n        if (absYear < 1000) {\n            if (yearValue < 0) {\n                yearString = \"-\" + (\"\" + (yearValue - 10000)).slice(-4);\n            } else {\n                yearString = (\"\" + (yearValue + 10000)).slice(-4);\n            }\n        } else {\n            if (yearValue > 9999) {\n                yearString = \"+\" + yearValue;\n            } else {\n                yearString = \"\" + yearValue;\n            }\n        }\n        if (monthValue < 10) {\n            monthString = \"-0\" + monthValue;\n        } else {\n            monthString = \"-\" + monthValue;\n        }\n        if (dayValue < 10) {\n            dayString = \"-0\" + dayValue;\n        } else {\n            dayString = \"-\" + dayValue;\n        }\n        return yearString + monthString + dayString;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        requireInstance(formatter, DateTimeFormatter, \"formatter\");\n        return _ChronoLocalDate.prototype.format.call(this, formatter);\n    };\n    return LocalDate;\n}(ChronoLocalDate);\nfunction _init$5() {\n    LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);\n    LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);\n    LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);\n    LocalDate.FROM = createTemporalQuery(\"LocalDate.FROM\", function(temporal) {\n        return LocalDate.from(temporal);\n    });\n}\nvar ChronoLocalDateTime = function(_Temporal) {\n    _inheritsLoose(ChronoLocalDateTime, _Temporal);\n    function ChronoLocalDateTime() {\n        return _Temporal.apply(this, arguments) || this;\n    }\n    var _proto = ChronoLocalDateTime.prototype;\n    _proto.chronology = function chronology() {\n        return this.toLocalDate().chronology();\n    };\n    _proto.query = function query(_query) {\n        if (_query === TemporalQueries.chronology()) {\n            return this.chronology();\n        } else if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (_query === TemporalQueries.localDate()) {\n            return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());\n        } else if (_query === TemporalQueries.localTime()) {\n            return this.toLocalTime();\n        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {\n            return null;\n        }\n        return _Temporal.prototype.query.call(this, _query);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());\n    };\n    _proto.toInstant = function toInstant(offset) {\n        requireInstance(offset, ZoneOffset, \"zoneId\");\n        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());\n    };\n    _proto.toEpochSecond = function toEpochSecond(offset) {\n        requireNonNull(offset, \"offset\");\n        var epochDay = this.toLocalDate().toEpochDay();\n        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();\n        secs -= offset.totalSeconds();\n        return MathUtil.safeToInt(secs);\n    };\n    return ChronoLocalDateTime;\n}(Temporal);\nvar LocalDateTime = function(_ChronoLocalDateTime) {\n    _inheritsLoose(LocalDateTime, _ChronoLocalDateTime);\n    LocalDateTime.now = function now(clockOrZone) {\n        if (clockOrZone == null) {\n            return LocalDateTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock) {\n            return LocalDateTime._now(clockOrZone);\n        } else {\n            return LocalDateTime._now(Clock.system(clockOrZone));\n        }\n    };\n    LocalDateTime._now = function _now(clock) {\n        requireNonNull(clock, \"clock\");\n        return LocalDateTime.ofInstant(clock.instant(), clock.zone());\n    };\n    LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {\n        var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();\n        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;\n        var date = LocalDate.ofEpochDay(localEpochDay);\n        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    };\n    LocalDateTime.of = function of() {\n        if (arguments.length <= 2) {\n            return LocalDateTime.ofDateAndTime.apply(this, arguments);\n        } else {\n            return LocalDateTime.ofNumbers.apply(this, arguments);\n        }\n    };\n    LocalDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {\n        if (hour === void 0) {\n            hour = 0;\n        }\n        if (minute === void 0) {\n            minute = 0;\n        }\n        if (second === void 0) {\n            second = 0;\n        }\n        if (nanoOfSecond === void 0) {\n            nanoOfSecond = 0;\n        }\n        var date = LocalDate.of(year, month, dayOfMonth);\n        var time = LocalTime.of(hour, minute, second, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    };\n    LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {\n        requireNonNull(date, \"date\");\n        requireNonNull(time, \"time\");\n        return new LocalDateTime(date, time);\n    };\n    LocalDateTime.ofInstant = function ofInstant(instant, zone) {\n        if (zone === void 0) {\n            zone = ZoneId.systemDefault();\n        }\n        requireNonNull(instant, \"instant\");\n        requireInstance(instant, Instant, \"instant\");\n        requireNonNull(zone, \"zone\");\n        var offset = zone.rules().offset(instant);\n        return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);\n    };\n    LocalDateTime.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {\n        if (epochSecond === void 0) {\n            epochSecond = 0;\n        }\n        if (nanoOfSecond === void 0) {\n            nanoOfSecond = 0;\n        }\n        if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {\n            offset = nanoOfSecond;\n            nanoOfSecond = 0;\n        }\n        requireNonNull(offset, \"offset\");\n        var localSecond = epochSecond + offset.totalSeconds();\n        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);\n        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);\n        var date = LocalDate.ofEpochDay(localEpochDay);\n        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);\n        return new LocalDateTime(date, time);\n    };\n    LocalDateTime.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        if (temporal instanceof LocalDateTime) {\n            return temporal;\n        } else if (temporal instanceof ZonedDateTime) {\n            return temporal.toLocalDateTime();\n        }\n        try {\n            var date = LocalDate.from(temporal);\n            var time = LocalTime.from(temporal);\n            return new LocalDateTime(date, time);\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain LocalDateTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n    };\n    LocalDateTime.parse = function parse(text, formatter) {\n        if (formatter === void 0) {\n            formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n        }\n        requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalDateTime.FROM);\n    };\n    function LocalDateTime(date, time) {\n        var _this;\n        _this = _ChronoLocalDateTime.call(this) || this;\n        requireInstance(date, LocalDate, \"date\");\n        requireInstance(time, LocalTime, \"time\");\n        _this._date = date;\n        _this._time = time;\n        return _this;\n    }\n    var _proto = LocalDateTime.prototype;\n    _proto._withDateTime = function _withDateTime(newDate, newTime) {\n        if (this._date.equals(newDate) && this._time.equals(newTime)) {\n            return this;\n        }\n        return new LocalDateTime(newDate, newTime);\n    };\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        if (field instanceof ChronoField) {\n            return field.isTimeBased() ? this._time.range(field) : this._date.range(field);\n        }\n        return field.rangeRefinedBy(this);\n    };\n    _proto.get = function get(field) {\n        if (field instanceof ChronoField) {\n            return field.isTimeBased() ? this._time.get(field) : this._date.get(field);\n        }\n        return _ChronoLocalDateTime.prototype.get.call(this, field);\n    };\n    _proto.getLong = function getLong(field) {\n        requireNonNull(field, \"field\");\n        if (field instanceof ChronoField) {\n            return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.year = function year() {\n        return this._date.year();\n    };\n    _proto.monthValue = function monthValue() {\n        return this._date.monthValue();\n    };\n    _proto.month = function month() {\n        return this._date.month();\n    };\n    _proto.dayOfMonth = function dayOfMonth() {\n        return this._date.dayOfMonth();\n    };\n    _proto.dayOfYear = function dayOfYear() {\n        return this._date.dayOfYear();\n    };\n    _proto.dayOfWeek = function dayOfWeek() {\n        return this._date.dayOfWeek();\n    };\n    _proto.hour = function hour() {\n        return this._time.hour();\n    };\n    _proto.minute = function minute() {\n        return this._time.minute();\n    };\n    _proto.second = function second() {\n        return this._time.second();\n    };\n    _proto.nano = function nano() {\n        return this._time.nano();\n    };\n    _proto._withAdjuster = function _withAdjuster(adjuster) {\n        requireNonNull(adjuster, \"adjuster\");\n        if (adjuster instanceof LocalDate) {\n            return this._withDateTime(adjuster, this._time);\n        } else if (adjuster instanceof LocalTime) {\n            return this._withDateTime(this._date, adjuster);\n        } else if (adjuster instanceof LocalDateTime) {\n            return adjuster;\n        }\n        return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        requireNonNull(field, \"field\");\n        if (field instanceof ChronoField) {\n            if (field.isTimeBased()) {\n                return this._withDateTime(this._date, this._time.with(field, newValue));\n            } else {\n                return this._withDateTime(this._date.with(field, newValue), this._time);\n            }\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto.withYear = function withYear(year) {\n        return this._withDateTime(this._date.withYear(year), this._time);\n    };\n    _proto.withMonth = function withMonth(month) {\n        return this._withDateTime(this._date.withMonth(month), this._time);\n    };\n    _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {\n        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);\n    };\n    _proto.withDayOfYear = function withDayOfYear(dayOfYear) {\n        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);\n    };\n    _proto.withHour = function withHour(hour) {\n        var newTime = this._time.withHour(hour);\n        return this._withDateTime(this._date, newTime);\n    };\n    _proto.withMinute = function withMinute(minute) {\n        var newTime = this._time.withMinute(minute);\n        return this._withDateTime(this._date, newTime);\n    };\n    _proto.withSecond = function withSecond(second) {\n        var newTime = this._time.withSecond(second);\n        return this._withDateTime(this._date, newTime);\n    };\n    _proto.withNano = function withNano(nanoOfSecond) {\n        var newTime = this._time.withNano(nanoOfSecond);\n        return this._withDateTime(this._date, newTime);\n    };\n    _proto.truncatedTo = function truncatedTo(unit) {\n        return this._withDateTime(this._date, this._time.truncatedTo(unit));\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        requireNonNull(unit, \"unit\");\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.NANOS:\n                    return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS:\n                    return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS:\n                    return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS:\n                    return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES:\n                    return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS:\n                    return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS:\n                    return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);\n            }\n            return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusYears = function plusYears(years) {\n        var newDate = this._date.plusYears(years);\n        return this._withDateTime(newDate, this._time);\n    };\n    _proto.plusMonths = function plusMonths(months) {\n        var newDate = this._date.plusMonths(months);\n        return this._withDateTime(newDate, this._time);\n    };\n    _proto.plusWeeks = function plusWeeks(weeks) {\n        var newDate = this._date.plusWeeks(weeks);\n        return this._withDateTime(newDate, this._time);\n    };\n    _proto.plusDays = function plusDays(days) {\n        var newDate = this._date.plusDays(days);\n        return this._withDateTime(newDate, this._time);\n    };\n    _proto.plusHours = function plusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);\n    };\n    _proto.plusMinutes = function plusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);\n    };\n    _proto.plusSeconds = function plusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);\n    };\n    _proto.plusNanos = function plusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        requireNonNull(unit, \"unit\");\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    };\n    _proto.minusYears = function minusYears(years) {\n        return this.plusYears(-1 * years);\n    };\n    _proto.minusMonths = function minusMonths(months) {\n        return this.plusMonths(-1 * months);\n    };\n    _proto.minusWeeks = function minusWeeks(weeks) {\n        return this.plusWeeks(-1 * weeks);\n    };\n    _proto.minusDays = function minusDays(days) {\n        return this.plusDays(-1 * days);\n    };\n    _proto.minusHours = function minusHours(hours) {\n        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);\n    };\n    _proto.minusMinutes = function minusMinutes(minutes) {\n        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);\n    };\n    _proto.minusSeconds = function minusSeconds(seconds) {\n        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);\n    };\n    _proto.minusNanos = function minusNanos(nanos) {\n        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);\n    };\n    _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {\n        if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {\n            return this._withDateTime(newDate, this._time);\n        }\n        var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);\n        totDays *= sign;\n        var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;\n        var curNoD = this._time.toNanoOfDay();\n        totNanos = totNanos * sign + curNoD;\n        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);\n        var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);\n        var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);\n        return this._withDateTime(newDate.plusDays(totDays), newTime);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        if (_query === TemporalQueries.localDate()) {\n            return this.toLocalDate();\n        }\n        return _ChronoLocalDateTime.prototype.query.call(this, _query);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);\n    };\n    _proto.until = function until(endExclusive, unit) {\n        requireNonNull(endExclusive, \"endExclusive\");\n        requireNonNull(unit, \"unit\");\n        var end = LocalDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            if (unit.isTimeBased()) {\n                var daysUntil = this._date.daysUntil(end._date);\n                var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();\n                if (daysUntil > 0 && timeUntil < 0) {\n                    daysUntil--;\n                    timeUntil += LocalTime.NANOS_PER_DAY;\n                } else if (daysUntil < 0 && timeUntil > 0) {\n                    daysUntil++;\n                    timeUntil -= LocalTime.NANOS_PER_DAY;\n                }\n                var amount = daysUntil;\n                switch(unit){\n                    case ChronoUnit.NANOS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);\n                        return MathUtil.safeAdd(amount, timeUntil);\n                    case ChronoUnit.MICROS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));\n                    case ChronoUnit.MILLIS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));\n                    case ChronoUnit.SECONDS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));\n                    case ChronoUnit.MINUTES:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));\n                    case ChronoUnit.HOURS:\n                        amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));\n                    case ChronoUnit.HALF_DAYS:\n                        amount = MathUtil.safeMultiply(amount, 2);\n                        return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));\n                }\n                throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n            }\n            var endDate = end._date;\n            var endTime = end._time;\n            if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {\n                endDate = endDate.minusDays(1);\n            } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {\n                endDate = endDate.plusDays(1);\n            }\n            return this._date.until(endDate, unit);\n        }\n        return unit.between(this, end);\n    };\n    _proto.atOffset = function atOffset(offset) {\n        return OffsetDateTime.of(this, offset);\n    };\n    _proto.atZone = function atZone(zone) {\n        return ZonedDateTime.of(this, zone);\n    };\n    _proto.toLocalDate = function toLocalDate() {\n        return this._date;\n    };\n    _proto.toLocalTime = function toLocalTime() {\n        return this._time;\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, LocalDateTime, \"other\");\n        return this._compareTo0(other);\n    };\n    _proto._compareTo0 = function _compareTo0(other) {\n        var cmp = this._date.compareTo(other.toLocalDate());\n        if (cmp === 0) {\n            cmp = this._time.compareTo(other.toLocalTime());\n        }\n        return cmp;\n    };\n    _proto.isAfter = function isAfter(other) {\n        return this.compareTo(other) > 0;\n    };\n    _proto.isBefore = function isBefore(other) {\n        return this.compareTo(other) < 0;\n    };\n    _proto.isEqual = function isEqual(other) {\n        return this.compareTo(other) === 0;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalDateTime) {\n            return this._date.equals(other._date) && this._time.equals(other._time);\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return this._date.hashCode() ^ this._time.hashCode();\n    };\n    _proto.toString = function toString() {\n        return this._date.toString() + \"T\" + this._time.toString();\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    };\n    return LocalDateTime;\n}(ChronoLocalDateTime);\nfunction _init$4() {\n    LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);\n    LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);\n    LocalDateTime.FROM = createTemporalQuery(\"LocalDateTime.FROM\", function(temporal) {\n        return LocalDateTime.from(temporal);\n    });\n}\nvar LocalTime = function(_Temporal) {\n    _inheritsLoose(LocalTime, _Temporal);\n    LocalTime.now = function now(clockOrZone) {\n        if (clockOrZone == null) {\n            return LocalTime._now(Clock.systemDefaultZone());\n        } else if (clockOrZone instanceof Clock) {\n            return LocalTime._now(clockOrZone);\n        } else {\n            return LocalTime._now(Clock.system(clockOrZone));\n        }\n    };\n    LocalTime._now = function _now(clock) {\n        if (clock === void 0) {\n            clock = Clock.systemDefaultZone();\n        }\n        requireNonNull(clock, \"clock\");\n        return LocalTime.ofInstant(clock.instant(), clock.zone());\n    };\n    LocalTime.ofInstant = function ofInstant(instant, zone) {\n        if (zone === void 0) {\n            zone = ZoneId.systemDefault();\n        }\n        var offset = zone.rules().offset(instant);\n        var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);\n        secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);\n        if (secsOfDay < 0) {\n            secsOfDay += LocalTime.SECONDS_PER_DAY;\n        }\n        return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());\n    };\n    LocalTime.of = function of(hour, minute, second, nanoOfSecond) {\n        return new LocalTime(hour, minute, second, nanoOfSecond);\n    };\n    LocalTime.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {\n        if (secondOfDay === void 0) {\n            secondOfDay = 0;\n        }\n        if (nanoOfSecond === void 0) {\n            nanoOfSecond = 0;\n        }\n        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n        var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);\n        secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;\n        var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);\n        secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;\n        return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);\n    };\n    LocalTime.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {\n        if (nanoOfDay === void 0) {\n            nanoOfDay = 0;\n        }\n        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);\n        var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);\n        nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;\n        var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);\n        nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;\n        var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);\n        nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;\n        return new LocalTime(hours, minutes, seconds, nanoOfDay);\n    };\n    LocalTime.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        var time = temporal.query(TemporalQueries.localTime());\n        if (time == null) {\n            throw new DateTimeException(\"Unable to obtain LocalTime TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n        return time;\n    };\n    LocalTime.parse = function parse(text, formatter) {\n        if (formatter === void 0) {\n            formatter = DateTimeFormatter.ISO_LOCAL_TIME;\n        }\n        requireNonNull(formatter, \"formatter\");\n        return formatter.parse(text, LocalTime.FROM);\n    };\n    function LocalTime(hour, minute, second, nanoOfSecond) {\n        var _this;\n        if (hour === void 0) {\n            hour = 0;\n        }\n        if (minute === void 0) {\n            minute = 0;\n        }\n        if (second === void 0) {\n            second = 0;\n        }\n        if (nanoOfSecond === void 0) {\n            nanoOfSecond = 0;\n        }\n        _this = _Temporal.call(this) || this;\n        var _hour = MathUtil.safeToInt(hour);\n        var _minute = MathUtil.safeToInt(minute);\n        var _second = MathUtil.safeToInt(second);\n        var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);\n        LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);\n        if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {\n            if (!LocalTime.HOURS[_hour]) {\n                _this._hour = _hour;\n                _this._minute = _minute;\n                _this._second = _second;\n                _this._nano = _nanoOfSecond;\n                LocalTime.HOURS[_hour] = _assertThisInitialized(_this);\n            }\n            return LocalTime.HOURS[_hour] || _assertThisInitialized(_this);\n        }\n        _this._hour = _hour;\n        _this._minute = _minute;\n        _this._second = _second;\n        _this._nano = _nanoOfSecond;\n        return _this;\n    }\n    LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {\n        ChronoField.HOUR_OF_DAY.checkValidValue(hour);\n        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);\n        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);\n        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);\n    };\n    var _proto = LocalTime.prototype;\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit.isTimeBased();\n        } else if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased();\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        requireNonNull(field);\n        return _Temporal.prototype.range.call(this, field);\n    };\n    _proto.get = function get(field) {\n        return this.getLong(field);\n    };\n    _proto.getLong = function getLong(field) {\n        requireNonNull(field, \"field\");\n        if (field instanceof ChronoField) {\n            return this._get0(field);\n        }\n        return field.getFrom(this);\n    };\n    _proto._get0 = function _get0(field) {\n        switch(field){\n            case ChronoField.NANO_OF_SECOND:\n                return this._nano;\n            case ChronoField.NANO_OF_DAY:\n                return this.toNanoOfDay();\n            case ChronoField.MICRO_OF_SECOND:\n                return MathUtil.intDiv(this._nano, 1000);\n            case ChronoField.MICRO_OF_DAY:\n                return MathUtil.intDiv(this.toNanoOfDay(), 1000);\n            case ChronoField.MILLI_OF_SECOND:\n                return MathUtil.intDiv(this._nano, 1000000);\n            case ChronoField.MILLI_OF_DAY:\n                return MathUtil.intDiv(this.toNanoOfDay(), 1000000);\n            case ChronoField.SECOND_OF_MINUTE:\n                return this._second;\n            case ChronoField.SECOND_OF_DAY:\n                return this.toSecondOfDay();\n            case ChronoField.MINUTE_OF_HOUR:\n                return this._minute;\n            case ChronoField.MINUTE_OF_DAY:\n                return this._hour * 60 + this._minute;\n            case ChronoField.HOUR_OF_AMPM:\n                return MathUtil.intMod(this._hour, 12);\n            case ChronoField.CLOCK_HOUR_OF_AMPM:\n                {\n                    var ham = MathUtil.intMod(this._hour, 12);\n                    return ham % 12 === 0 ? 12 : ham;\n                }\n            case ChronoField.HOUR_OF_DAY:\n                return this._hour;\n            case ChronoField.CLOCK_HOUR_OF_DAY:\n                return this._hour === 0 ? 24 : this._hour;\n            case ChronoField.AMPM_OF_DAY:\n                return MathUtil.intDiv(this._hour, 12);\n        }\n        throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n    };\n    _proto.hour = function hour() {\n        return this._hour;\n    };\n    _proto.minute = function minute() {\n        return this._minute;\n    };\n    _proto.second = function second() {\n        return this._second;\n    };\n    _proto.nano = function nano() {\n        return this._nano;\n    };\n    _proto._withAdjuster = function _withAdjuster(adjuster) {\n        requireNonNull(adjuster, \"adjuster\");\n        if (adjuster instanceof LocalTime) {\n            return adjuster;\n        }\n        return _Temporal.prototype._withAdjuster.call(this, adjuster);\n    };\n    _proto._withField = function _withField(field, newValue) {\n        requireNonNull(field, \"field\");\n        requireInstance(field, TemporalField, \"field\");\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch(field){\n                case ChronoField.NANO_OF_SECOND:\n                    return this.withNano(newValue);\n                case ChronoField.NANO_OF_DAY:\n                    return LocalTime.ofNanoOfDay(newValue);\n                case ChronoField.MICRO_OF_SECOND:\n                    return this.withNano(newValue * 1000);\n                case ChronoField.MICRO_OF_DAY:\n                    return LocalTime.ofNanoOfDay(newValue * 1000);\n                case ChronoField.MILLI_OF_SECOND:\n                    return this.withNano(newValue * 1000000);\n                case ChronoField.MILLI_OF_DAY:\n                    return LocalTime.ofNanoOfDay(newValue * 1000000);\n                case ChronoField.SECOND_OF_MINUTE:\n                    return this.withSecond(newValue);\n                case ChronoField.SECOND_OF_DAY:\n                    return this.plusSeconds(newValue - this.toSecondOfDay());\n                case ChronoField.MINUTE_OF_HOUR:\n                    return this.withMinute(newValue);\n                case ChronoField.MINUTE_OF_DAY:\n                    return this.plusMinutes(newValue - (this._hour * 60 + this._minute));\n                case ChronoField.HOUR_OF_AMPM:\n                    return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));\n                case ChronoField.CLOCK_HOUR_OF_AMPM:\n                    return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));\n                case ChronoField.HOUR_OF_DAY:\n                    return this.withHour(newValue);\n                case ChronoField.CLOCK_HOUR_OF_DAY:\n                    return this.withHour(newValue === 24 ? 0 : newValue);\n                case ChronoField.AMPM_OF_DAY:\n                    return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto.withHour = function withHour(hour) {\n        if (hour === void 0) {\n            hour = 0;\n        }\n        if (this._hour === hour) {\n            return this;\n        }\n        return new LocalTime(hour, this._minute, this._second, this._nano);\n    };\n    _proto.withMinute = function withMinute(minute) {\n        if (minute === void 0) {\n            minute = 0;\n        }\n        if (this._minute === minute) {\n            return this;\n        }\n        return new LocalTime(this._hour, minute, this._second, this._nano);\n    };\n    _proto.withSecond = function withSecond(second) {\n        if (second === void 0) {\n            second = 0;\n        }\n        if (this._second === second) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, second, this._nano);\n    };\n    _proto.withNano = function withNano(nanoOfSecond) {\n        if (nanoOfSecond === void 0) {\n            nanoOfSecond = 0;\n        }\n        if (this._nano === nanoOfSecond) {\n            return this;\n        }\n        return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);\n    };\n    _proto.truncatedTo = function truncatedTo(unit) {\n        requireNonNull(unit, \"unit\");\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        var unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException(\"Unit is too large to be used for truncation\");\n        }\n        var dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException(\"Unit must divide into a standard day without remainder\");\n        }\n        var nod = this.toNanoOfDay();\n        return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        requireNonNull(unit, \"unit\");\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.NANOS:\n                    return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS:\n                    return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);\n                case ChronoUnit.MILLIS:\n                    return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);\n                case ChronoUnit.SECONDS:\n                    return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES:\n                    return this.plusMinutes(amountToAdd);\n                case ChronoUnit.HOURS:\n                    return this.plusHours(amountToAdd);\n                case ChronoUnit.HALF_DAYS:\n                    return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusHours = function plusHours(hoursToAdd) {\n        if (hoursToAdd === 0) {\n            return this;\n        }\n        var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);\n        return new LocalTime(newHour, this._minute, this._second, this._nano);\n    };\n    _proto.plusMinutes = function plusMinutes(minutesToAdd) {\n        if (minutesToAdd === 0) {\n            return this;\n        }\n        var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;\n        var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);\n        if (mofd === newMofd) {\n            return this;\n        }\n        var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);\n        var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);\n        return new LocalTime(newHour, newMinute, this._second, this._nano);\n    };\n    _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n        if (secondsToAdd === 0) {\n            return this;\n        }\n        var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;\n        var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);\n        if (sofd === newSofd) {\n            return this;\n        }\n        var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);\n        var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);\n        return new LocalTime(newHour, newMinute, newSecond, this._nano);\n    };\n    _proto.plusNanos = function plusNanos(nanosToAdd) {\n        if (nanosToAdd === 0) {\n            return this;\n        }\n        var nofd = this.toNanoOfDay();\n        var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);\n        if (nofd === newNofd) {\n            return this;\n        }\n        var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);\n        var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);\n        var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);\n        var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);\n        return new LocalTime(newHour, newMinute, newSecond, newNano);\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        requireNonNull(unit, \"unit\");\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    };\n    _proto.minusHours = function minusHours(hoursToSubtract) {\n        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));\n    };\n    _proto.minusMinutes = function minusMinutes(minutesToSubtract) {\n        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));\n    };\n    _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));\n    };\n    _proto.minusNanos = function minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        } else if (_query === TemporalQueries.localTime()) {\n            return this;\n        }\n        if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {\n            return null;\n        }\n        return _query.queryFrom(this);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());\n    };\n    _proto.until = function until(endExclusive, unit) {\n        requireNonNull(endExclusive, \"endExclusive\");\n        requireNonNull(unit, \"unit\");\n        var end = LocalTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();\n            switch(unit){\n                case ChronoUnit.NANOS:\n                    return nanosUntil;\n                case ChronoUnit.MICROS:\n                    return MathUtil.intDiv(nanosUntil, 1000);\n                case ChronoUnit.MILLIS:\n                    return MathUtil.intDiv(nanosUntil, 1000000);\n                case ChronoUnit.SECONDS:\n                    return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);\n                case ChronoUnit.MINUTES:\n                    return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);\n                case ChronoUnit.HOURS:\n                    return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS:\n                    return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    };\n    _proto.atDate = function atDate(date) {\n        return LocalDateTime.of(date, this);\n    };\n    _proto.atOffset = function atOffset(offset) {\n        return OffsetTime.of(this, offset);\n    };\n    _proto.toSecondOfDay = function toSecondOfDay() {\n        var total = this._hour * LocalTime.SECONDS_PER_HOUR;\n        total += this._minute * LocalTime.SECONDS_PER_MINUTE;\n        total += this._second;\n        return total;\n    };\n    _proto.toNanoOfDay = function toNanoOfDay() {\n        var total = this._hour * LocalTime.NANOS_PER_HOUR;\n        total += this._minute * LocalTime.NANOS_PER_MINUTE;\n        total += this._second * LocalTime.NANOS_PER_SECOND;\n        total += this._nano;\n        return total;\n    };\n    _proto.compareTo = function compareTo(other) {\n        requireNonNull(other, \"other\");\n        requireInstance(other, LocalTime, \"other\");\n        var cmp = MathUtil.compareNumbers(this._hour, other._hour);\n        if (cmp === 0) {\n            cmp = MathUtil.compareNumbers(this._minute, other._minute);\n            if (cmp === 0) {\n                cmp = MathUtil.compareNumbers(this._second, other._second);\n                if (cmp === 0) {\n                    cmp = MathUtil.compareNumbers(this._nano, other._nano);\n                }\n            }\n        }\n        return cmp;\n    };\n    _proto.isAfter = function isAfter(other) {\n        return this.compareTo(other) > 0;\n    };\n    _proto.isBefore = function isBefore(other) {\n        return this.compareTo(other) < 0;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof LocalTime) {\n            return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        var nod = this.toNanoOfDay();\n        return MathUtil.hash(nod);\n    };\n    _proto.toString = function toString() {\n        var buf = \"\";\n        var hourValue = this._hour;\n        var minuteValue = this._minute;\n        var secondValue = this._second;\n        var nanoValue = this._nano;\n        buf += hourValue < 10 ? \"0\" : \"\";\n        buf += hourValue;\n        buf += minuteValue < 10 ? \":0\" : \":\";\n        buf += minuteValue;\n        if (secondValue > 0 || nanoValue > 0) {\n            buf += secondValue < 10 ? \":0\" : \":\";\n            buf += secondValue;\n            if (nanoValue > 0) {\n                buf += \".\";\n                if (MathUtil.intMod(nanoValue, 1000000) === 0) {\n                    buf += (\"\" + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);\n                } else if (MathUtil.intMod(nanoValue, 1000) === 0) {\n                    buf += (\"\" + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);\n                } else {\n                    buf += (\"\" + (nanoValue + 1000000000)).substring(1);\n                }\n            }\n        }\n        return buf;\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    _proto.format = function format(formatter) {\n        requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    };\n    return LocalTime;\n}(Temporal);\nfunction _init$3() {\n    LocalTime.HOURS = [];\n    for(var hour = 0; hour < 24; hour++){\n        LocalTime.of(hour, 0, 0, 0);\n    }\n    LocalTime.MIN = LocalTime.HOURS[0];\n    LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);\n    LocalTime.MIDNIGHT = LocalTime.HOURS[0];\n    LocalTime.NOON = LocalTime.HOURS[12];\n    LocalTime.FROM = createTemporalQuery(\"LocalTime.FROM\", function(temporal) {\n        return LocalTime.from(temporal);\n    });\n}\nLocalTime.HOURS_PER_DAY = 24;\nLocalTime.MINUTES_PER_HOUR = 60;\nLocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.SECONDS_PER_MINUTE = 60;\nLocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;\nLocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;\nLocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;\nLocalTime.NANOS_PER_SECOND = 1000000000;\nLocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;\nLocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;\nLocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;\nvar NANOS_PER_MILLI = 1000000;\nvar Instant = function(_Temporal) {\n    _inheritsLoose(Instant, _Temporal);\n    Instant.now = function now(clock) {\n        if (clock === void 0) {\n            clock = Clock.systemUTC();\n        }\n        return clock.instant();\n    };\n    Instant.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {\n        if (nanoAdjustment === void 0) {\n            nanoAdjustment = 0;\n        }\n        var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);\n        return Instant._create(secs, nos);\n    };\n    Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {\n        var secs = MathUtil.floorDiv(epochMilli, 1000);\n        var mos = MathUtil.floorMod(epochMilli, 1000);\n        return Instant._create(secs, mos * 1000000);\n    };\n    Instant.ofEpochMicro = function ofEpochMicro(epochMicro) {\n        var secs = MathUtil.floorDiv(epochMicro, 1000000);\n        var mos = MathUtil.floorMod(epochMicro, 1000000);\n        return Instant._create(secs, mos * 1000);\n    };\n    Instant.from = function from(temporal) {\n        try {\n            var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);\n            var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);\n            return Instant.ofEpochSecond(instantSecs, nanoOfSecond);\n        } catch (ex) {\n            throw new DateTimeException(\"Unable to obtain Instant from TemporalAccessor: \" + temporal + \", type \" + typeof temporal, ex);\n        }\n    };\n    Instant.parse = function parse(text) {\n        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);\n    };\n    Instant._create = function _create(seconds, nanoOfSecond) {\n        if (seconds === 0 && nanoOfSecond === 0) {\n            return Instant.EPOCH;\n        }\n        return new Instant(seconds, nanoOfSecond);\n    };\n    Instant._validate = function _validate(seconds, nanoOfSecond) {\n        if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {\n            throw new DateTimeException(\"Instant exceeds minimum or maximum instant\");\n        }\n        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {\n            throw new DateTimeException(\"Instant exceeds minimum or maximum instant\");\n        }\n    };\n    function Instant(seconds, nanoOfSecond) {\n        var _this;\n        _this = _Temporal.call(this) || this;\n        Instant._validate(seconds, nanoOfSecond);\n        _this._seconds = MathUtil.safeToInt(seconds);\n        _this._nanos = MathUtil.safeToInt(nanoOfSecond);\n        return _this;\n    }\n    var _proto = Instant.prototype;\n    _proto.isSupported = function isSupported(fieldOrUnit) {\n        if (fieldOrUnit instanceof ChronoField) {\n            return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;\n        }\n        if (fieldOrUnit instanceof ChronoUnit) {\n            return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;\n        }\n        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);\n    };\n    _proto.range = function range(field) {\n        return _Temporal.prototype.range.call(this, field);\n    };\n    _proto.get = function get(field) {\n        return this.getLong(field);\n    };\n    _proto.getLong = function getLong(field) {\n        if (field instanceof ChronoField) {\n            switch(field){\n                case ChronoField.NANO_OF_SECOND:\n                    return this._nanos;\n                case ChronoField.MICRO_OF_SECOND:\n                    return MathUtil.intDiv(this._nanos, 1000);\n                case ChronoField.MILLI_OF_SECOND:\n                    return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n                case ChronoField.INSTANT_SECONDS:\n                    return this._seconds;\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.getFrom(this);\n    };\n    _proto.epochSecond = function epochSecond() {\n        return this._seconds;\n    };\n    _proto.nano = function nano() {\n        return this._nanos;\n    };\n    _proto._withField = function _withField(field, newValue) {\n        requireNonNull(field, \"field\");\n        if (field instanceof ChronoField) {\n            field.checkValidValue(newValue);\n            switch(field){\n                case ChronoField.MILLI_OF_SECOND:\n                    {\n                        var nval = newValue * NANOS_PER_MILLI;\n                        return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;\n                    }\n                case ChronoField.MICRO_OF_SECOND:\n                    {\n                        var _nval = newValue * 1000;\n                        return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;\n                    }\n                case ChronoField.NANO_OF_SECOND:\n                    return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;\n                case ChronoField.INSTANT_SECONDS:\n                    return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported field: \" + field);\n        }\n        return field.adjustInto(this, newValue);\n    };\n    _proto.truncatedTo = function truncatedTo(unit) {\n        requireNonNull(unit, \"unit\");\n        if (unit === ChronoUnit.NANOS) {\n            return this;\n        }\n        var unitDur = unit.duration();\n        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {\n            throw new DateTimeException(\"Unit is too large to be used for truncation\");\n        }\n        var dur = unitDur.toNanos();\n        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {\n            throw new DateTimeException(\"Unit must divide into a standard day without remainder\");\n        }\n        var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;\n        var result = MathUtil.intDiv(nod, dur) * dur;\n        return this.plusNanos(result - nod);\n    };\n    _proto._plusUnit = function _plusUnit(amountToAdd, unit) {\n        requireNonNull(amountToAdd, \"amountToAdd\");\n        requireNonNull(unit, \"unit\");\n        requireInstance(unit, TemporalUnit);\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.NANOS:\n                    return this.plusNanos(amountToAdd);\n                case ChronoUnit.MICROS:\n                    return this.plusMicros(amountToAdd);\n                case ChronoUnit.MILLIS:\n                    return this.plusMillis(amountToAdd);\n                case ChronoUnit.SECONDS:\n                    return this.plusSeconds(amountToAdd);\n                case ChronoUnit.MINUTES:\n                    return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));\n                case ChronoUnit.HOURS:\n                    return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));\n                case ChronoUnit.HALF_DAYS:\n                    return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));\n                case ChronoUnit.DAYS:\n                    return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.addTo(this, amountToAdd);\n    };\n    _proto.plusSeconds = function plusSeconds(secondsToAdd) {\n        return this._plus(secondsToAdd, 0);\n    };\n    _proto.plusMillis = function plusMillis(millisToAdd) {\n        return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);\n    };\n    _proto.plusNanos = function plusNanos(nanosToAdd) {\n        return this._plus(0, nanosToAdd);\n    };\n    _proto.plusMicros = function plusMicros(microsToAdd) {\n        return this._plus(MathUtil.intDiv(microsToAdd, 1000000), MathUtil.intMod(microsToAdd, 1000000) * 1000);\n    };\n    _proto._plus = function _plus(secondsToAdd, nanosToAdd) {\n        if (secondsToAdd === 0 && nanosToAdd === 0) {\n            return this;\n        }\n        var epochSec = this._seconds + secondsToAdd;\n        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);\n        var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;\n        return Instant.ofEpochSecond(epochSec, nanoAdjustment);\n    };\n    _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {\n        return this._plusUnit(-1 * amountToSubtract, unit);\n    };\n    _proto.minusSeconds = function minusSeconds(secondsToSubtract) {\n        return this.plusSeconds(secondsToSubtract * -1);\n    };\n    _proto.minusMillis = function minusMillis(millisToSubtract) {\n        return this.plusMillis(-1 * millisToSubtract);\n    };\n    _proto.minusNanos = function minusNanos(nanosToSubtract) {\n        return this.plusNanos(-1 * nanosToSubtract);\n    };\n    _proto.minusMicros = function minusMicros(microsToSubtract) {\n        return this.plusMicros(-1 * microsToSubtract);\n    };\n    _proto.query = function query(_query) {\n        requireNonNull(_query, \"query\");\n        if (_query === TemporalQueries.precision()) {\n            return ChronoUnit.NANOS;\n        }\n        if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {\n            return null;\n        }\n        return _query.queryFrom(this);\n    };\n    _proto.adjustInto = function adjustInto(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);\n    };\n    _proto.until = function until(endExclusive, unit) {\n        requireNonNull(endExclusive, \"endExclusive\");\n        requireNonNull(unit, \"unit\");\n        var end = Instant.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            switch(unit){\n                case ChronoUnit.NANOS:\n                    return this._nanosUntil(end);\n                case ChronoUnit.MICROS:\n                    return this._microsUntil(end);\n                case ChronoUnit.MILLIS:\n                    return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());\n                case ChronoUnit.SECONDS:\n                    return this._secondsUntil(end);\n                case ChronoUnit.MINUTES:\n                    return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);\n                case ChronoUnit.HOURS:\n                    return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);\n                case ChronoUnit.HALF_DAYS:\n                    return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);\n                case ChronoUnit.DAYS:\n                    return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);\n            }\n            throw new UnsupportedTemporalTypeException(\"Unsupported unit: \" + unit);\n        }\n        return unit.between(this, end);\n    };\n    _proto._microsUntil = function _microsUntil(end) {\n        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        var totalMicros = MathUtil.safeMultiply(secsDiff, 1000000);\n        return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1000));\n    };\n    _proto._nanosUntil = function _nanosUntil(end) {\n        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);\n        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());\n    };\n    _proto._secondsUntil = function _secondsUntil(end) {\n        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());\n        var nanosDiff = end.nano() - this.nano();\n        if (secsDiff > 0 && nanosDiff < 0) {\n            secsDiff--;\n        } else if (secsDiff < 0 && nanosDiff > 0) {\n            secsDiff++;\n        }\n        return secsDiff;\n    };\n    _proto.atOffset = function atOffset(offset) {\n        return OffsetDateTime.ofInstant(this, offset);\n    };\n    _proto.atZone = function atZone(zone) {\n        return ZonedDateTime.ofInstant(this, zone);\n    };\n    _proto.toEpochMilli = function toEpochMilli() {\n        var millis = MathUtil.safeMultiply(this._seconds, 1000);\n        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);\n    };\n    _proto.compareTo = function compareTo(otherInstant) {\n        requireNonNull(otherInstant, \"otherInstant\");\n        requireInstance(otherInstant, Instant, \"otherInstant\");\n        var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);\n        if (cmp !== 0) {\n            return cmp;\n        }\n        return this._nanos - otherInstant._nanos;\n    };\n    _proto.isAfter = function isAfter(otherInstant) {\n        return this.compareTo(otherInstant) > 0;\n    };\n    _proto.isBefore = function isBefore(otherInstant) {\n        return this.compareTo(otherInstant) < 0;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof Instant) {\n            return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return MathUtil.hashCode(this._seconds, this._nanos);\n    };\n    _proto.toString = function toString() {\n        return DateTimeFormatter.ISO_INSTANT.format(this);\n    };\n    _proto.toJSON = function toJSON() {\n        return this.toString();\n    };\n    return Instant;\n}(Temporal);\nfunction _init$2() {\n    Instant.MIN_SECONDS = -31619119219200;\n    Instant.MAX_SECONDS = 31494816403199;\n    Instant.EPOCH = new Instant(0, 0);\n    Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);\n    Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);\n    Instant.FROM = createTemporalQuery(\"Instant.FROM\", function(temporal) {\n        return Instant.from(temporal);\n    });\n}\nvar Clock = function() {\n    function Clock() {}\n    Clock.systemUTC = function systemUTC() {\n        return new SystemClock(ZoneOffset.UTC);\n    };\n    Clock.systemDefaultZone = function systemDefaultZone() {\n        return new SystemClock(ZoneId.systemDefault());\n    };\n    Clock.system = function system(zone) {\n        return new SystemClock(zone);\n    };\n    Clock.fixed = function fixed(fixedInstant, zoneId) {\n        return new FixedClock(fixedInstant, zoneId);\n    };\n    Clock.offset = function offset(baseClock, duration) {\n        return new OffsetClock(baseClock, duration);\n    };\n    var _proto = Clock.prototype;\n    _proto.millis = function millis() {\n        abstractMethodFail(\"Clock.millis\");\n    };\n    _proto.instant = function instant() {\n        abstractMethodFail(\"Clock.instant\");\n    };\n    _proto.zone = function zone() {\n        abstractMethodFail(\"Clock.zone\");\n    };\n    _proto.withZone = function withZone() {\n        abstractMethodFail(\"Clock.withZone\");\n    };\n    return Clock;\n}();\nvar SystemClock = function(_Clock) {\n    _inheritsLoose(SystemClock, _Clock);\n    function SystemClock(zone) {\n        var _this;\n        requireNonNull(zone, \"zone\");\n        _this = _Clock.call(this) || this;\n        _this._zone = zone;\n        return _this;\n    }\n    var _proto2 = SystemClock.prototype;\n    _proto2.zone = function zone() {\n        return this._zone;\n    };\n    _proto2.millis = function millis() {\n        return new Date().getTime();\n    };\n    _proto2.instant = function instant() {\n        return Instant.ofEpochMilli(this.millis());\n    };\n    _proto2.equals = function equals(obj) {\n        if (obj instanceof SystemClock) {\n            return this._zone.equals(obj._zone);\n        }\n        return false;\n    };\n    _proto2.withZone = function withZone(zone) {\n        if (zone.equals(this._zone)) {\n            return this;\n        }\n        return new SystemClock(zone);\n    };\n    _proto2.toString = function toString() {\n        return \"SystemClock[\" + this._zone.toString() + \"]\";\n    };\n    return SystemClock;\n}(Clock);\nvar FixedClock = function(_Clock2) {\n    _inheritsLoose(FixedClock, _Clock2);\n    function FixedClock(fixedInstant, zoneId) {\n        var _this2;\n        _this2 = _Clock2.call(this) || this;\n        _this2._instant = fixedInstant;\n        _this2._zoneId = zoneId;\n        return _this2;\n    }\n    var _proto3 = FixedClock.prototype;\n    _proto3.instant = function instant() {\n        return this._instant;\n    };\n    _proto3.millis = function millis() {\n        return this._instant.toEpochMilli();\n    };\n    _proto3.zone = function zone() {\n        return this._zoneId;\n    };\n    _proto3.toString = function toString() {\n        return \"FixedClock[]\";\n    };\n    _proto3.equals = function equals(obj) {\n        if (obj instanceof FixedClock) {\n            return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);\n        }\n        return false;\n    };\n    _proto3.withZone = function withZone(zone) {\n        if (zone.equals(this._zoneId)) {\n            return this;\n        }\n        return new FixedClock(this._instant, zone);\n    };\n    return FixedClock;\n}(Clock);\nvar OffsetClock = function(_Clock3) {\n    _inheritsLoose(OffsetClock, _Clock3);\n    function OffsetClock(baseClock, offset) {\n        var _this3;\n        _this3 = _Clock3.call(this) || this;\n        _this3._baseClock = baseClock;\n        _this3._offset = offset;\n        return _this3;\n    }\n    var _proto4 = OffsetClock.prototype;\n    _proto4.zone = function zone() {\n        return this._baseClock.zone();\n    };\n    _proto4.withZone = function withZone(zone) {\n        if (zone.equals(this._baseClock.zone())) {\n            return this;\n        }\n        return new OffsetClock(this._baseClock.withZone(zone), this._offset);\n    };\n    _proto4.millis = function millis() {\n        return this._baseClock.millis() + this._offset.toMillis();\n    };\n    _proto4.instant = function instant() {\n        return this._baseClock.instant().plus(this._offset);\n    };\n    _proto4.equals = function equals(obj) {\n        if (obj instanceof OffsetClock) {\n            return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);\n        }\n        return false;\n    };\n    _proto4.toString = function toString() {\n        return \"OffsetClock[\" + this._baseClock + \",\" + this._offset + \"]\";\n    };\n    return OffsetClock;\n}(Clock);\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ZoneOffsetTransition = function() {\n    ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {\n        return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);\n    };\n    function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {\n        requireNonNull(transition, \"transition\");\n        requireNonNull(offsetBefore, \"offsetBefore\");\n        requireNonNull(offsetAfter, \"offsetAfter\");\n        if (offsetBefore.equals(offsetAfter)) {\n            throw new IllegalArgumentException(\"Offsets must not be equal\");\n        }\n        if (transition.nano() !== 0) {\n            throw new IllegalArgumentException(\"Nano-of-second must be zero\");\n        }\n        if (transition instanceof LocalDateTime) {\n            this._transition = transition;\n        } else {\n            this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);\n        }\n        this._offsetBefore = offsetBefore;\n        this._offsetAfter = offsetAfter;\n    }\n    var _proto = ZoneOffsetTransition.prototype;\n    _proto.instant = function instant() {\n        return this._transition.toInstant(this._offsetBefore);\n    };\n    _proto.toEpochSecond = function toEpochSecond() {\n        return this._transition.toEpochSecond(this._offsetBefore);\n    };\n    _proto.dateTimeBefore = function dateTimeBefore() {\n        return this._transition;\n    };\n    _proto.dateTimeAfter = function dateTimeAfter() {\n        return this._transition.plusSeconds(this.durationSeconds());\n    };\n    _proto.offsetBefore = function offsetBefore() {\n        return this._offsetBefore;\n    };\n    _proto.offsetAfter = function offsetAfter() {\n        return this._offsetAfter;\n    };\n    _proto.duration = function duration() {\n        return Duration.ofSeconds(this.durationSeconds());\n    };\n    _proto.durationSeconds = function durationSeconds() {\n        return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();\n    };\n    _proto.isGap = function isGap() {\n        return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();\n    };\n    _proto.isOverlap = function isOverlap() {\n        return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();\n    };\n    _proto.isValidOffset = function isValidOffset(offset) {\n        return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);\n    };\n    _proto.validOffsets = function validOffsets() {\n        if (this.isGap()) {\n            return [];\n        } else {\n            return [\n                this._offsetBefore,\n                this._offsetAfter\n            ];\n        }\n    };\n    _proto.compareTo = function compareTo(transition) {\n        return this.instant().compareTo(transition.instant());\n    };\n    _proto.equals = function equals(other) {\n        if (other === this) {\n            return true;\n        }\n        if (other instanceof ZoneOffsetTransition) {\n            var d = other;\n            return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());\n        }\n        return false;\n    };\n    _proto.hashCode = function hashCode() {\n        return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;\n    };\n    _proto.toString = function toString() {\n        return \"Transition[\" + (this.isGap() ? \"Gap\" : \"Overlap\") + \" at \" + this._transition.toString() + this._offsetBefore.toString() + \" to \" + this._offsetAfter + \"]\";\n    };\n    return ZoneOffsetTransition;\n}();\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ function _init$1() {\n    TemporalQueries.ZONE_ID = createTemporalQuery(\"ZONE_ID\", function(temporal) {\n        return temporal.query(TemporalQueries.ZONE_ID);\n    });\n    TemporalQueries.CHRONO = createTemporalQuery(\"CHRONO\", function(temporal) {\n        return temporal.query(TemporalQueries.CHRONO);\n    });\n    TemporalQueries.PRECISION = createTemporalQuery(\"PRECISION\", function(temporal) {\n        return temporal.query(TemporalQueries.PRECISION);\n    });\n    TemporalQueries.OFFSET = createTemporalQuery(\"OFFSET\", function(temporal) {\n        if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {\n            return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));\n        }\n        return null;\n    });\n    TemporalQueries.ZONE = createTemporalQuery(\"ZONE\", function(temporal) {\n        var zone = temporal.query(TemporalQueries.ZONE_ID);\n        return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);\n    });\n    TemporalQueries.LOCAL_DATE = createTemporalQuery(\"LOCAL_DATE\", function(temporal) {\n        if (temporal.isSupported(ChronoField.EPOCH_DAY)) {\n            return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));\n        }\n        return null;\n    });\n    TemporalQueries.LOCAL_TIME = createTemporalQuery(\"LOCAL_TIME\", function(temporal) {\n        if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {\n            return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));\n        }\n        return null;\n    });\n}\nvar SystemDefaultZoneRules = function(_ZoneRules) {\n    _inheritsLoose(SystemDefaultZoneRules, _ZoneRules);\n    function SystemDefaultZoneRules() {\n        return _ZoneRules.apply(this, arguments) || this;\n    }\n    var _proto = SystemDefaultZoneRules.prototype;\n    _proto.isFixedOffset = function isFixedOffset() {\n        return false;\n    };\n    _proto.offsetOfInstant = function offsetOfInstant(instant) {\n        var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    };\n    _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {\n        var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);\n    };\n    _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {\n        var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;\n        var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();\n        var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;\n        var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();\n        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);\n    };\n    _proto.validOffsets = function validOffsets(localDateTime) {\n        return [\n            this.offsetOfLocalDateTime(localDateTime)\n        ];\n    };\n    _proto.transition = function transition() {\n        return null;\n    };\n    _proto.standardOffset = function standardOffset(instant) {\n        return this.offsetOfInstant(instant);\n    };\n    _proto.daylightSavings = function daylightSavings() {\n        this._throwNotSupported();\n    };\n    _proto.isDaylightSavings = function isDaylightSavings() {\n        this._throwNotSupported();\n    };\n    _proto.isValidOffset = function isValidOffset(dateTime, offset) {\n        return this.offsetOfLocalDateTime(dateTime).equals(offset);\n    };\n    _proto.nextTransition = function nextTransition() {\n        this._throwNotSupported();\n    };\n    _proto.previousTransition = function previousTransition() {\n        this._throwNotSupported();\n    };\n    _proto.transitions = function transitions() {\n        this._throwNotSupported();\n    };\n    _proto.transitionRules = function transitionRules() {\n        this._throwNotSupported();\n    };\n    _proto._throwNotSupported = function _throwNotSupported() {\n        throw new DateTimeException(\"not supported operation\");\n    };\n    _proto.equals = function equals(other) {\n        if (this === other || other instanceof SystemDefaultZoneRules) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    _proto.toString = function toString() {\n        return \"SYSTEM\";\n    };\n    return SystemDefaultZoneRules;\n}(ZoneRules);\nvar SystemDefaultZoneId = function(_ZoneId) {\n    _inheritsLoose(SystemDefaultZoneId, _ZoneId);\n    function SystemDefaultZoneId() {\n        var _this;\n        _this = _ZoneId.call(this) || this;\n        _this._rules = new SystemDefaultZoneRules();\n        return _this;\n    }\n    var _proto = SystemDefaultZoneId.prototype;\n    _proto.rules = function rules() {\n        return this._rules;\n    };\n    _proto.equals = function equals(other) {\n        if (this === other) {\n            return true;\n        }\n        return false;\n    };\n    _proto.id = function id() {\n        return \"SYSTEM\";\n    };\n    return SystemDefaultZoneId;\n}(ZoneId);\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ZoneIdFactory = function() {\n    function ZoneIdFactory() {}\n    ZoneIdFactory.systemDefault = function systemDefault() {\n        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    };\n    ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {\n        return ZoneRulesProvider.getAvailableZoneIds();\n    };\n    ZoneIdFactory.of = function of(zoneId) {\n        requireNonNull(zoneId, \"zoneId\");\n        if (zoneId === \"Z\") {\n            return ZoneOffset.UTC;\n        }\n        if (zoneId.length === 1) {\n            throw new DateTimeException(\"Invalid zone: \" + zoneId);\n        }\n        if (StringUtil.startsWith(zoneId, \"+\") || StringUtil.startsWith(zoneId, \"-\")) {\n            return ZoneOffset.of(zoneId);\n        }\n        if (zoneId === \"UTC\" || zoneId === \"GMT\" || zoneId === \"GMT0\" || zoneId === \"UT\") {\n            return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());\n        }\n        if (StringUtil.startsWith(zoneId, \"UTC+\") || StringUtil.startsWith(zoneId, \"GMT+\") || StringUtil.startsWith(zoneId, \"UTC-\") || StringUtil.startsWith(zoneId, \"GMT-\")) {\n            var offset = ZoneOffset.of(zoneId.substring(3));\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(zoneId.substring(0, 3), offset.rules());\n            }\n            return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());\n        }\n        if (StringUtil.startsWith(zoneId, \"UT+\") || StringUtil.startsWith(zoneId, \"UT-\")) {\n            var _offset = ZoneOffset.of(zoneId.substring(2));\n            if (_offset.totalSeconds() === 0) {\n                return new ZoneRegion(\"UT\", _offset.rules());\n            }\n            return new ZoneRegion(\"UT\" + _offset.id(), _offset.rules());\n        }\n        if (zoneId === \"SYSTEM\") {\n            return ZoneId.systemDefault();\n        }\n        return ZoneRegion.ofId(zoneId);\n    };\n    ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {\n        requireNonNull(prefix, \"prefix\");\n        requireNonNull(offset, \"offset\");\n        if (prefix.length === 0) {\n            return offset;\n        }\n        if (prefix === \"GMT\" || prefix === \"UTC\" || prefix === \"UT\") {\n            if (offset.totalSeconds() === 0) {\n                return new ZoneRegion(prefix, offset.rules());\n            }\n            return new ZoneRegion(prefix + offset.id(), offset.rules());\n        }\n        throw new IllegalArgumentException(\"Invalid prefix, must be GMT, UTC or UT: \" + prefix);\n    };\n    ZoneIdFactory.from = function from(temporal) {\n        requireNonNull(temporal, \"temporal\");\n        var obj = temporal.query(TemporalQueries.zone());\n        if (obj == null) {\n            throw new DateTimeException(\"Unable to obtain ZoneId from TemporalAccessor: \" + temporal + \", type \" + (temporal.constructor != null ? temporal.constructor.name : \"\"));\n        }\n        return obj;\n    };\n    return ZoneIdFactory;\n}();\nvar SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;\nfunction _init() {\n    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();\n    ZoneId.systemDefault = ZoneIdFactory.systemDefault;\n    ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;\n    ZoneId.of = ZoneIdFactory.of;\n    ZoneId.ofOffset = ZoneIdFactory.ofOffset;\n    ZoneId.from = ZoneIdFactory.from;\n    ZoneOffset.from = ZoneIdFactory.from;\n    ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;\n    ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);\n}\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var isInit = false;\nfunction init() {\n    if (isInit) {\n        return;\n    }\n    isInit = true;\n    _init$m();\n    _init$n();\n    _init$l();\n    _init$k();\n    _init$3();\n    _init$f();\n    _init$1();\n    _init$j();\n    _init$2();\n    _init$5();\n    _init$4();\n    _init$a();\n    _init$i();\n    _init$b();\n    _init$c();\n    _init$h();\n    _init$g();\n    _init$7();\n    _init();\n    _init$9();\n    _init$d();\n    _init$e();\n    _init$6();\n    _init$8();\n}\ninit();\n/*\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var ToNativeJsConverter = function() {\n    function ToNativeJsConverter(temporal, zone) {\n        var zonedDateTime;\n        if (temporal instanceof Instant) {\n            this.instant = temporal;\n            return;\n        } else if (temporal instanceof LocalDate) {\n            zone = zone == null ? ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atStartOfDay(zone);\n        } else if (temporal instanceof LocalDateTime) {\n            zone = zone == null ? ZoneId.systemDefault() : zone;\n            zonedDateTime = temporal.atZone(zone);\n        } else if (temporal instanceof ZonedDateTime) {\n            if (zone == null) {\n                zonedDateTime = temporal;\n            } else {\n                zonedDateTime = temporal.withZoneSameInstant(zone);\n            }\n        } else {\n            throw new IllegalArgumentException(\"unsupported instance for convert operation:\" + temporal);\n        }\n        this.instant = zonedDateTime.toInstant();\n    }\n    var _proto = ToNativeJsConverter.prototype;\n    _proto.toDate = function toDate() {\n        return new Date(this.instant.toEpochMilli());\n    };\n    _proto.toEpochMilli = function toEpochMilli() {\n        return this.instant.toEpochMilli();\n    };\n    return ToNativeJsConverter;\n}();\nfunction convert(temporal, zone) {\n    return new ToNativeJsConverter(temporal, zone);\n}\n/*\n * @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ function nativeJs(date, zone) {\n    if (zone === void 0) {\n        zone = ZoneId.systemDefault();\n    }\n    requireNonNull(date, \"date\");\n    requireNonNull(zone, \"zone\");\n    if (date instanceof Date) {\n        return Instant.ofEpochMilli(date.getTime()).atZone(zone);\n    } else if (typeof date.toDate === \"function\" && date.toDate() instanceof Date) {\n        return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);\n    }\n    throw new IllegalArgumentException(\"date must be a javascript Date or a moment instance\");\n}\nfunction bindUse(jsJoda) {\n    var used = [];\n    return function use(fn) {\n        if (!~used.indexOf(fn)) {\n            fn(jsJoda);\n            used.push(fn);\n        }\n        return jsJoda;\n    };\n}\n/**\n * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper\n * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)\n */ var _ = {\n    assert: assert$1,\n    DateTimeBuilder: DateTimeBuilder,\n    DateTimeParseContext: DateTimeParseContext,\n    DateTimePrintContext: DateTimePrintContext,\n    MathUtil: MathUtil,\n    StringUtil: StringUtil,\n    StringBuilder: StringBuilder\n};\nvar jsJodaExports = {\n    _: _,\n    convert: convert,\n    nativeJs: nativeJs,\n    ArithmeticException: ArithmeticException,\n    DateTimeException: DateTimeException,\n    DateTimeParseException: DateTimeParseException,\n    IllegalArgumentException: IllegalArgumentException,\n    IllegalStateException: IllegalStateException,\n    UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,\n    NullPointerException: NullPointerException,\n    Clock: Clock,\n    DayOfWeek: DayOfWeek,\n    Duration: Duration,\n    Instant: Instant,\n    LocalDate: LocalDate,\n    LocalTime: LocalTime,\n    LocalDateTime: LocalDateTime,\n    OffsetTime: OffsetTime,\n    OffsetDateTime: OffsetDateTime,\n    Month: Month,\n    MonthDay: MonthDay,\n    ParsePosition: ParsePosition,\n    Period: Period,\n    Year: Year,\n    YearConstants: YearConstants,\n    YearMonth: YearMonth,\n    ZonedDateTime: ZonedDateTime,\n    ZoneOffset: ZoneOffset,\n    ZoneId: ZoneId,\n    ZoneRegion: ZoneRegion,\n    ZoneOffsetTransition: ZoneOffsetTransition,\n    ZoneRules: ZoneRules,\n    ZoneRulesProvider: ZoneRulesProvider,\n    ChronoLocalDate: ChronoLocalDate,\n    ChronoLocalDateTime: ChronoLocalDateTime,\n    ChronoZonedDateTime: ChronoZonedDateTime,\n    IsoChronology: IsoChronology,\n    ChronoField: ChronoField,\n    ChronoUnit: ChronoUnit,\n    IsoFields: IsoFields,\n    Temporal: Temporal,\n    TemporalAccessor: TemporalAccessor,\n    TemporalAdjuster: TemporalAdjuster,\n    TemporalAdjusters: TemporalAdjusters,\n    TemporalAmount: TemporalAmount,\n    TemporalField: TemporalField,\n    TemporalQueries: TemporalQueries,\n    TemporalQuery: TemporalQuery,\n    TemporalUnit: TemporalUnit,\n    ValueRange: ValueRange,\n    DateTimeFormatter: DateTimeFormatter,\n    DateTimeFormatterBuilder: DateTimeFormatterBuilder,\n    DecimalStyle: DecimalStyle,\n    ResolverStyle: ResolverStyle,\n    SignStyle: SignStyle,\n    TextStyle: TextStyle\n};\nvar use = bindUse(jsJodaExports);\njsJodaExports.use = use;\n //# sourceMappingURL=js-joda.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGpzLWpvZGEvY29yZS9kaXN0L2pzLWpvZGEuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtDQUFrQztBQUNsQywyRkFBMkY7QUFDM0YsK0VBQStFO0FBQy9FLGlGQUFpRjtBQUVqRjs7O0NBR0MsR0FFRCxTQUFTQSxnQkFBZ0JDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxlQUFlO0lBQ2xELElBQUlBLG9CQUFvQixLQUFLLEdBQUc7UUFDOUJBLGtCQUFrQkM7SUFDcEI7SUFDQSxTQUFTQyxnQkFBZ0JDLE9BQU87UUFDOUIsSUFBSSxDQUFDRixNQUFNRyxpQkFBaUIsRUFBRTtZQUM1QixJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJSixRQUFRSSxLQUFLO1FBQ2hDLE9BQU87WUFDTEosTUFBTUcsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ0UsV0FBVztRQUNoRDtRQUNBLElBQUksQ0FBQ0gsT0FBTyxHQUFHQTtRQUNmSixRQUFRQSxLQUFLUSxLQUFLLENBQUMsSUFBSSxFQUFFQztRQUN6QixJQUFJLENBQUNDLFFBQVEsR0FBRztZQUNkLE9BQU8sSUFBSSxDQUFDWCxJQUFJLEdBQUcsT0FBTyxJQUFJLENBQUNLLE9BQU87UUFDeEM7SUFDRjtJQUNBRCxnQkFBZ0JRLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDWixnQkFBZ0JVLFNBQVM7SUFDbkVSLGdCQUFnQlEsU0FBUyxDQUFDWixJQUFJLEdBQUdBO0lBQ2pDSSxnQkFBZ0JRLFNBQVMsQ0FBQ0osV0FBVyxHQUFHSjtJQUN4QyxPQUFPQTtBQUNUO0FBQ0EsSUFBSVcsb0JBQW9CaEIsZ0JBQWdCLHFCQUFxQmlCO0FBQzdELElBQUlDLHlCQUF5QmxCLGdCQUFnQiwwQkFBMEJtQjtBQUN2RSxJQUFJQyxtQ0FBbUNwQixnQkFBZ0Isb0NBQW9DLE1BQU1nQjtBQUNq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cm9zb2RpZnktYmFja2VuZC8uL25vZGVfbW9kdWxlcy9AanMtam9kYS9jb3JlL2Rpc3QvanMtam9kYS5lc20uanM/ZDVkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgQHZlcnNpb24gQGpzLWpvZGEvY29yZSAtIDUuNi41XG4vLyEgQGNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIsIFBhdHRyaWNrIEjDvHBlciAmIGpzLWpvZGEgY29udHJpYnV0b3JzXG4vLyEgQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4vLyEgQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKG5hbWUsIGluaXQsIHN1cGVyRXJyb3JDbGFzcykge1xuICBpZiAoc3VwZXJFcnJvckNsYXNzID09PSB2b2lkIDApIHtcbiAgICBzdXBlckVycm9yQ2xhc3MgPSBFcnJvcjtcbiAgfVxuICBmdW5jdGlvbiBKc0pvZGFFeGNlcHRpb24obWVzc2FnZSkge1xuICAgIGlmICghRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgaW5pdCAmJiBpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcbiAgfVxuICBKc0pvZGFFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckVycm9yQ2xhc3MucHJvdG90eXBlKTtcbiAgSnNKb2RhRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gbmFtZTtcbiAgSnNKb2RhRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpzSm9kYUV4Y2VwdGlvbjtcbiAgcmV0dXJuIEpzSm9kYUV4Y2VwdGlvbjtcbn1cbnZhciBEYXRlVGltZUV4Y2VwdGlvbiA9IGNyZWF0ZUVycm9yVHlwZSgnRGF0ZVRpbWVFeGNlcHRpb24nLCBtZXNzYWdlV2l0aENhdXNlKTtcbnZhciBEYXRlVGltZVBhcnNlRXhjZXB0aW9uID0gY3JlYXRlRXJyb3JUeXBlKCdEYXRlVGltZVBhcnNlRXhjZXB0aW9uJywgbWVzc2FnZUZvckRhdGVUaW1lUGFyc2VFeGNlcHRpb24pO1xudmFyIFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uID0gY3JlYXRlRXJyb3JUeXBlKCdVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbicsIG51bGwsIERhdGVUaW1lRXhjZXB0aW9uKTtcbnZhciBBcml0aG1ldGljRXhjZXB0aW9uID0gY3JlYXRlRXJyb3JUeXBlKCdBcml0aG1ldGljRXhjZXB0aW9uJyk7XG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gY3JlYXRlRXJyb3JUeXBlKCdJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24nKTtcbnZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb24gPSBjcmVhdGVFcnJvclR5cGUoJ0lsbGVnYWxTdGF0ZUV4Y2VwdGlvbicpO1xudmFyIE51bGxQb2ludGVyRXhjZXB0aW9uID0gY3JlYXRlRXJyb3JUeXBlKCdOdWxsUG9pbnRlckV4Y2VwdGlvbicpO1xuZnVuY3Rpb24gbWVzc2FnZVdpdGhDYXVzZShtZXNzYWdlLCBjYXVzZSkge1xuICBpZiAoY2F1c2UgPT09IHZvaWQgMCkge1xuICAgIGNhdXNlID0gbnVsbDtcbiAgfVxuICB2YXIgbXNnID0gbWVzc2FnZSB8fCB0aGlzLm5hbWU7XG4gIGlmIChjYXVzZSAhPT0gbnVsbCAmJiBjYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgbXNnICs9IFwiXFxuLS0tLS0tLVxcbkNhdXNlZCBieTogXCIgKyBjYXVzZS5zdGFjayArIFwiXFxuLS0tLS0tLVxcblwiO1xuICB9XG4gIHRoaXMubWVzc2FnZSA9IG1zZztcbn1cbmZ1bmN0aW9uIG1lc3NhZ2VGb3JEYXRlVGltZVBhcnNlRXhjZXB0aW9uKG1lc3NhZ2UsIHRleHQsIGluZGV4LCBjYXVzZSkge1xuICBpZiAodGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgdGV4dCA9ICcnO1xuICB9XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG4gIGlmIChjYXVzZSA9PT0gdm9pZCAwKSB7XG4gICAgY2F1c2UgPSBudWxsO1xuICB9XG4gIHZhciBtc2cgPSBtZXNzYWdlIHx8IHRoaXMubmFtZTtcbiAgbXNnICs9IFwiOiBcIiArIHRleHQgKyBcIiwgYXQgaW5kZXg6IFwiICsgaW5kZXg7XG4gIGlmIChjYXVzZSAhPT0gbnVsbCAmJiBjYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgbXNnICs9IFwiXFxuLS0tLS0tLVxcbkNhdXNlZCBieTogXCIgKyBjYXVzZS5zdGFjayArIFwiXFxuLS0tLS0tLVxcblwiO1xuICB9XG4gIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgdGhpcy5wYXJzZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG4gIHRoaXMuZXJyb3JJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGFzc2VydGlvbiwgbXNnLCBlcnJvcikge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IGVycm9yKG1zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU5vbk51bGwodmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb24ocGFyYW1ldGVyTmFtZSArIFwiIG11c3Qgbm90IGJlIG51bGxcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcmVxdWlyZUluc3RhbmNlKHZhbHVlLCBfY2xhc3MsIHBhcmFtZXRlck5hbWUpIHtcbiAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBfY2xhc3MpKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihwYXJhbWV0ZXJOYW1lICsgXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBcIiArIChfY2xhc3MubmFtZSA/IF9jbGFzcy5uYW1lIDogX2NsYXNzKSArICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID8gXCIsIGJ1dCBpcyBcIiArIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFic3RyYWN0TWV0aG9kRmFpbChtZXRob2ROYW1lKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhYnN0cmFjdCBtZXRob2QgXFxcIlwiICsgbWV0aG9kTmFtZSArIFwiXFxcIiBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbnZhciBhc3NlcnQkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYWJzdHJhY3RNZXRob2RGYWlsOiBhYnN0cmFjdE1ldGhvZEZhaWwsXG4gICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgcmVxdWlyZUluc3RhbmNlOiByZXF1aXJlSW5zdGFuY2UsXG4gICAgcmVxdWlyZU5vbk51bGw6IHJlcXVpcmVOb25OdWxsXG59KTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIE1JTl9TQUZFX0lOVEVHRVIgPSAtOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNYXRoVXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWF0aFV0aWwoKSB7fVxuICBNYXRoVXRpbC5pbnREaXYgPSBmdW5jdGlvbiBpbnREaXYoeCwgeSkge1xuICAgIHZhciByID0geCAvIHk7XG4gICAgciA9IE1hdGhVdGlsLnJvdW5kRG93bihyKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8ocik7XG4gIH07XG4gIE1hdGhVdGlsLmludE1vZCA9IGZ1bmN0aW9uIGludE1vZCh4LCB5KSB7XG4gICAgdmFyIHIgPSB4IC0gTWF0aFV0aWwuaW50RGl2KHgsIHkpICogeTtcbiAgICByID0gTWF0aFV0aWwucm91bmREb3duKHIpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyhyKTtcbiAgfTtcbiAgTWF0aFV0aWwucm91bmREb3duID0gZnVuY3Rpb24gcm91bmREb3duKHIpIHtcbiAgICBpZiAociA8IDApIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwocik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHIpO1xuICAgIH1cbiAgfTtcbiAgTWF0aFV0aWwuZmxvb3JEaXYgPSBmdW5jdGlvbiBmbG9vckRpdih4LCB5KSB7XG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKHggLyB5KTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8ocik7XG4gIH07XG4gIE1hdGhVdGlsLmZsb29yTW9kID0gZnVuY3Rpb24gZmxvb3JNb2QoeCwgeSkge1xuICAgIHZhciByID0geCAtIE1hdGhVdGlsLmZsb29yRGl2KHgsIHkpICogeTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8ocik7XG4gIH07XG4gIE1hdGhVdGlsLnNhZmVBZGQgPSBmdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgICBNYXRoVXRpbC52ZXJpZnlJbnQoeCk7XG4gICAgTWF0aFV0aWwudmVyaWZ5SW50KHkpO1xuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeSk7XG4gICAgfVxuICAgIGlmICh5ID09PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeCk7XG4gICAgfVxuICAgIHZhciByID0gTWF0aFV0aWwuc2FmZVRvSW50KHggKyB5KTtcbiAgICBpZiAociA9PT0geCB8fCByID09PSB5KSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignSW52YWxpZCBhZGRpdGlvbiBiZXlvbmQgTUFYX1NBRkVfSU5URUdFUiEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIE1hdGhVdGlsLnNhZmVTdWJ0cmFjdCA9IGZ1bmN0aW9uIHNhZmVTdWJ0cmFjdCh4LCB5KSB7XG4gICAgTWF0aFV0aWwudmVyaWZ5SW50KHgpO1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh5KTtcbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybygtMSAqIHkpO1xuICAgIH0gZWxzZSBpZiAoeSA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVaZXJvKHgpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVRvSW50KHggLSB5KTtcbiAgfTtcbiAgTWF0aFV0aWwuc2FmZU11bHRpcGx5ID0gZnVuY3Rpb24gc2FmZU11bHRpcGx5KHgsIHkpIHtcbiAgICBNYXRoVXRpbC52ZXJpZnlJbnQoeCk7XG4gICAgTWF0aFV0aWwudmVyaWZ5SW50KHkpO1xuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeSk7XG4gICAgfVxuICAgIGlmICh5ID09PSAxKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeCk7XG4gICAgfVxuICAgIGlmICh4ID09PSAwIHx8IHkgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgciA9IE1hdGhVdGlsLnNhZmVUb0ludCh4ICogeSk7XG4gICAgaWYgKHIgLyB5ICE9PSB4IHx8IHggPT09IE1JTl9TQUZFX0lOVEVHRVIgJiYgeSA9PT0gLTEgfHwgeSA9PT0gTUlOX1NBRkVfSU5URUdFUiAmJiB4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oXCJNdWx0aXBsaWNhdGlvbiBvdmVyZmxvd3M6IFwiICsgeCArIFwiICogXCIgKyB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIE1hdGhVdGlsLnBhcnNlSW50ID0gZnVuY3Rpb24gKF9wYXJzZUludCkge1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KF94KSB7XG4gICAgICByZXR1cm4gX3BhcnNlSW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHBhcnNlSW50LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9wYXJzZUludC50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlSW50O1xuICB9KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlVG9JbnQocik7XG4gIH0pO1xuICBNYXRoVXRpbC5zYWZlVG9JbnQgPSBmdW5jdGlvbiBzYWZlVG9JbnQodmFsdWUpIHtcbiAgICBNYXRoVXRpbC52ZXJpZnlJbnQodmFsdWUpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyh2YWx1ZSk7XG4gIH07XG4gIE1hdGhVdGlsLnZlcmlmeUludCA9IGZ1bmN0aW9uIHZlcmlmeUludCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbihcIkludmFsaWQgdmFsdWU6ICdcIiArIHZhbHVlICsgXCInLCB1c2luZyBudWxsIG9yIHVuZGVmaW5lZCBhcyBhcmd1bWVudFwiKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oJ0ludmFsaWQgaW50IHZhbHVlLCB1c2luZyBOYU4gYXMgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIpIHtcbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbihcIkludmFsaWQgdmFsdWU6ICdcIiArIHZhbHVlICsgXCInIGlzIGEgZmxvYXRcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAlIDEgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKFwiSW52YWxpZCB2YWx1ZTogJ1wiICsgdmFsdWUgKyBcIicgaXMgYSBmbG9hdFwiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKFwiQ2FsY3VsYXRpb24gb3ZlcmZsb3dzIGFuIGludDogXCIgKyB2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBNYXRoVXRpbC5zYWZlWmVybyA9IGZ1bmN0aW9uIHNhZmVaZXJvKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gMCA6ICt2YWx1ZTtcbiAgfTtcbiAgTWF0aFV0aWwuY29tcGFyZU51bWJlcnMgPSBmdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhID4gYikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICBNYXRoVXRpbC5zbWkgPSBmdW5jdGlvbiBzbWkoaW50KSB7XG4gICAgcmV0dXJuIGludCA+Pj4gMSAmIDB4NDAwMDAwMDAgfCBpbnQgJiAweEJGRkZGRkZGO1xuICB9O1xuICBNYXRoVXRpbC5oYXNoID0gZnVuY3Rpb24gaGFzaChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBudW1iZXI7XG4gICAgd2hpbGUgKG51bWJlciA+IDB4RkZGRkZGRkYpIHtcbiAgICAgIG51bWJlciAvPSAweEZGRkZGRkZGO1xuICAgICAgcmVzdWx0IF49IG51bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNtaShyZXN1bHQpO1xuICB9O1xuICBNYXRoVXRpbC5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHZhciByZXN1bHQgPSAxNztcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbnVtYmVycyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG51bWJlcnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgX251bWJlcnMgPSBudW1iZXJzOyBfaSA8IF9udW1iZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG4gPSBfbnVtYmVyc1tfaV07XG4gICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDUpIC0gcmVzdWx0ICsgTWF0aFV0aWwuaGFzaChuKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2gocmVzdWx0KTtcbiAgfTtcbiAgcmV0dXJuIE1hdGhVdGlsO1xufSgpO1xuTWF0aFV0aWwuTUFYX1NBRkVfSU5URUdFUiA9IE1BWF9TQUZFX0lOVEVHRVI7XG5NYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSID0gTUlOX1NBRkVfSU5URUdFUjtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi92YXIgRW51bSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW51bShuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cbiAgdmFyIF9wcm90byA9IEVudW0ucHJvdG90eXBlO1xuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IG90aGVyO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICByZXR1cm4gRW51bTtcbn0oKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBUZW1wb3JhbEFtb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVtcG9yYWxBbW91bnQoKSB7fVxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxBbW91bnQucHJvdG90eXBlO1xuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KHVuaXQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2dldCcpO1xuICB9O1xuICBfcHJvdG8udW5pdHMgPSBmdW5jdGlvbiB1bml0cygpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3VuaXRzJyk7XG4gIH07XG4gIF9wcm90by5hZGRUbyA9IGZ1bmN0aW9uIGFkZFRvKHRlbXBvcmFsKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdhZGRUbycpO1xuICB9O1xuICBfcHJvdG8uc3VidHJhY3RGcm9tID0gZnVuY3Rpb24gc3VidHJhY3RGcm9tKHRlbXBvcmFsKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdzdWJ0cmFjdEZyb20nKTtcbiAgfTtcbiAgcmV0dXJuIFRlbXBvcmFsQW1vdW50O1xufSgpO1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSkge1xuICBUZW1wb3JhbEFtb3VudC5wcm90b3R5cGVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9IGZ1bmN0aW9uIChoaW50KSB7XG4gICAgaWYgKGhpbnQgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGNvbnZlcnNpb24gZnJvbSBUZW1wb3JhbEFtb3VudCB0byBhIG51bWJlciBpcyBub3QgYWxsb3dlZC4gJyArICdUbyBjb21wYXJlIHVzZSB0aGUgbWV0aG9kcyAuZXF1YWxzKCksIC5jb21wYXJlVG8oKSwgLmlzQmVmb3JlKCkgJyArICdvciBvbmUgdGhhdCBpcyBtb3JlIHN1aXRhYmxlIHRvIHlvdXIgdXNlIGNhc2UuJyk7XG4gIH07XG59XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG52YXIgVGVtcG9yYWxVbml0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbFVuaXQoKSB7fVxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxVbml0LnByb3RvdHlwZTtcbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdkdXJhdGlvbicpO1xuICB9O1xuICBfcHJvdG8uaXNEdXJhdGlvbkVzdGltYXRlZCA9IGZ1bmN0aW9uIGlzRHVyYXRpb25Fc3RpbWF0ZWQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc0R1cmF0aW9uRXN0aW1hdGVkJyk7XG4gIH07XG4gIF9wcm90by5pc0RhdGVCYXNlZCA9IGZ1bmN0aW9uIGlzRGF0ZUJhc2VkKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNEYXRlQmFzZWQnKTtcbiAgfTtcbiAgX3Byb3RvLmlzVGltZUJhc2VkID0gZnVuY3Rpb24gaXNUaW1lQmFzZWQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc1RpbWVCYXNlZCcpO1xuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2lzU3VwcG9ydGVkQnknKTtcbiAgfTtcbiAgX3Byb3RvLmFkZFRvID0gZnVuY3Rpb24gYWRkVG8oZGF0ZVRpbWUsIHBlcmlvZFRvQWRkKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdhZGRUbycpO1xuICB9O1xuICBfcHJvdG8uYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4odGVtcG9yYWwxLCB0ZW1wb3JhbDIpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2JldHdlZW4nKTtcbiAgfTtcbiAgcmV0dXJuIFRlbXBvcmFsVW5pdDtcbn0oKTtcblxudmFyIER1cmF0aW9uID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFtb3VudCkge1xuICBfaW5oZXJpdHNMb29zZShEdXJhdGlvbiwgX1RlbXBvcmFsQW1vdW50KTtcbiAgZnVuY3Rpb24gRHVyYXRpb24oc2Vjb25kcywgbmFub3MpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBbW91bnQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9zZWNvbmRzID0gTWF0aFV0aWwuc2FmZVRvSW50KHNlY29uZHMpO1xuICAgIF90aGlzLl9uYW5vcyA9IE1hdGhVdGlsLnNhZmVUb0ludChuYW5vcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIER1cmF0aW9uLm9mRGF5cyA9IGZ1bmN0aW9uIG9mRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGRheXMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpLCAwKTtcbiAgfTtcbiAgRHVyYXRpb24ub2ZIb3VycyA9IGZ1bmN0aW9uIG9mSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShNYXRoVXRpbC5zYWZlTXVsdGlwbHkoaG91cnMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKSwgMCk7XG4gIH07XG4gIER1cmF0aW9uLm9mTWludXRlcyA9IGZ1bmN0aW9uIG9mTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoTWF0aFV0aWwuc2FmZU11bHRpcGx5KG1pbnV0ZXMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCAwKTtcbiAgfTtcbiAgRHVyYXRpb24ub2ZTZWNvbmRzID0gZnVuY3Rpb24gb2ZTZWNvbmRzKHNlY29uZHMsIG5hbm9BZGp1c3RtZW50KSB7XG4gICAgaWYgKG5hbm9BZGp1c3RtZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9BZGp1c3RtZW50ID0gMDtcbiAgICB9XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5zYWZlQWRkKHNlY29uZHMsIE1hdGhVdGlsLmZsb29yRGl2KG5hbm9BZGp1c3RtZW50LCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCkpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5mbG9vck1vZChuYW5vQWRqdXN0bWVudCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHJldHVybiBEdXJhdGlvbi5fY3JlYXRlKHNlY3MsIG5vcyk7XG4gIH07XG4gIER1cmF0aW9uLm9mTWlsbGlzID0gZnVuY3Rpb24gb2ZNaWxsaXMobWlsbGlzKSB7XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5pbnREaXYobWlsbGlzLCAxMDAwKTtcbiAgICB2YXIgbW9zID0gTWF0aFV0aWwuaW50TW9kKG1pbGxpcywgMTAwMCk7XG4gICAgaWYgKG1vcyA8IDApIHtcbiAgICAgIG1vcyArPSAxMDAwO1xuICAgICAgc2Vjcy0tO1xuICAgIH1cbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShzZWNzLCBtb3MgKiAxMDAwMDAwKTtcbiAgfTtcbiAgRHVyYXRpb24ub2ZOYW5vcyA9IGZ1bmN0aW9uIG9mTmFub3MobmFub3MpIHtcbiAgICB2YXIgc2VjcyA9IE1hdGhVdGlsLmludERpdihuYW5vcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5pbnRNb2QobmFub3MsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICBpZiAobm9zIDwgMCkge1xuICAgICAgbm9zICs9IExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EO1xuICAgICAgc2Vjcy0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlKHNlY3MsIG5vcyk7XG4gIH07XG4gIER1cmF0aW9uLm9mID0gZnVuY3Rpb24gb2YoYW1vdW50LCB1bml0KSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLlpFUk8ucGx1cyhhbW91bnQsIHVuaXQpO1xuICB9O1xuICBEdXJhdGlvbi5mcm9tID0gZnVuY3Rpb24gZnJvbShhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoYW1vdW50LCBUZW1wb3JhbEFtb3VudCk7XG4gICAgdmFyIGR1cmF0aW9uID0gRHVyYXRpb24uWkVSTztcbiAgICBhbW91bnQudW5pdHMoKS5mb3JFYWNoKGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uLnBsdXMoYW1vdW50LmdldCh1bml0KSwgdW5pdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGR1cmF0aW9uO1xuICB9O1xuICBEdXJhdGlvbi5iZXR3ZWVuID0gZnVuY3Rpb24gYmV0d2VlbihzdGFydEluY2x1c2l2ZSwgZW5kRXhjbHVzaXZlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoc3RhcnRJbmNsdXNpdmUsICdzdGFydEluY2x1c2l2ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZEV4Y2x1c2l2ZSwgJ2VuZEV4Y2x1c2l2ZScpO1xuICAgIHZhciBzZWNzID0gc3RhcnRJbmNsdXNpdmUudW50aWwoZW5kRXhjbHVzaXZlLCBDaHJvbm9Vbml0LlNFQ09ORFMpO1xuICAgIHZhciBuYW5vcyA9IDA7XG4gICAgaWYgKHN0YXJ0SW5jbHVzaXZlLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKSAmJiBlbmRFeGNsdXNpdmUuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RhcnROb3MgPSBzdGFydEluY2x1c2l2ZS5nZXRMb25nKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICAgICAgbmFub3MgPSBlbmRFeGNsdXNpdmUuZ2V0TG9uZyhDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCkgLSBzdGFydE5vcztcbiAgICAgICAgaWYgKHNlY3MgPiAwICYmIG5hbm9zIDwgMCkge1xuICAgICAgICAgIG5hbm9zICs9IExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EO1xuICAgICAgICB9IGVsc2UgaWYgKHNlY3MgPCAwICYmIG5hbm9zID4gMCkge1xuICAgICAgICAgIG5hbm9zIC09IExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EO1xuICAgICAgICB9IGVsc2UgaWYgKHNlY3MgPT09IDAgJiYgbmFub3MgIT09IDApIHtcbiAgICAgICAgICB2YXIgYWRqdXN0ZWRFbmQgPSBlbmRFeGNsdXNpdmUud2l0aChDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCwgc3RhcnROb3MpO1xuICAgICAgICAgIHNlY3MgPSBzdGFydEluY2x1c2l2ZS51bnRpbChhZGp1c3RlZEVuZCwgQ2hyb25vVW5pdC5TRUNPTkRTKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub2ZTZWNvbmRzKHNlY3MsIG5hbm9zKTtcbiAgfTtcbiAgRHVyYXRpb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICB2YXIgUEFUVEVSTiA9IG5ldyBSZWdFeHAoJyhbLStdPylQKD86KFstK10/WzAtOV0rKUQpPyhUKD86KFstK10/WzAtOV0rKUgpPyg/OihbLStdP1swLTldKylNKT8oPzooWy0rXT9bMC05XSspKD86Wy4sXShbMC05XXswLDl9KSk/Uyk/KT8nLCAnaScpO1xuICAgIHZhciBtYXRjaGVzID0gUEFUVEVSTi5leGVjKHRleHQpO1xuICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICBpZiAoJ1QnID09PSBtYXRjaGVzWzNdID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgbmVnYXRlID0gJy0nID09PSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgZGF5TWF0Y2ggPSBtYXRjaGVzWzJdO1xuICAgICAgICB2YXIgaG91ck1hdGNoID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgdmFyIG1pbnV0ZU1hdGNoID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgdmFyIHNlY29uZE1hdGNoID0gbWF0Y2hlc1s2XTtcbiAgICAgICAgdmFyIGZyYWN0aW9uTWF0Y2ggPSBtYXRjaGVzWzddO1xuICAgICAgICBpZiAoZGF5TWF0Y2ggIT0gbnVsbCB8fCBob3VyTWF0Y2ggIT0gbnVsbCB8fCBtaW51dGVNYXRjaCAhPSBudWxsIHx8IHNlY29uZE1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZGF5c0FzU2VjcyA9IER1cmF0aW9uLl9wYXJzZU51bWJlcih0ZXh0LCBkYXlNYXRjaCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSwgJ2RheXMnKTtcbiAgICAgICAgICB2YXIgaG91cnNBc1NlY3MgPSBEdXJhdGlvbi5fcGFyc2VOdW1iZXIodGV4dCwgaG91ck1hdGNoLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiwgJ2hvdXJzJyk7XG4gICAgICAgICAgdmFyIG1pbnNBc1NlY3MgPSBEdXJhdGlvbi5fcGFyc2VOdW1iZXIodGV4dCwgbWludXRlTWF0Y2gsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUsICdtaW51dGVzJyk7XG4gICAgICAgICAgdmFyIHNlY29uZHMgPSBEdXJhdGlvbi5fcGFyc2VOdW1iZXIodGV4dCwgc2Vjb25kTWF0Y2gsIDEsICdzZWNvbmRzJyk7XG4gICAgICAgICAgdmFyIG5lZ2F0aXZlU2VjcyA9IHNlY29uZE1hdGNoICE9IG51bGwgJiYgc2Vjb25kTWF0Y2guY2hhckF0KDApID09PSAnLSc7XG4gICAgICAgICAgdmFyIG5hbm9zID0gRHVyYXRpb24uX3BhcnNlRnJhY3Rpb24odGV4dCwgZnJhY3Rpb25NYXRjaCwgbmVnYXRpdmVTZWNzID8gLTEgOiAxKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUobmVnYXRlLCBkYXlzQXNTZWNzLCBob3Vyc0FzU2VjcywgbWluc0FzU2Vjcywgc2Vjb25kcywgbmFub3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbignVGV4dCBjYW5ub3QgYmUgcGFyc2VkIHRvIGEgRHVyYXRpb246IG92ZXJmbG93JywgdGV4dCwgMCwgZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbignVGV4dCBjYW5ub3QgYmUgcGFyc2VkIHRvIGEgRHVyYXRpb24nLCB0ZXh0LCAwKTtcbiAgfTtcbiAgRHVyYXRpb24uX3BhcnNlTnVtYmVyID0gZnVuY3Rpb24gX3BhcnNlTnVtYmVyKHRleHQsIHBhcnNlZCwgbXVsdGlwbGllciwgZXJyb3JUZXh0KSB7XG4gICAgaWYgKHBhcnNlZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXJzZWRbMF0gPT09ICcrJykge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZWQuc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVNdWx0aXBseShwYXJzZUZsb2F0KHBhcnNlZCksIG11bHRpcGxpZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbihcIlRleHQgY2Fubm90IGJlIHBhcnNlZCB0byBhIER1cmF0aW9uOiBcIiArIGVycm9yVGV4dCwgdGV4dCwgMCwgZXgpO1xuICAgIH1cbiAgfTtcbiAgRHVyYXRpb24uX3BhcnNlRnJhY3Rpb24gPSBmdW5jdGlvbiBfcGFyc2VGcmFjdGlvbih0ZXh0LCBwYXJzZWQsIG5lZ2F0ZSkge1xuICAgIGlmIChwYXJzZWQgPT0gbnVsbCB8fCBwYXJzZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcGFyc2VkID0gKHBhcnNlZCArIFwiMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCA5KTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJzZWQpICogbmVnYXRlO1xuICB9O1xuICBEdXJhdGlvbi5fY3JlYXRlID0gZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZVNlY29uZHNOYW5vcyhhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5fY3JlYXRlTmVnYXRlRGF5c0hvdXJzTWludXRlc1NlY29uZHNOYW5vcyhhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKTtcbiAgICB9XG4gIH07XG4gIER1cmF0aW9uLl9jcmVhdGVOZWdhdGVEYXlzSG91cnNNaW51dGVzU2Vjb25kc05hbm9zID0gZnVuY3Rpb24gX2NyZWF0ZU5lZ2F0ZURheXNIb3Vyc01pbnV0ZXNTZWNvbmRzTmFub3MobmVnYXRlLCBkYXlzQXNTZWNzLCBob3Vyc0FzU2VjcywgbWluc0FzU2Vjcywgc2VjcywgbmFub3MpIHtcbiAgICB2YXIgc2Vjb25kcyA9IE1hdGhVdGlsLnNhZmVBZGQoZGF5c0FzU2VjcywgTWF0aFV0aWwuc2FmZUFkZChob3Vyc0FzU2VjcywgTWF0aFV0aWwuc2FmZUFkZChtaW5zQXNTZWNzLCBzZWNzKSkpO1xuICAgIGlmIChuZWdhdGUpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5vZlNlY29uZHMoc2Vjb25kcywgbmFub3MpLm5lZ2F0ZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNvbmRzLCBuYW5vcyk7XG4gIH07XG4gIER1cmF0aW9uLl9jcmVhdGVTZWNvbmRzTmFub3MgPSBmdW5jdGlvbiBfY3JlYXRlU2Vjb25kc05hbm9zKHNlY29uZHMsIG5hbm9BZGp1c3RtZW50KSB7XG4gICAgaWYgKHNlY29uZHMgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kcyA9IDA7XG4gICAgfVxuICAgIGlmIChuYW5vQWRqdXN0bWVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vQWRqdXN0bWVudCA9IDA7XG4gICAgfVxuICAgIGlmIChzZWNvbmRzID09PSAwICYmIG5hbm9BZGp1c3RtZW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uWkVSTztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbihzZWNvbmRzLCBuYW5vQWRqdXN0bWVudCk7XG4gIH07XG4gIHZhciBfcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQodW5pdCkge1xuICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LlNFQ09ORFMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWNvbmRzO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5OQU5PUykge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnVuaXRzID0gZnVuY3Rpb24gdW5pdHMoKSB7XG4gICAgcmV0dXJuIFtDaHJvbm9Vbml0LlNFQ09ORFMsIENocm9ub1VuaXQuTkFOT1NdO1xuICB9O1xuICBfcHJvdG8uaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWNvbmRzID09PSAwICYmIHRoaXMuX25hbm9zID09PSAwO1xuICB9O1xuICBfcHJvdG8uaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY29uZHMgPCAwO1xuICB9O1xuICBfcHJvdG8uc2Vjb25kcyA9IGZ1bmN0aW9uIHNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY29uZHM7XG4gIH07XG4gIF9wcm90by5uYW5vID0gZnVuY3Rpb24gbmFubygpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFub3M7XG4gIH07XG4gIF9wcm90by53aXRoU2Vjb25kcyA9IGZ1bmN0aW9uIHdpdGhTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShzZWNvbmRzLCB0aGlzLl9uYW5vcyk7XG4gIH07XG4gIF9wcm90by53aXRoTmFub3MgPSBmdW5jdGlvbiB3aXRoTmFub3MobmFub09mU2Vjb25kKSB7XG4gICAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZEludFZhbHVlKG5hbm9PZlNlY29uZCk7XG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUodGhpcy5fc2Vjb25kcywgbmFub09mU2Vjb25kKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNEdXJhdGlvbiA9IGZ1bmN0aW9uIHBsdXNEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIHJlcXVpcmVOb25OdWxsKGR1cmF0aW9uLCAnZHVyYXRpb24nKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1cmF0aW9uLnNlY29uZHMoKSwgZHVyYXRpb24ubmFubygpKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGR1cmF0aW9uT3JOdW1iZXIsIHVuaXRPck51bWJlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVzRHVyYXRpb24oZHVyYXRpb25Pck51bWJlcik7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHVuaXRPck51bWJlciBpbnN0YW5jZW9mIFRlbXBvcmFsVW5pdCkge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c0Ftb3VudFVuaXQoZHVyYXRpb25Pck51bWJlciwgdW5pdE9yTnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhkdXJhdGlvbk9yTnVtYmVyLCB1bml0T3JOdW1iZXIpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnBsdXNBbW91bnRVbml0ID0gZnVuY3Rpb24gcGx1c0Ftb3VudFVuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnRUb0FkZCwgJ2Ftb3VudFRvQWRkJyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5EQVlTKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSksIDApO1xuICAgIH1cbiAgICBpZiAodW5pdC5pc0R1cmF0aW9uRXN0aW1hdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5pdCBtdXN0IG5vdCBoYXZlIGFuIGVzdGltYXRlZCBkdXJhdGlvbicpO1xuICAgIH1cbiAgICBpZiAoYW1vdW50VG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTkFOT1M6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgMTAwMDAwMCAqIDEwMDApICogMTAwMCwgTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCAxMDAwMDAwICogMTAwMCkgKiAxMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExJUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTWlsbGlzKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoYW1vdW50VG9BZGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkodW5pdC5kdXJhdGlvbigpLnNlY29uZHMoKSwgYW1vdW50VG9BZGQpLCAwKTtcbiAgICB9XG4gICAgdmFyIGR1cmF0aW9uID0gdW5pdC5kdXJhdGlvbigpLm11bHRpcGxpZWRCeShhbW91bnRUb0FkZCk7XG4gICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhkdXJhdGlvbi5zZWNvbmRzKCksIGR1cmF0aW9uLm5hbm8oKSk7XG4gIH07XG4gIF9wcm90by5wbHVzRGF5cyA9IGZ1bmN0aW9uIHBsdXNEYXlzKGRheXNUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzTmFub3MoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGRheXNUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSksIDApO1xuICB9O1xuICBfcHJvdG8ucGx1c0hvdXJzID0gZnVuY3Rpb24gcGx1c0hvdXJzKGhvdXJzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLnNhZmVNdWx0aXBseShob3Vyc1RvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiksIDApO1xuICB9O1xuICBfcHJvdG8ucGx1c01pbnV0ZXMgPSBmdW5jdGlvbiBwbHVzTWludXRlcyhtaW51dGVzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLnNhZmVNdWx0aXBseShtaW51dGVzVG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCAwKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNTZWNvbmRzID0gZnVuY3Rpb24gcGx1c1NlY29uZHMoc2Vjb25kc1RvQWRkKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhzZWNvbmRzVG9BZGQsIDApO1xuICB9O1xuICBfcHJvdG8ucGx1c01pbGxpcyA9IGZ1bmN0aW9uIHBsdXNNaWxsaXMobWlsbGlzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLmludERpdihtaWxsaXNUb0FkZCwgMTAwMCksIE1hdGhVdGlsLmludE1vZChtaWxsaXNUb0FkZCwgMTAwMCkgKiAxMDAwMDAwKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNOYW5vcyA9IGZ1bmN0aW9uIHBsdXNOYW5vcyhuYW5vc1RvQWRkKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcygwLCBuYW5vc1RvQWRkKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNTZWNvbmRzTmFub3MgPSBmdW5jdGlvbiBwbHVzU2Vjb25kc05hbm9zKHNlY29uZHNUb0FkZCwgbmFub3NUb0FkZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHNlY29uZHNUb0FkZCwgJ3NlY29uZHNUb0FkZCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKG5hbm9zVG9BZGQsICduYW5vc1RvQWRkJyk7XG4gICAgaWYgKHNlY29uZHNUb0FkZCA9PT0gMCAmJiBuYW5vc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGVwb2NoU2VjID0gTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl9zZWNvbmRzLCBzZWNvbmRzVG9BZGQpO1xuICAgIGVwb2NoU2VjID0gTWF0aFV0aWwuc2FmZUFkZChlcG9jaFNlYywgTWF0aFV0aWwuaW50RGl2KG5hbm9zVG9BZGQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKSk7XG4gICAgbmFub3NUb0FkZCA9IE1hdGhVdGlsLmludE1vZChuYW5vc1RvQWRkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgdmFyIG5hbm9BZGp1c3RtZW50ID0gTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl9uYW5vcywgbmFub3NUb0FkZCk7XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhlcG9jaFNlYywgbmFub0FkanVzdG1lbnQpO1xuICB9O1xuICBfcHJvdG8ubWludXMgPSBmdW5jdGlvbiBtaW51cyhkdXJhdGlvbk9yTnVtYmVyLCB1bml0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1pbnVzRHVyYXRpb24oZHVyYXRpb25Pck51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm1pbnVzQW1vdW50VW5pdChkdXJhdGlvbk9yTnVtYmVyLCB1bml0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5taW51c0R1cmF0aW9uID0gZnVuY3Rpb24gbWludXNEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIHJlcXVpcmVOb25OdWxsKGR1cmF0aW9uLCAnZHVyYXRpb24nKTtcbiAgICB2YXIgc2Vjc1RvU3VidHJhY3QgPSBkdXJhdGlvbi5zZWNvbmRzKCk7XG4gICAgdmFyIG5hbm9zVG9TdWJ0cmFjdCA9IGR1cmF0aW9uLm5hbm8oKTtcbiAgICBpZiAoc2Vjc1RvU3VidHJhY3QgPT09IE1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdXMoTUFYX1NBRkVfSU5URUdFUiwgLW5hbm9zVG9TdWJ0cmFjdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBsdXMoLXNlY3NUb1N1YnRyYWN0LCAtbmFub3NUb1N1YnRyYWN0KTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzQW1vdW50VW5pdCA9IGZ1bmN0aW9uIG1pbnVzQW1vdW50VW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9TdWJ0cmFjdCwgJ2Ftb3VudFRvU3VidHJhY3QnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJldHVybiBhbW91bnRUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzQW1vdW50VW5pdChNQVhfU0FGRV9JTlRFR0VSLCB1bml0KSA6IHRoaXMucGx1c0Ftb3VudFVuaXQoLWFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIGRheXNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzRGF5cyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c0RheXMoLWRheXNUb1N1YnRyYWN0KTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzSG91cnMgPSBmdW5jdGlvbiBtaW51c0hvdXJzKGhvdXJzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiBob3Vyc1RvU3VidHJhY3QgPT09IE1JTl9TQUZFX0lOVEVHRVIgPyB0aGlzLnBsdXNIb3VycyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c0hvdXJzKC1ob3Vyc1RvU3VidHJhY3QpO1xuICB9O1xuICBfcHJvdG8ubWludXNNaW51dGVzID0gZnVuY3Rpb24gbWludXNNaW51dGVzKG1pbnV0ZXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIG1pbnV0ZXNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTWludXRlcyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c01pbnV0ZXMoLW1pbnV0ZXNUb1N1YnRyYWN0KTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiBzZWNvbmRzVG9TdWJ0cmFjdCA9PT0gTUlOX1NBRkVfSU5URUdFUiA/IHRoaXMucGx1c1NlY29uZHMoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNTZWNvbmRzKC1zZWNvbmRzVG9TdWJ0cmFjdCk7XG4gIH07XG4gIF9wcm90by5taW51c01pbGxpcyA9IGZ1bmN0aW9uIG1pbnVzTWlsbGlzKG1pbGxpc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gbWlsbGlzVG9TdWJ0cmFjdCA9PT0gTUlOX1NBRkVfSU5URUdFUiA/IHRoaXMucGx1c01pbGxpcyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c01pbGxpcygtbWlsbGlzVG9TdWJ0cmFjdCk7XG4gIH07XG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gbmFub3NUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTmFub3MoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNOYW5vcygtbmFub3NUb1N1YnRyYWN0KTtcbiAgfTtcbiAgX3Byb3RvLm11bHRpcGxpZWRCeSA9IGZ1bmN0aW9uIG11bHRpcGxpZWRCeShtdWx0aXBsaWNhbmQpIHtcbiAgICBpZiAobXVsdGlwbGljYW5kID09PSAwKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uWkVSTztcbiAgICB9XG4gICAgaWYgKG11bHRpcGxpY2FuZCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX3NlY29uZHMsIG11bHRpcGxpY2FuZCk7XG4gICAgdmFyIG5vcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl9uYW5vcywgbXVsdGlwbGljYW5kKTtcbiAgICBzZWNzID0gc2VjcyArIE1hdGhVdGlsLmludERpdihub3MsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICBub3MgPSBNYXRoVXRpbC5pbnRNb2Qobm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNzLCBub3MpO1xuICB9O1xuICBfcHJvdG8uZGl2aWRlZEJ5ID0gZnVuY3Rpb24gZGl2aWRlZEJ5KGRpdmlzb3IpIHtcbiAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpO1xuICAgIH1cbiAgICBpZiAoZGl2aXNvciA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIGRpdmlzb3IpO1xuICAgIHZhciBzZWNzTW9kID0gTWF0aFV0aWwucm91bmREb3duKCh0aGlzLl9zZWNvbmRzIC8gZGl2aXNvciAtIHNlY3MpICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFub3MsIGRpdmlzb3IpO1xuICAgIG5vcyA9IHNlY3NNb2QgKyBub3M7XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNzLCBub3MpO1xuICB9O1xuICBfcHJvdG8ubmVnYXRlZCA9IGZ1bmN0aW9uIG5lZ2F0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGllZEJ5KC0xKTtcbiAgfTtcbiAgX3Byb3RvLmFicyA9IGZ1bmN0aW9uIGFicygpIHtcbiAgICByZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCkgPyB0aGlzLm5lZ2F0ZWQoKSA6IHRoaXM7XG4gIH07XG4gIF9wcm90by5hZGRUbyA9IGZ1bmN0aW9uIGFkZFRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIGlmICh0aGlzLl9zZWNvbmRzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5fc2Vjb25kcywgQ2hyb25vVW5pdC5TRUNPTkRTKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX25hbm9zICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5fbmFub3MsIENocm9ub1VuaXQuTkFOT1MpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcG9yYWw7XG4gIH07XG4gIF9wcm90by5zdWJ0cmFjdEZyb20gPSBmdW5jdGlvbiBzdWJ0cmFjdEZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgaWYgKHRoaXMuX3NlY29uZHMgIT09IDApIHtcbiAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwubWludXModGhpcy5fc2Vjb25kcywgQ2hyb25vVW5pdC5TRUNPTkRTKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX25hbm9zICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX25hbm9zLCBDaHJvbm9Vbml0Lk5BTk9TKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBvcmFsO1xuICB9O1xuICBfcHJvdG8udG9EYXlzID0gZnVuY3Rpb24gdG9EYXlzKCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSk7XG4gIH07XG4gIF9wcm90by50b0hvdXJzID0gZnVuY3Rpb24gdG9Ib3VycygpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKTtcbiAgfTtcbiAgX3Byb3RvLnRvTWludXRlcyA9IGZ1bmN0aW9uIHRvTWludXRlcygpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpO1xuICB9O1xuICBfcHJvdG8udG9NaWxsaXMgPSBmdW5jdGlvbiB0b01pbGxpcygpIHtcbiAgICB2YXIgbWlsbGlzID0gTWF0aC5yb3VuZChNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5fc2Vjb25kcywgMTAwMCkpO1xuICAgIG1pbGxpcyA9IE1hdGhVdGlsLnNhZmVBZGQobWlsbGlzLCBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFub3MsIDEwMDAwMDApKTtcbiAgICByZXR1cm4gbWlsbGlzO1xuICB9O1xuICBfcHJvdG8udG9OYW5vcyA9IGZ1bmN0aW9uIHRvTmFub3MoKSB7XG4gICAgdmFyIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlQWRkKHRvdGFsTmFub3MsIHRoaXMuX25hbm9zKTtcbiAgICByZXR1cm4gdG90YWxOYW5vcztcbiAgfTtcbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlckR1cmF0aW9uKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXJEdXJhdGlvbiwgJ290aGVyRHVyYXRpb24nKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXJEdXJhdGlvbiwgRHVyYXRpb24sICdvdGhlckR1cmF0aW9uJyk7XG4gICAgdmFyIGNtcCA9IE1hdGhVdGlsLmNvbXBhcmVOdW1iZXJzKHRoaXMuX3NlY29uZHMsIG90aGVyRHVyYXRpb24uc2Vjb25kcygpKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbmFub3MgLSBvdGhlckR1cmF0aW9uLm5hbm8oKTtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlckR1cmF0aW9uKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyRHVyYXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob3RoZXJEdXJhdGlvbiBpbnN0YW5jZW9mIER1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWNvbmRzKCkgPT09IG90aGVyRHVyYXRpb24uc2Vjb25kcygpICYmIHRoaXMubmFubygpID09PSBvdGhlckR1cmF0aW9uLm5hbm8oKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcyA9PT0gRHVyYXRpb24uWkVSTykge1xuICAgICAgcmV0dXJuICdQVDBTJztcbiAgICB9XG4gICAgdmFyIGhvdXJzID0gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKTtcbiAgICB2YXIgbWludXRlcyA9IE1hdGhVdGlsLmludERpdihNYXRoVXRpbC5pbnRNb2QodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICB2YXIgc2VjcyA9IE1hdGhVdGlsLmludE1vZCh0aGlzLl9zZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICB2YXIgcnZhbCA9ICdQVCc7XG4gICAgaWYgKGhvdXJzICE9PSAwKSB7XG4gICAgICBydmFsICs9IGhvdXJzICsgXCJIXCI7XG4gICAgfVxuICAgIGlmIChtaW51dGVzICE9PSAwKSB7XG4gICAgICBydmFsICs9IG1pbnV0ZXMgKyBcIk1cIjtcbiAgICB9XG4gICAgaWYgKHNlY3MgPT09IDAgJiYgdGhpcy5fbmFub3MgPT09IDAgJiYgcnZhbC5sZW5ndGggPiAyKSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gICAgaWYgKHNlY3MgPCAwICYmIHRoaXMuX25hbm9zID4gMCkge1xuICAgICAgaWYgKHNlY3MgPT09IC0xKSB7XG4gICAgICAgIHJ2YWwgKz0gJy0wJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgKz0gc2VjcyArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgKz0gc2VjcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX25hbm9zID4gMCkge1xuICAgICAgcnZhbCArPSAnLic7XG4gICAgICB2YXIgbmFub1N0cmluZztcbiAgICAgIGlmIChzZWNzIDwgMCkge1xuICAgICAgICBuYW5vU3RyaW5nID0gXCJcIiArICgyICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQgLSB0aGlzLl9uYW5vcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW5vU3RyaW5nID0gXCJcIiArIChMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCArIHRoaXMuX25hbm9zKTtcbiAgICAgIH1cbiAgICAgIG5hbm9TdHJpbmcgPSBuYW5vU3RyaW5nLnNsaWNlKDEsIG5hbm9TdHJpbmcubGVuZ3RoKTtcbiAgICAgIHJ2YWwgKz0gbmFub1N0cmluZztcbiAgICAgIHdoaWxlIChydmFsLmNoYXJBdChydmFsLmxlbmd0aCAtIDEpID09PSAnMCcpIHtcbiAgICAgICAgcnZhbCA9IHJ2YWwuc2xpY2UoMCwgcnZhbC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbCArPSAnUyc7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgcmV0dXJuIER1cmF0aW9uO1xufShUZW1wb3JhbEFtb3VudCk7XG5mdW5jdGlvbiBfaW5pdCRuKCkge1xuICBEdXJhdGlvbi5aRVJPID0gbmV3IER1cmF0aW9uKDAsIDApO1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFLm1kIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovdmFyIFllYXJDb25zdGFudHMgPSBmdW5jdGlvbiBZZWFyQ29uc3RhbnRzKCkge307XG5mdW5jdGlvbiBfaW5pdCRtKCkge1xuICBZZWFyQ29uc3RhbnRzLk1JTl9WQUxVRSA9IC05OTk5OTk7XG4gIFllYXJDb25zdGFudHMuTUFYX1ZBTFVFID0gOTk5OTk5O1xufVxuXG52YXIgQ2hyb25vVW5pdCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxVbml0KSB7XG4gIF9pbmhlcml0c0xvb3NlKENocm9ub1VuaXQsIF9UZW1wb3JhbFVuaXQpO1xuICBmdW5jdGlvbiBDaHJvbm9Vbml0KG5hbWUsIGVzdGltYXRlZER1cmF0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX1RlbXBvcmFsVW5pdC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX25hbWUgPSBuYW1lO1xuICAgIF90aGlzLl9kdXJhdGlvbiA9IGVzdGltYXRlZER1cmF0aW9uO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gQ2hyb25vVW5pdC5wcm90b3R5cGU7XG4gIF9wcm90by5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgfTtcbiAgX3Byb3RvLmlzRHVyYXRpb25Fc3RpbWF0ZWQgPSBmdW5jdGlvbiBpc0R1cmF0aW9uRXN0aW1hdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGF0ZUJhc2VkKCkgfHwgdGhpcyA9PT0gQ2hyb25vVW5pdC5GT1JFVkVSO1xuICB9O1xuICBfcHJvdG8uaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8oQ2hyb25vVW5pdC5EQVlTKSA+PSAwICYmIHRoaXMgIT09IENocm9ub1VuaXQuRk9SRVZFUjtcbiAgfTtcbiAgX3Byb3RvLmlzVGltZUJhc2VkID0gZnVuY3Rpb24gaXNUaW1lQmFzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKENocm9ub1VuaXQuREFZUykgPCAwO1xuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICBpZiAodGhpcyA9PT0gQ2hyb25vVW5pdC5GT1JFVkVSKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0ZW1wb3JhbC5wbHVzKDEsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVtcG9yYWwucGx1cygtMSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmFkZFRvID0gZnVuY3Rpb24gYWRkVG8odGVtcG9yYWwsIGFtb3VudCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5wbHVzKGFtb3VudCwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5iZXR3ZWVuID0gZnVuY3Rpb24gYmV0d2Vlbih0ZW1wb3JhbDEsIHRlbXBvcmFsMikge1xuICAgIHJldHVybiB0ZW1wb3JhbDEudW50aWwodGVtcG9yYWwyLCB0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kdXJhdGlvbigpLmNvbXBhcmVUbyhvdGhlci5kdXJhdGlvbigpKTtcbiAgfTtcbiAgcmV0dXJuIENocm9ub1VuaXQ7XG59KFRlbXBvcmFsVW5pdCk7XG5mdW5jdGlvbiBfaW5pdCRsKCkge1xuICBDaHJvbm9Vbml0Lk5BTk9TID0gbmV3IENocm9ub1VuaXQoJ05hbm9zJywgRHVyYXRpb24ub2ZOYW5vcygxKSk7XG4gIENocm9ub1VuaXQuTUlDUk9TID0gbmV3IENocm9ub1VuaXQoJ01pY3JvcycsIER1cmF0aW9uLm9mTmFub3MoMTAwMCkpO1xuICBDaHJvbm9Vbml0Lk1JTExJUyA9IG5ldyBDaHJvbm9Vbml0KCdNaWxsaXMnLCBEdXJhdGlvbi5vZk5hbm9zKDEwMDAwMDApKTtcbiAgQ2hyb25vVW5pdC5TRUNPTkRTID0gbmV3IENocm9ub1VuaXQoJ1NlY29uZHMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMSkpO1xuICBDaHJvbm9Vbml0Lk1JTlVURVMgPSBuZXcgQ2hyb25vVW5pdCgnTWludXRlcycsIER1cmF0aW9uLm9mU2Vjb25kcyg2MCkpO1xuICBDaHJvbm9Vbml0LkhPVVJTID0gbmV3IENocm9ub1VuaXQoJ0hvdXJzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDM2MDApKTtcbiAgQ2hyb25vVW5pdC5IQUxGX0RBWVMgPSBuZXcgQ2hyb25vVW5pdCgnSGFsZkRheXMnLCBEdXJhdGlvbi5vZlNlY29uZHMoNDMyMDApKTtcbiAgQ2hyb25vVW5pdC5EQVlTID0gbmV3IENocm9ub1VuaXQoJ0RheXMnLCBEdXJhdGlvbi5vZlNlY29uZHMoODY0MDApKTtcbiAgQ2hyb25vVW5pdC5XRUVLUyA9IG5ldyBDaHJvbm9Vbml0KCdXZWVrcycsIER1cmF0aW9uLm9mU2Vjb25kcyg3ICogODY0MDApKTtcbiAgQ2hyb25vVW5pdC5NT05USFMgPSBuZXcgQ2hyb25vVW5pdCgnTW9udGhzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyIC8gMTIpKTtcbiAgQ2hyb25vVW5pdC5ZRUFSUyA9IG5ldyBDaHJvbm9Vbml0KCdZZWFycycsIER1cmF0aW9uLm9mU2Vjb25kcygzMTU1Njk1MikpO1xuICBDaHJvbm9Vbml0LkRFQ0FERVMgPSBuZXcgQ2hyb25vVW5pdCgnRGVjYWRlcycsIER1cmF0aW9uLm9mU2Vjb25kcygzMTU1Njk1MiAqIDEwKSk7XG4gIENocm9ub1VuaXQuQ0VOVFVSSUVTID0gbmV3IENocm9ub1VuaXQoJ0NlbnR1cmllcycsIER1cmF0aW9uLm9mU2Vjb25kcygzMTU1Njk1MiAqIDEwMCkpO1xuICBDaHJvbm9Vbml0Lk1JTExFTk5JQSA9IG5ldyBDaHJvbm9Vbml0KCdNaWxsZW5uaWEnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIgKiAxMDAwKSk7XG4gIENocm9ub1VuaXQuRVJBUyA9IG5ldyBDaHJvbm9Vbml0KCdFcmFzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyICogKFllYXJDb25zdGFudHMuTUFYX1ZBTFVFICsgMSkpKTtcbiAgQ2hyb25vVW5pdC5GT1JFVkVSID0gbmV3IENocm9ub1VuaXQoJ0ZvcmV2ZXInLCBEdXJhdGlvbi5vZlNlY29uZHMoTWF0aFV0aWwuTUFYX1NBRkVfSU5URUdFUiwgOTk5OTk5OTk5KSk7XG59XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEZpZWxkKCkge31cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsRmllbGQucHJvdG90eXBlO1xuICBfcHJvdG8uaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2lzRGF0ZUJhc2VkJyk7XG4gIH07XG4gIF9wcm90by5pc1RpbWVCYXNlZCA9IGZ1bmN0aW9uIGlzVGltZUJhc2VkKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNUaW1lQmFzZWQnKTtcbiAgfTtcbiAgX3Byb3RvLmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdiYXNlVW5pdCcpO1xuICB9O1xuICBfcHJvdG8ucmFuZ2VVbml0ID0gZnVuY3Rpb24gcmFuZ2VVbml0KCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgncmFuZ2VVbml0Jyk7XG4gIH07XG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgncmFuZ2UnKTtcbiAgfTtcbiAgX3Byb3RvLnJhbmdlUmVmaW5lZEJ5ID0gZnVuY3Rpb24gcmFuZ2VSZWZpbmVkQnkodGVtcG9yYWwpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3JhbmdlUmVmaW5lZEJ5Jyk7XG4gIH07XG4gIF9wcm90by5nZXRGcm9tID0gZnVuY3Rpb24gZ2V0RnJvbSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnZ2V0RnJvbScpO1xuICB9O1xuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdhZGp1c3RJbnRvJyk7XG4gIH07XG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNTdXBwb3J0ZWRCeScpO1xuICB9O1xuICBfcHJvdG8uZGlzcGxheU5hbWUgPSBmdW5jdGlvbiBkaXNwbGF5TmFtZSgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2Rpc3BsYXlOYW1lJyk7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2VxdWFscycpO1xuICB9O1xuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCduYW1lJyk7XG4gIH07XG4gIHJldHVybiBUZW1wb3JhbEZpZWxkO1xufSgpO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBWYWx1ZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWYWx1ZVJhbmdlKG1pblNtYWxsZXN0LCBtaW5MYXJnZXN0LCBtYXhTbWFsbGVzdCwgbWF4TGFyZ2VzdCkge1xuICAgIGFzc2VydCghKG1pblNtYWxsZXN0ID4gbWluTGFyZ2VzdCksIFwiU21hbGxlc3QgbWluaW11bSB2YWx1ZSAnXCIgKyBtaW5TbWFsbGVzdCArIFwiJyBtdXN0IGJlIGxlc3MgdGhhbiBsYXJnZXN0IG1pbmltdW0gdmFsdWUgJ1wiICsgbWluTGFyZ2VzdCArIFwiJ1wiLCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24pO1xuICAgIGFzc2VydCghKG1heFNtYWxsZXN0ID4gbWF4TGFyZ2VzdCksIFwiU21hbGxlc3QgbWF4aW11bSB2YWx1ZSAnXCIgKyBtYXhTbWFsbGVzdCArIFwiJyBtdXN0IGJlIGxlc3MgdGhhbiBsYXJnZXN0IG1heGltdW0gdmFsdWUgJ1wiICsgbWF4TGFyZ2VzdCArIFwiJ1wiLCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24pO1xuICAgIGFzc2VydCghKG1pbkxhcmdlc3QgPiBtYXhMYXJnZXN0KSwgXCJNaW5pbXVtIHZhbHVlICdcIiArIG1pbkxhcmdlc3QgKyBcIicgbXVzdCBiZSBsZXNzIHRoYW4gbWF4aW11bSB2YWx1ZSAnXCIgKyBtYXhMYXJnZXN0ICsgXCInXCIsIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbik7XG4gICAgdGhpcy5fbWluU21hbGxlc3QgPSBtaW5TbWFsbGVzdDtcbiAgICB0aGlzLl9taW5MYXJnZXN0ID0gbWluTGFyZ2VzdDtcbiAgICB0aGlzLl9tYXhMYXJnZXN0ID0gbWF4TGFyZ2VzdDtcbiAgICB0aGlzLl9tYXhTbWFsbGVzdCA9IG1heFNtYWxsZXN0O1xuICB9XG4gIHZhciBfcHJvdG8gPSBWYWx1ZVJhbmdlLnByb3RvdHlwZTtcbiAgX3Byb3RvLmlzRml4ZWQgPSBmdW5jdGlvbiBpc0ZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5TbWFsbGVzdCA9PT0gdGhpcy5fbWluTGFyZ2VzdCAmJiB0aGlzLl9tYXhTbWFsbGVzdCA9PT0gdGhpcy5fbWF4TGFyZ2VzdDtcbiAgfTtcbiAgX3Byb3RvLm1pbmltdW0gPSBmdW5jdGlvbiBtaW5pbXVtKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5TbWFsbGVzdDtcbiAgfTtcbiAgX3Byb3RvLmxhcmdlc3RNaW5pbXVtID0gZnVuY3Rpb24gbGFyZ2VzdE1pbmltdW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbkxhcmdlc3Q7XG4gIH07XG4gIF9wcm90by5tYXhpbXVtID0gZnVuY3Rpb24gbWF4aW11bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGFyZ2VzdDtcbiAgfTtcbiAgX3Byb3RvLnNtYWxsZXN0TWF4aW11bSA9IGZ1bmN0aW9uIHNtYWxsZXN0TWF4aW11bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4U21hbGxlc3Q7XG4gIH07XG4gIF9wcm90by5pc1ZhbGlkVmFsdWUgPSBmdW5jdGlvbiBpc1ZhbGlkVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5taW5pbXVtKCkgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdGhpcy5tYXhpbXVtKCk7XG4gIH07XG4gIF9wcm90by5jaGVja1ZhbGlkVmFsdWUgPSBmdW5jdGlvbiBjaGVja1ZhbGlkVmFsdWUodmFsdWUsIGZpZWxkKSB7XG4gICAgdmFyIG1zZztcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFZhbHVlKHZhbHVlKSkge1xuICAgICAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgbXNnID0gXCJJbnZhbGlkIHZhbHVlIGZvciBcIiArIGZpZWxkICsgXCIgKHZhbGlkIHZhbHVlcyBcIiArIHRoaXMudG9TdHJpbmcoKSArIFwiKTogXCIgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9IFwiSW52YWxpZCB2YWx1ZSAodmFsaWQgdmFsdWVzIFwiICsgdGhpcy50b1N0cmluZygpICsgXCIpOiBcIiArIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzc2VydChmYWxzZSwgbXNnLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLmNoZWNrVmFsaWRJbnRWYWx1ZSA9IGZ1bmN0aW9uIGNoZWNrVmFsaWRJbnRWYWx1ZSh2YWx1ZSwgZmllbGQpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkSW50VmFsdWUodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCBpbnQgdmFsdWUgZm9yIFwiICsgZmllbGQgKyBcIjogXCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLmlzVmFsaWRJbnRWYWx1ZSA9IGZ1bmN0aW9uIGlzVmFsaWRJbnRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSW50VmFsdWUoKSAmJiB0aGlzLmlzVmFsaWRWYWx1ZSh2YWx1ZSk7XG4gIH07XG4gIF9wcm90by5pc0ludFZhbHVlID0gZnVuY3Rpb24gaXNJbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5pbXVtKCkgPj0gTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUiAmJiB0aGlzLm1heGltdW0oKSA8PSBNYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSO1xuICB9O1xuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgVmFsdWVSYW5nZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pblNtYWxsZXN0ID09PSBvdGhlci5fbWluU21hbGxlc3QgJiYgdGhpcy5fbWluTGFyZ2VzdCA9PT0gb3RoZXIuX21pbkxhcmdlc3QgJiYgdGhpcy5fbWF4U21hbGxlc3QgPT09IG90aGVyLl9tYXhTbWFsbGVzdCAmJiB0aGlzLl9tYXhMYXJnZXN0ID09PSBvdGhlci5fbWF4TGFyZ2VzdDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaGFzaENvZGUodGhpcy5fbWluU21hbGxlc3QsIHRoaXMuX21pbkxhcmdlc3QsIHRoaXMuX21heFNtYWxsZXN0LCB0aGlzLl9tYXhMYXJnZXN0KTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMubWluaW11bSgpICsgKHRoaXMubWluaW11bSgpICE9PSB0aGlzLmxhcmdlc3RNaW5pbXVtKCkgPyBcIi9cIiArIHRoaXMubGFyZ2VzdE1pbmltdW0oKSA6ICcnKTtcbiAgICBzdHIgKz0gJyAtICc7XG4gICAgc3RyICs9IHRoaXMuc21hbGxlc3RNYXhpbXVtKCkgKyAodGhpcy5zbWFsbGVzdE1heGltdW0oKSAhPT0gdGhpcy5tYXhpbXVtKCkgPyBcIi9cIiArIHRoaXMubWF4aW11bSgpIDogJycpO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIFZhbHVlUmFuZ2Uub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZVJhbmdlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1sxXSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlUmFuZ2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVSYW5nZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0KGZhbHNlLCBcIkludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBcIiArIGFyZ3VtZW50cy5sZW5ndGgsIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gVmFsdWVSYW5nZTtcbn0oKTtcblxudmFyIENocm9ub0ZpZWxkID0gZnVuY3Rpb24gKF9UZW1wb3JhbEZpZWxkKSB7XG4gIF9pbmhlcml0c0xvb3NlKENocm9ub0ZpZWxkLCBfVGVtcG9yYWxGaWVsZCk7XG4gIENocm9ub0ZpZWxkLmJ5TmFtZSA9IGZ1bmN0aW9uIGJ5TmFtZShmaWVsZE5hbWUpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoQ2hyb25vRmllbGRbcHJvcF0pIHtcbiAgICAgICAgaWYgKENocm9ub0ZpZWxkW3Byb3BdIGluc3RhbmNlb2YgQ2hyb25vRmllbGQgJiYgQ2hyb25vRmllbGRbcHJvcF0ubmFtZSgpID09PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gQ2hyb25vRmllbGRbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIENocm9ub0ZpZWxkKG5hbWUsIGJhc2VVbml0LCByYW5nZVVuaXQsIHJhbmdlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX1RlbXBvcmFsRmllbGQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9uYW1lID0gbmFtZTtcbiAgICBfdGhpcy5fYmFzZVVuaXQgPSBiYXNlVW5pdDtcbiAgICBfdGhpcy5fcmFuZ2VVbml0ID0gcmFuZ2VVbml0O1xuICAgIF90aGlzLl9yYW5nZSA9IHJhbmdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gQ2hyb25vRmllbGQucHJvdG90eXBlO1xuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG4gIF9wcm90by5iYXNlVW5pdCA9IGZ1bmN0aW9uIGJhc2VVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlVW5pdDtcbiAgfTtcbiAgX3Byb3RvLnJhbmdlVW5pdCA9IGZ1bmN0aW9uIHJhbmdlVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFuZ2VVbml0O1xuICB9O1xuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFuZ2U7XG4gIH07XG4gIF9wcm90by5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGRpc3BsYXlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIF9wcm90by5jaGVja1ZhbGlkVmFsdWUgPSBmdW5jdGlvbiBjaGVja1ZhbGlkVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRWYWx1ZSh2YWx1ZSwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5jaGVja1ZhbGlkSW50VmFsdWUgPSBmdW5jdGlvbiBjaGVja1ZhbGlkSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRJbnRWYWx1ZSh2YWx1ZSwgdGhpcyk7XG4gIH07XG4gIF9wcm90by5pc0RhdGVCYXNlZCA9IGZ1bmN0aW9uIGlzRGF0ZUJhc2VkKCkge1xuICAgIHZhciBkYXRlQmFzZWQgPSB0aGlzID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEggfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuREFZX09GX1lFQVIgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuRVBPQ0hfREFZIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USCB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USCB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5ZRUFSIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkVSQTtcbiAgICByZXR1cm4gZGF0ZUJhc2VkO1xuICB9O1xuICBfcHJvdG8uaXNUaW1lQmFzZWQgPSBmdW5jdGlvbiBpc1RpbWVCYXNlZCgpIHtcbiAgICB2YXIgdGltZUJhc2VkID0gdGhpcyA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLk1JQ1JPX09GX0RBWSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE0gfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuSE9VUl9PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk7XG4gICAgcmV0dXJuIHRpbWVCYXNlZDtcbiAgfTtcbiAgX3Byb3RvLnJhbmdlUmVmaW5lZEJ5ID0gZnVuY3Rpb24gcmFuZ2VSZWZpbmVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwucmFuZ2UodGhpcyk7XG4gIH07XG4gIF9wcm90by5nZXRGcm9tID0gZnVuY3Rpb24gZ2V0RnJvbSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5nZXRMb25nKHRoaXMpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lKCk7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXI7XG4gIH07XG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCwgbmV3VmFsdWUpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aCh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKTtcbiAgfTtcbiAgcmV0dXJuIENocm9ub0ZpZWxkO1xufShUZW1wb3JhbEZpZWxkKTtcbmZ1bmN0aW9uIF9pbml0JGsoKSB7XG4gIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EID0gbmV3IENocm9ub0ZpZWxkKCdOYW5vT2ZTZWNvbmQnLCBDaHJvbm9Vbml0Lk5BTk9TLCBDaHJvbm9Vbml0LlNFQ09ORFMsIFZhbHVlUmFuZ2Uub2YoMCwgOTk5OTk5OTk5KSk7XG4gIENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZID0gbmV3IENocm9ub0ZpZWxkKCdOYW5vT2ZEYXknLCBDaHJvbm9Vbml0Lk5BTk9TLCBDaHJvbm9Vbml0LkRBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgODY0MDAgKiAxMDAwMDAwMDAwIC0gMSkpO1xuICBDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQgPSBuZXcgQ2hyb25vRmllbGQoJ01pY3JvT2ZTZWNvbmQnLCBDaHJvbm9Vbml0Lk1JQ1JPUywgQ2hyb25vVW5pdC5TRUNPTkRTLCBWYWx1ZVJhbmdlLm9mKDAsIDk5OTk5OSkpO1xuICBDaHJvbm9GaWVsZC5NSUNST19PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ01pY3JvT2ZEYXknLCBDaHJvbm9Vbml0Lk1JQ1JPUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDg2NDAwICogMTAwMDAwMCAtIDEpKTtcbiAgQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EID0gbmV3IENocm9ub0ZpZWxkKCdNaWxsaU9mU2Vjb25kJywgQ2hyb25vVW5pdC5NSUxMSVMsIENocm9ub1VuaXQuU0VDT05EUywgVmFsdWVSYW5nZS5vZigwLCA5OTkpKTtcbiAgQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZID0gbmV3IENocm9ub0ZpZWxkKCdNaWxsaU9mRGF5JywgQ2hyb25vVW5pdC5NSUxMSVMsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigwLCA4NjQwMCAqIDEwMDAgLSAxKSk7XG4gIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUgPSBuZXcgQ2hyb25vRmllbGQoJ1NlY29uZE9mTWludXRlJywgQ2hyb25vVW5pdC5TRUNPTkRTLCBDaHJvbm9Vbml0Lk1JTlVURVMsIFZhbHVlUmFuZ2Uub2YoMCwgNTkpKTtcbiAgQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnU2Vjb25kT2ZEYXknLCBDaHJvbm9Vbml0LlNFQ09ORFMsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigwLCA4NjQwMCAtIDEpKTtcbiAgQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIgPSBuZXcgQ2hyb25vRmllbGQoJ01pbnV0ZU9mSG91cicsIENocm9ub1VuaXQuTUlOVVRFUywgQ2hyb25vVW5pdC5IT1VSUywgVmFsdWVSYW5nZS5vZigwLCA1OSkpO1xuICBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZID0gbmV3IENocm9ub0ZpZWxkKCdNaW51dGVPZkRheScsIENocm9ub1VuaXQuTUlOVVRFUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDI0ICogNjAgLSAxKSk7XG4gIENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSA9IG5ldyBDaHJvbm9GaWVsZCgnSG91ck9mQW1QbScsIENocm9ub1VuaXQuSE9VUlMsIENocm9ub1VuaXQuSEFMRl9EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDExKSk7XG4gIENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfQU1QTSA9IG5ldyBDaHJvbm9GaWVsZCgnQ2xvY2tIb3VyT2ZBbVBtJywgQ2hyb25vVW5pdC5IT1VSUywgQ2hyb25vVW5pdC5IQUxGX0RBWVMsIFZhbHVlUmFuZ2Uub2YoMSwgMTIpKTtcbiAgQ2hyb25vRmllbGQuSE9VUl9PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ0hvdXJPZkRheScsIENocm9ub1VuaXQuSE9VUlMsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigwLCAyMykpO1xuICBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnQ2xvY2tIb3VyT2ZEYXknLCBDaHJvbm9Vbml0LkhPVVJTLCBDaHJvbm9Vbml0LkRBWVMsIFZhbHVlUmFuZ2Uub2YoMSwgMjQpKTtcbiAgQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ0FtUG1PZkRheScsIENocm9ub1VuaXQuSEFMRl9EQVlTLCBDaHJvbm9Vbml0LkRBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgMSkpO1xuICBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyA9IG5ldyBDaHJvbm9GaWVsZCgnRGF5T2ZXZWVrJywgQ2hyb25vVW5pdC5EQVlTLCBDaHJvbm9Vbml0LldFRUtTLCBWYWx1ZVJhbmdlLm9mKDEsIDcpKTtcbiAgQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9NT05USCA9IG5ldyBDaHJvbm9GaWVsZCgnQWxpZ25lZERheU9mV2Vla0luTW9udGgnLCBDaHJvbm9Vbml0LkRBWVMsIENocm9ub1VuaXQuV0VFS1MsIFZhbHVlUmFuZ2Uub2YoMSwgNykpO1xuICBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX1lFQVIgPSBuZXcgQ2hyb25vRmllbGQoJ0FsaWduZWREYXlPZldlZWtJblllYXInLCBDaHJvbm9Vbml0LkRBWVMsIENocm9ub1VuaXQuV0VFS1MsIFZhbHVlUmFuZ2Uub2YoMSwgNykpO1xuICBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEggPSBuZXcgQ2hyb25vRmllbGQoJ0RheU9mTW9udGgnLCBDaHJvbm9Vbml0LkRBWVMsIENocm9ub1VuaXQuTU9OVEhTLCBWYWx1ZVJhbmdlLm9mKDEsIDI4LCAzMSksICdkYXknKTtcbiAgQ2hyb25vRmllbGQuREFZX09GX1lFQVIgPSBuZXcgQ2hyb25vRmllbGQoJ0RheU9mWWVhcicsIENocm9ub1VuaXQuREFZUywgQ2hyb25vVW5pdC5ZRUFSUywgVmFsdWVSYW5nZS5vZigxLCAzNjUsIDM2NikpO1xuICBDaHJvbm9GaWVsZC5FUE9DSF9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ0Vwb2NoRGF5JywgQ2hyb25vVW5pdC5EQVlTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoLTM2NTk2MTY2MiwgMzY0NTIyOTcxKSk7XG4gIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USCA9IG5ldyBDaHJvbm9GaWVsZCgnQWxpZ25lZFdlZWtPZk1vbnRoJywgQ2hyb25vVW5pdC5XRUVLUywgQ2hyb25vVW5pdC5NT05USFMsIFZhbHVlUmFuZ2Uub2YoMSwgNCwgNSkpO1xuICBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUiA9IG5ldyBDaHJvbm9GaWVsZCgnQWxpZ25lZFdlZWtPZlllYXInLCBDaHJvbm9Vbml0LldFRUtTLCBDaHJvbm9Vbml0LllFQVJTLCBWYWx1ZVJhbmdlLm9mKDEsIDUzKSk7XG4gIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIgPSBuZXcgQ2hyb25vRmllbGQoJ01vbnRoT2ZZZWFyJywgQ2hyb25vVW5pdC5NT05USFMsIENocm9ub1VuaXQuWUVBUlMsIFZhbHVlUmFuZ2Uub2YoMSwgMTIpLCAnbW9udGgnKTtcbiAgQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIID0gbmV3IENocm9ub0ZpZWxkKCdQcm9sZXB0aWNNb250aCcsIENocm9ub1VuaXQuTU9OVEhTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoWWVhckNvbnN0YW50cy5NSU5fVkFMVUUgKiAxMiwgWWVhckNvbnN0YW50cy5NQVhfVkFMVUUgKiAxMiArIDExKSk7XG4gIENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBID0gbmV3IENocm9ub0ZpZWxkKCdZZWFyT2ZFcmEnLCBDaHJvbm9Vbml0LllFQVJTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoMSwgWWVhckNvbnN0YW50cy5NQVhfVkFMVUUsIFllYXJDb25zdGFudHMuTUFYX1ZBTFVFICsgMSkpO1xuICBDaHJvbm9GaWVsZC5ZRUFSID0gbmV3IENocm9ub0ZpZWxkKCdZZWFyJywgQ2hyb25vVW5pdC5ZRUFSUywgQ2hyb25vVW5pdC5GT1JFVkVSLCBWYWx1ZVJhbmdlLm9mKFllYXJDb25zdGFudHMuTUlOX1ZBTFVFLCBZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSksICd5ZWFyJyk7XG4gIENocm9ub0ZpZWxkLkVSQSA9IG5ldyBDaHJvbm9GaWVsZCgnRXJhJywgQ2hyb25vVW5pdC5FUkFTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoMCwgMSkpO1xuICBDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMgPSBuZXcgQ2hyb25vRmllbGQoJ0luc3RhbnRTZWNvbmRzJywgQ2hyb25vVW5pdC5TRUNPTkRTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoTUlOX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUikpO1xuICBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUyA9IG5ldyBDaHJvbm9GaWVsZCgnT2Zmc2V0U2Vjb25kcycsIENocm9ub1VuaXQuU0VDT05EUywgQ2hyb25vVW5pdC5GT1JFVkVSLCBWYWx1ZVJhbmdlLm9mKC0xOCAqIDM2MDAsIDE4ICogMzYwMCkpO1xufVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovdmFyIFRlbXBvcmFsUXVlcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVtcG9yYWxRdWVyaWVzKCkge31cbiAgVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCA9IGZ1bmN0aW9uIHpvbmVJZCgpIHtcbiAgICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzLlpPTkVfSUQ7XG4gIH07XG4gIFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5ID0gZnVuY3Rpb24gY2hyb25vbG9neSgpIHtcbiAgICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzLkNIUk9OTztcbiAgfTtcbiAgVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbiA9IGZ1bmN0aW9uIHByZWNpc2lvbigpIHtcbiAgICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzLlBSRUNJU0lPTjtcbiAgfTtcbiAgVGVtcG9yYWxRdWVyaWVzLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIHJldHVybiBUZW1wb3JhbFF1ZXJpZXMuWk9ORTtcbiAgfTtcbiAgVGVtcG9yYWxRdWVyaWVzLm9mZnNldCA9IGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzLk9GRlNFVDtcbiAgfTtcbiAgVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSA9IGZ1bmN0aW9uIGxvY2FsRGF0ZSgpIHtcbiAgICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzLkxPQ0FMX0RBVEU7XG4gIH07XG4gIFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUgPSBmdW5jdGlvbiBsb2NhbFRpbWUoKSB7XG4gICAgcmV0dXJuIFRlbXBvcmFsUXVlcmllcy5MT0NBTF9USU1FO1xuICB9O1xuICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzO1xufSgpO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBUZW1wb3JhbEFjY2Vzc29yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEFjY2Vzc29yKCkge31cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsQWNjZXNzb3IucHJvdG90eXBlO1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZShmaWVsZCkuY2hlY2tWYWxpZEludFZhbHVlKHRoaXMuZ2V0TG9uZyhmaWVsZCksIGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdnZXRMb25nJyk7XG4gIH07XG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNTdXBwb3J0ZWQnKTtcbiAgfTtcbiAgcmV0dXJuIFRlbXBvcmFsQWNjZXNzb3I7XG59KCk7XG5cbnZhciBUZW1wb3JhbFF1ZXJ5ID0gZnVuY3Rpb24gKF9FbnVtKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRlbXBvcmFsUXVlcnksIF9FbnVtKTtcbiAgZnVuY3Rpb24gVGVtcG9yYWxRdWVyeSgpIHtcbiAgICByZXR1cm4gX0VudW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBUZW1wb3JhbFF1ZXJ5LnByb3RvdHlwZTtcbiAgX3Byb3RvLnF1ZXJ5RnJvbSA9IGZ1bmN0aW9uIHF1ZXJ5RnJvbSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgncXVlcnlGcm9tJyk7XG4gIH07XG4gIHJldHVybiBUZW1wb3JhbFF1ZXJ5O1xufShFbnVtKTtcbmZ1bmN0aW9uIGNyZWF0ZVRlbXBvcmFsUXVlcnkobmFtZSwgcXVlcnlGcm9tRnVuY3Rpb24pIHtcbiAgdmFyIEV4dGVuZGVkVGVtcG9yYWxRdWVyeSA9IGZ1bmN0aW9uIChfVGVtcG9yYWxRdWVyeSkge1xuICAgIF9pbmhlcml0c0xvb3NlKEV4dGVuZGVkVGVtcG9yYWxRdWVyeSwgX1RlbXBvcmFsUXVlcnkpO1xuICAgIGZ1bmN0aW9uIEV4dGVuZGVkVGVtcG9yYWxRdWVyeSgpIHtcbiAgICAgIHJldHVybiBfVGVtcG9yYWxRdWVyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBFeHRlbmRlZFRlbXBvcmFsUXVlcnk7XG4gIH0oVGVtcG9yYWxRdWVyeSk7XG4gIEV4dGVuZGVkVGVtcG9yYWxRdWVyeS5wcm90b3R5cGUucXVlcnlGcm9tID0gcXVlcnlGcm9tRnVuY3Rpb247XG4gIHJldHVybiBuZXcgRXh0ZW5kZWRUZW1wb3JhbFF1ZXJ5KG5hbWUpO1xufVxuXG52YXIgRGF5T2ZXZWVrID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFjY2Vzc29yKSB7XG4gIF9pbmhlcml0c0xvb3NlKERheU9mV2VlaywgX1RlbXBvcmFsQWNjZXNzb3IpO1xuICBmdW5jdGlvbiBEYXlPZldlZWsob3JkaW5hbCwgbmFtZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9UZW1wb3JhbEFjY2Vzc29yLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fb3JkaW5hbCA9IG9yZGluYWw7XG4gICAgX3RoaXMuX25hbWUgPSBuYW1lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gRGF5T2ZXZWVrLnByb3RvdHlwZTtcbiAgX3Byb3RvLm9yZGluYWwgPSBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsO1xuICB9O1xuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG4gIERheU9mV2Vlay52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIEVOVU1TLnNsaWNlKCk7XG4gIH07XG4gIERheU9mV2Vlay52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZihuYW1lKSB7XG4gICAgdmFyIG9yZGluYWwgPSAwO1xuICAgIGZvciAob3JkaW5hbDsgb3JkaW5hbCA8IEVOVU1TLmxlbmd0aDsgb3JkaW5hbCsrKSB7XG4gICAgICBpZiAoRU5VTVNbb3JkaW5hbF0ubmFtZSgpID09PSBuYW1lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRGF5T2ZXZWVrLm9mKG9yZGluYWwgKyAxKTtcbiAgfTtcbiAgRGF5T2ZXZWVrLm9mID0gZnVuY3Rpb24gb2YoZGF5T2ZXZWVrKSB7XG4gICAgaWYgKGRheU9mV2VlayA8IDEgfHwgZGF5T2ZXZWVrID4gNykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCB2YWx1ZSBmb3IgRGF5T2ZXZWVrOiBcIiArIGRheU9mV2Vlayk7XG4gICAgfVxuICAgIHJldHVybiBFTlVNU1tkYXlPZldlZWsgLSAxXTtcbiAgfTtcbiAgRGF5T2ZXZWVrLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgYXNzZXJ0KHRlbXBvcmFsICE9IG51bGwsICd0ZW1wb3JhbCcsIE51bGxQb2ludGVyRXhjZXB0aW9uKTtcbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBEYXlPZldlZWspIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBEYXlPZldlZWsub2YodGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIERhdGVUaW1lRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gRGF5T2ZXZWVrIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiLCB0eXBlIFwiICsgKHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpLCBleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by52YWx1ZSA9IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsICsgMTtcbiAgfTtcbiAgX3Byb3RvLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gZGlzcGxheU5hbWUoc3R5bGUsIGxvY2FsZSkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gdXNpbmcgKGxvY2FsaXplZCkgdGV4dCBub3QgaW1wbGVtZW50ZWQgeWV0IScpO1xuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQgIT0gbnVsbCAmJiBmaWVsZC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuREFZX09GX1dFRUspIHtcbiAgICAgIHJldHVybiBmaWVsZC5yYW5nZSgpO1xuICAgIH0gZWxzZSBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQucmFuZ2VSZWZpbmVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYW5nZShmaWVsZCkuY2hlY2tWYWxpZEludFZhbHVlKHRoaXMuZ2V0TG9uZyhmaWVsZCksIGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSykge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5wbHVzID0gZnVuY3Rpb24gcGx1cyhkYXlzKSB7XG4gICAgdmFyIGFtb3VudCA9IE1hdGhVdGlsLmZsb29yTW9kKGRheXMsIDcpO1xuICAgIHJldHVybiBFTlVNU1tNYXRoVXRpbC5mbG9vck1vZCh0aGlzLl9vcmRpbmFsICsgKGFtb3VudCArIDcpLCA3KV07XG4gIH07XG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGRheXMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzKC0xICogTWF0aFV0aWwuZmxvb3JNb2QoZGF5cywgNykpO1xuICB9O1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0LkRBWVM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXNzZXJ0KF9xdWVyeSAhPSBudWxsLCAncXVlcnknLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSywgdGhpcy52YWx1ZSgpKTtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBEYXlPZldlZWssICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsIC0gb3RoZXIuX29yZGluYWw7XG4gIH07XG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgcmV0dXJuIERheU9mV2Vlaztcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG52YXIgRU5VTVM7XG5mdW5jdGlvbiBfaW5pdCRqKCkge1xuICBEYXlPZldlZWsuTU9OREFZID0gbmV3IERheU9mV2VlaygwLCAnTU9OREFZJyk7XG4gIERheU9mV2Vlay5UVUVTREFZID0gbmV3IERheU9mV2VlaygxLCAnVFVFU0RBWScpO1xuICBEYXlPZldlZWsuV0VETkVTREFZID0gbmV3IERheU9mV2VlaygyLCAnV0VETkVTREFZJyk7XG4gIERheU9mV2Vlay5USFVSU0RBWSA9IG5ldyBEYXlPZldlZWsoMywgJ1RIVVJTREFZJyk7XG4gIERheU9mV2Vlay5GUklEQVkgPSBuZXcgRGF5T2ZXZWVrKDQsICdGUklEQVknKTtcbiAgRGF5T2ZXZWVrLlNBVFVSREFZID0gbmV3IERheU9mV2Vlayg1LCAnU0FUVVJEQVknKTtcbiAgRGF5T2ZXZWVrLlNVTkRBWSA9IG5ldyBEYXlPZldlZWsoNiwgJ1NVTkRBWScpO1xuICBEYXlPZldlZWsuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0RheU9mV2Vlay5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIERheU9mV2Vlay5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG4gIEVOVU1TID0gW0RheU9mV2Vlay5NT05EQVksIERheU9mV2Vlay5UVUVTREFZLCBEYXlPZldlZWsuV0VETkVTREFZLCBEYXlPZldlZWsuVEhVUlNEQVksIERheU9mV2Vlay5GUklEQVksIERheU9mV2Vlay5TQVRVUkRBWSwgRGF5T2ZXZWVrLlNVTkRBWV07XG59XG5cbnZhciBNb250aCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShNb250aCwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuICBmdW5jdGlvbiBNb250aCh2YWx1ZSwgbmFtZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9UZW1wb3JhbEFjY2Vzc29yLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fdmFsdWUgPSBNYXRoVXRpbC5zYWZlVG9JbnQodmFsdWUpO1xuICAgIF90aGlzLl9uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IE1vbnRoLnByb3RvdHlwZTtcbiAgX3Byb3RvLnZhbHVlID0gZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9O1xuICBfcHJvdG8ub3JkaW5hbCA9IGZ1bmN0aW9uIG9yZGluYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlIC0gMTtcbiAgfTtcbiAgX3Byb3RvLm5hbWUgPSBmdW5jdGlvbiBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9O1xuICBfcHJvdG8uZGlzcGxheU5hbWUgPSBmdW5jdGlvbiBkaXNwbGF5TmFtZShzdHlsZSwgbG9jYWxlKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUGF0dGVybiB1c2luZyAobG9jYWxpemVkKSB0ZXh0IG5vdCBpbXBsZW1lbnRlZCB5ZXQhJyk7XG4gIH07XG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkKSB7XG4gICAgaWYgKG51bGwgPT09IGZpZWxkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZCAhPSBudWxsICYmIGZpZWxkLmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuICBfcHJvdG8ucGx1cyA9IGZ1bmN0aW9uIHBsdXMobW9udGhzKSB7XG4gICAgdmFyIGFtb3VudCA9IE1hdGhVdGlsLmludE1vZChtb250aHMsIDEyKSArIDEyO1xuICAgIHZhciBuZXdNb250aFZhbCA9IE1hdGhVdGlsLmludE1vZCh0aGlzLnZhbHVlKCkgKyBhbW91bnQsIDEyKTtcbiAgICBuZXdNb250aFZhbCA9IG5ld01vbnRoVmFsID09PSAwID8gMTIgOiBuZXdNb250aFZhbDtcbiAgICByZXR1cm4gTW9udGgub2YobmV3TW9udGhWYWwpO1xuICB9O1xuICBfcHJvdG8ubWludXMgPSBmdW5jdGlvbiBtaW51cyhtb250aHMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzKC0xICogTWF0aFV0aWwuaW50TW9kKG1vbnRocywgMTIpKTtcbiAgfTtcbiAgX3Byb3RvLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChsZWFwWWVhcikge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBNb250aC5GRUJSVUFSWTpcbiAgICAgICAgcmV0dXJuIGxlYXBZZWFyID8gMjkgOiAyODtcbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICBjYXNlIE1vbnRoLkpVTkU6XG4gICAgICBjYXNlIE1vbnRoLlNFUFRFTUJFUjpcbiAgICAgIGNhc2UgTW9udGguTk9WRU1CRVI6XG4gICAgICAgIHJldHVybiAzMDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAzMTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5taW5MZW5ndGggPSBmdW5jdGlvbiBtaW5MZW5ndGgoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIE1vbnRoLkZFQlJVQVJZOlxuICAgICAgICByZXR1cm4gMjg7XG4gICAgICBjYXNlIE1vbnRoLkFQUklMOlxuICAgICAgY2FzZSBNb250aC5KVU5FOlxuICAgICAgY2FzZSBNb250aC5TRVBURU1CRVI6XG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgICByZXR1cm4gMzA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMzE7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubWF4TGVuZ3RoID0gZnVuY3Rpb24gbWF4TGVuZ3RoKCkge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBNb250aC5GRUJSVUFSWTpcbiAgICAgICAgcmV0dXJuIDI5O1xuICAgICAgY2FzZSBNb250aC5BUFJJTDpcbiAgICAgIGNhc2UgTW9udGguSlVORTpcbiAgICAgIGNhc2UgTW9udGguU0VQVEVNQkVSOlxuICAgICAgY2FzZSBNb250aC5OT1ZFTUJFUjpcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gZnVuY3Rpb24gZmlyc3REYXlPZlllYXIobGVhcFllYXIpIHtcbiAgICB2YXIgbGVhcCA9IGxlYXBZZWFyID8gMSA6IDA7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIE1vbnRoLkpBTlVBUlk6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBNb250aC5GRUJSVUFSWTpcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgY2FzZSBNb250aC5NQVJDSDpcbiAgICAgICAgcmV0dXJuIDYwICsgbGVhcDtcbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICAgIHJldHVybiA5MSArIGxlYXA7XG4gICAgICBjYXNlIE1vbnRoLk1BWTpcbiAgICAgICAgcmV0dXJuIDEyMSArIGxlYXA7XG4gICAgICBjYXNlIE1vbnRoLkpVTkU6XG4gICAgICAgIHJldHVybiAxNTIgKyBsZWFwO1xuICAgICAgY2FzZSBNb250aC5KVUxZOlxuICAgICAgICByZXR1cm4gMTgyICsgbGVhcDtcbiAgICAgIGNhc2UgTW9udGguQVVHVVNUOlxuICAgICAgICByZXR1cm4gMjEzICsgbGVhcDtcbiAgICAgIGNhc2UgTW9udGguU0VQVEVNQkVSOlxuICAgICAgICByZXR1cm4gMjQ0ICsgbGVhcDtcbiAgICAgIGNhc2UgTW9udGguT0NUT0JFUjpcbiAgICAgICAgcmV0dXJuIDI3NCArIGxlYXA7XG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgICByZXR1cm4gMzA1ICsgbGVhcDtcbiAgICAgIGNhc2UgTW9udGguREVDRU1CRVI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMzM1ICsgbGVhcDtcbiAgICB9XG4gIH07XG4gIF9wcm90by5maXJzdE1vbnRoT2ZRdWFydGVyID0gZnVuY3Rpb24gZmlyc3RNb250aE9mUXVhcnRlcigpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgTW9udGguSkFOVUFSWTpcbiAgICAgIGNhc2UgTW9udGguRkVCUlVBUlk6XG4gICAgICBjYXNlIE1vbnRoLk1BUkNIOlxuICAgICAgICByZXR1cm4gTW9udGguSkFOVUFSWTtcbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICBjYXNlIE1vbnRoLk1BWTpcbiAgICAgIGNhc2UgTW9udGguSlVORTpcbiAgICAgICAgcmV0dXJuIE1vbnRoLkFQUklMO1xuICAgICAgY2FzZSBNb250aC5KVUxZOlxuICAgICAgY2FzZSBNb250aC5BVUdVU1Q6XG4gICAgICBjYXNlIE1vbnRoLlNFUFRFTUJFUjpcbiAgICAgICAgcmV0dXJuIE1vbnRoLkpVTFk7XG4gICAgICBjYXNlIE1vbnRoLk9DVE9CRVI6XG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgY2FzZSBNb250aC5ERUNFTUJFUjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBNb250aC5PQ1RPQkVSO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgYXNzZXJ0KF9xdWVyeSAhPSBudWxsLCAncXVlcnkoKSBwYXJhbWV0ZXIgbXVzdCBub3QgYmUgbnVsbCcsIERhdGVUaW1lRXhjZXB0aW9uKTtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5NT05USFM7XG4gICAgfVxuICAgIHJldHVybiBfVGVtcG9yYWxBY2Nlc3Nvci5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgTW9udGguSkFOVUFSWTpcbiAgICAgICAgcmV0dXJuICdKQU5VQVJZJztcbiAgICAgIGNhc2UgTW9udGguRkVCUlVBUlk6XG4gICAgICAgIHJldHVybiAnRkVCUlVBUlknO1xuICAgICAgY2FzZSBNb250aC5NQVJDSDpcbiAgICAgICAgcmV0dXJuICdNQVJDSCc7XG4gICAgICBjYXNlIE1vbnRoLkFQUklMOlxuICAgICAgICByZXR1cm4gJ0FQUklMJztcbiAgICAgIGNhc2UgTW9udGguTUFZOlxuICAgICAgICByZXR1cm4gJ01BWSc7XG4gICAgICBjYXNlIE1vbnRoLkpVTkU6XG4gICAgICAgIHJldHVybiAnSlVORSc7XG4gICAgICBjYXNlIE1vbnRoLkpVTFk6XG4gICAgICAgIHJldHVybiAnSlVMWSc7XG4gICAgICBjYXNlIE1vbnRoLkFVR1VTVDpcbiAgICAgICAgcmV0dXJuICdBVUdVU1QnO1xuICAgICAgY2FzZSBNb250aC5TRVBURU1CRVI6XG4gICAgICAgIHJldHVybiAnU0VQVEVNQkVSJztcbiAgICAgIGNhc2UgTW9udGguT0NUT0JFUjpcbiAgICAgICAgcmV0dXJuICdPQ1RPQkVSJztcbiAgICAgIGNhc2UgTW9udGguTk9WRU1CRVI6XG4gICAgICAgIHJldHVybiAnTk9WRU1CRVInO1xuICAgICAgY2FzZSBNb250aC5ERUNFTUJFUjpcbiAgICAgICAgcmV0dXJuICdERUNFTUJFUic7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJ1bmtub3duIE1vbnRoLCB2YWx1ZTogXCIgKyB0aGlzLnZhbHVlKCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIHRoaXMudmFsdWUoKSk7XG4gIH07XG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBNb250aCwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlIC0gb3RoZXIuX3ZhbHVlO1xuICB9O1xuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMgPT09IG90aGVyO1xuICB9O1xuICBNb250aC52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZihuYW1lKSB7XG4gICAgdmFyIG9yZGluYWwgPSAwO1xuICAgIGZvciAob3JkaW5hbDsgb3JkaW5hbCA8IE1PTlRIUy5sZW5ndGg7IG9yZGluYWwrKykge1xuICAgICAgaWYgKE1PTlRIU1tvcmRpbmFsXS5uYW1lKCkgPT09IG5hbWUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNb250aC5vZihvcmRpbmFsICsgMSk7XG4gIH07XG4gIE1vbnRoLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gTU9OVEhTLnNsaWNlKCk7XG4gIH07XG4gIE1vbnRoLm9mID0gZnVuY3Rpb24gb2YobW9udGgpIHtcbiAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgXCJJbnZhbGlkIHZhbHVlIGZvciBNb250aE9mWWVhcjogXCIgKyBtb250aCwgRGF0ZVRpbWVFeGNlcHRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gTU9OVEhTW21vbnRoIC0gMV07XG4gIH07XG4gIE1vbnRoLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgTW9udGgpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBNb250aC5vZih0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJVbmFibGUgdG8gb2J0YWluIE1vbnRoIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiIG9mIHR5cGUgXCIgKyAodGVtcG9yYWwgJiYgdGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJyksIGV4KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBNb250aDtcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG52YXIgTU9OVEhTO1xuZnVuY3Rpb24gX2luaXQkaSgpIHtcbiAgTW9udGguSkFOVUFSWSA9IG5ldyBNb250aCgxLCAnSkFOVUFSWScpO1xuICBNb250aC5GRUJSVUFSWSA9IG5ldyBNb250aCgyLCAnRkVCUlVBUlknKTtcbiAgTW9udGguTUFSQ0ggPSBuZXcgTW9udGgoMywgJ01BUkNIJyk7XG4gIE1vbnRoLkFQUklMID0gbmV3IE1vbnRoKDQsICdBUFJJTCcpO1xuICBNb250aC5NQVkgPSBuZXcgTW9udGgoNSwgJ01BWScpO1xuICBNb250aC5KVU5FID0gbmV3IE1vbnRoKDYsICdKVU5FJyk7XG4gIE1vbnRoLkpVTFkgPSBuZXcgTW9udGgoNywgJ0pVTFknKTtcbiAgTW9udGguQVVHVVNUID0gbmV3IE1vbnRoKDgsICdBVUdVU1QnKTtcbiAgTW9udGguU0VQVEVNQkVSID0gbmV3IE1vbnRoKDksICdTRVBURU1CRVInKTtcbiAgTW9udGguT0NUT0JFUiA9IG5ldyBNb250aCgxMCwgJ09DVE9CRVInKTtcbiAgTW9udGguTk9WRU1CRVIgPSBuZXcgTW9udGgoMTEsICdOT1ZFTUJFUicpO1xuICBNb250aC5ERUNFTUJFUiA9IG5ldyBNb250aCgxMiwgJ0RFQ0VNQkVSJyk7XG4gIE1PTlRIUyA9IFtNb250aC5KQU5VQVJZLCBNb250aC5GRUJSVUFSWSwgTW9udGguTUFSQ0gsIE1vbnRoLkFQUklMLCBNb250aC5NQVksIE1vbnRoLkpVTkUsIE1vbnRoLkpVTFksIE1vbnRoLkFVR1VTVCwgTW9udGguU0VQVEVNQkVSLCBNb250aC5PQ1RPQkVSLCBNb250aC5OT1ZFTUJFUiwgTW9udGguREVDRU1CRVJdO1xufVxuXG52YXIgUEFUVEVSTiA9IC8oWy0rXT8pUCg/OihbLStdP1swLTldKylZKT8oPzooWy0rXT9bMC05XSspTSk/KD86KFstK10/WzAtOV0rKVcpPyg/OihbLStdP1swLTldKylEKT8vO1xudmFyIFBlcmlvZCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBbW91bnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGVyaW9kLCBfVGVtcG9yYWxBbW91bnQpO1xuICBmdW5jdGlvbiBQZXJpb2QoeWVhcnMsIG1vbnRocywgZGF5cykge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9UZW1wb3JhbEFtb3VudC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgdmFyIF95ZWFycyA9IE1hdGhVdGlsLnNhZmVUb0ludCh5ZWFycyk7XG4gICAgdmFyIF9tb250aHMgPSBNYXRoVXRpbC5zYWZlVG9JbnQobW9udGhzKTtcbiAgICB2YXIgX2RheXMgPSBNYXRoVXRpbC5zYWZlVG9JbnQoZGF5cyk7XG4gICAgaWYgKF95ZWFycyA9PT0gMCAmJiBfbW9udGhzID09PSAwICYmIF9kYXlzID09PSAwKSB7XG4gICAgICBpZiAoIVBlcmlvZC5aRVJPKSB7XG4gICAgICAgIF90aGlzLl95ZWFycyA9IF95ZWFycztcbiAgICAgICAgX3RoaXMuX21vbnRocyA9IF9tb250aHM7XG4gICAgICAgIF90aGlzLl9kYXlzID0gX2RheXM7XG4gICAgICAgIFBlcmlvZC5aRVJPID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGVyaW9kLlpFUk8gfHwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgfVxuICAgIF90aGlzLl95ZWFycyA9IF95ZWFycztcbiAgICBfdGhpcy5fbW9udGhzID0gX21vbnRocztcbiAgICBfdGhpcy5fZGF5cyA9IF9kYXlzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBQZXJpb2Qub2ZZZWFycyA9IGZ1bmN0aW9uIG9mWWVhcnMoeWVhcnMpIHtcbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSh5ZWFycywgMCwgMCk7XG4gIH07XG4gIFBlcmlvZC5vZk1vbnRocyA9IGZ1bmN0aW9uIG9mTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKDAsIG1vbnRocywgMCk7XG4gIH07XG4gIFBlcmlvZC5vZldlZWtzID0gZnVuY3Rpb24gb2ZXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKDAsIDAsIE1hdGhVdGlsLnNhZmVNdWx0aXBseSh3ZWVrcywgNykpO1xuICB9O1xuICBQZXJpb2Qub2ZEYXlzID0gZnVuY3Rpb24gb2ZEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSgwLCAwLCBkYXlzKTtcbiAgfTtcbiAgUGVyaW9kLm9mID0gZnVuY3Rpb24gb2YoeWVhcnMsIG1vbnRocywgZGF5cykge1xuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKHllYXJzLCBtb250aHMsIGRheXMpO1xuICB9O1xuICBQZXJpb2QuZnJvbSA9IGZ1bmN0aW9uIGZyb20oYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCBpbnN0YW5jZW9mIFBlcmlvZCkge1xuICAgICAgcmV0dXJuIGFtb3VudDtcbiAgICB9XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgdmFyIHllYXJzID0gMDtcbiAgICB2YXIgbW9udGhzID0gMDtcbiAgICB2YXIgZGF5cyA9IDA7XG4gICAgdmFyIHVuaXRzID0gYW1vdW50LnVuaXRzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHVuaXQgPSB1bml0c1tpXTtcbiAgICAgIHZhciB1bml0QW1vdW50ID0gYW1vdW50LmdldCh1bml0KTtcbiAgICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LllFQVJTKSB7XG4gICAgICAgIHllYXJzID0gTWF0aFV0aWwuc2FmZVRvSW50KHVuaXRBbW91bnQpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSBDaHJvbm9Vbml0Lk1PTlRIUykge1xuICAgICAgICBtb250aHMgPSBNYXRoVXRpbC5zYWZlVG9JbnQodW5pdEFtb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuREFZUykge1xuICAgICAgICBkYXlzID0gTWF0aFV0aWwuc2FmZVRvSW50KHVuaXRBbW91bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5pdCBtdXN0IGJlIFllYXJzLCBNb250aHMgb3IgRGF5cywgYnV0IHdhcyBcIiArIHVuaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSh5ZWFycywgbW9udGhzLCBkYXlzKTtcbiAgfTtcbiAgUGVyaW9kLmJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHN0YXJ0RGF0ZSwgJ3N0YXJ0RGF0ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZERhdGUsICdlbmREYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHN0YXJ0RGF0ZSwgTG9jYWxEYXRlLCAnc3RhcnREYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGVuZERhdGUsIExvY2FsRGF0ZSwgJ2VuZERhdGUnKTtcbiAgICByZXR1cm4gc3RhcnREYXRlLnVudGlsKGVuZERhdGUpO1xuICB9O1xuICBQZXJpb2QucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFBlcmlvZC5fcGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIEFyaXRobWV0aWNFeGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oJ1RleHQgY2Fubm90IGJlIHBhcnNlZCB0byBhIFBlcmlvZCcsIHRleHQsIDAsIGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUGVyaW9kLl9wYXJzZSA9IGZ1bmN0aW9uIF9wYXJzZSh0ZXh0KSB7XG4gICAgdmFyIG1hdGNoZXMgPSBQQVRURVJOLmV4ZWModGV4dCk7XG4gICAgaWYgKG1hdGNoZXMgIT0gbnVsbCkge1xuICAgICAgdmFyIG5lZ2F0ZSA9ICctJyA9PT0gbWF0Y2hlc1sxXSA/IC0xIDogMTtcbiAgICAgIHZhciB5ZWFyTWF0Y2ggPSBtYXRjaGVzWzJdO1xuICAgICAgdmFyIG1vbnRoTWF0Y2ggPSBtYXRjaGVzWzNdO1xuICAgICAgdmFyIHdlZWtNYXRjaCA9IG1hdGNoZXNbNF07XG4gICAgICB2YXIgZGF5TWF0Y2ggPSBtYXRjaGVzWzVdO1xuICAgICAgaWYgKHllYXJNYXRjaCAhPSBudWxsIHx8IG1vbnRoTWF0Y2ggIT0gbnVsbCB8fCB3ZWVrTWF0Y2ggIT0gbnVsbCB8fCBkYXlNYXRjaCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB5ZWFycyA9IFBlcmlvZC5fcGFyc2VOdW1iZXIodGV4dCwgeWVhck1hdGNoLCBuZWdhdGUpO1xuICAgICAgICB2YXIgbW9udGhzID0gUGVyaW9kLl9wYXJzZU51bWJlcih0ZXh0LCBtb250aE1hdGNoLCBuZWdhdGUpO1xuICAgICAgICB2YXIgd2Vla3MgPSBQZXJpb2QuX3BhcnNlTnVtYmVyKHRleHQsIHdlZWtNYXRjaCwgbmVnYXRlKTtcbiAgICAgICAgdmFyIGRheXMgPSBQZXJpb2QuX3BhcnNlTnVtYmVyKHRleHQsIGRheU1hdGNoLCBuZWdhdGUpO1xuICAgICAgICBkYXlzID0gTWF0aFV0aWwuc2FmZUFkZChkYXlzLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkod2Vla3MsIDcpKTtcbiAgICAgICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKCdUZXh0IGNhbm5vdCBiZSBwYXJzZWQgdG8gYSBQZXJpb2QnLCB0ZXh0LCAwKTtcbiAgfTtcbiAgUGVyaW9kLl9wYXJzZU51bWJlciA9IGZ1bmN0aW9uIF9wYXJzZU51bWJlcih0ZXh0LCBzdHIsIG5lZ2F0ZSkge1xuICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciB2YWwgPSBNYXRoVXRpbC5wYXJzZUludChzdHIpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodmFsLCBuZWdhdGUpO1xuICB9O1xuICBQZXJpb2QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHllYXJzLCBtb250aHMsIGRheXMpIHtcbiAgICByZXR1cm4gbmV3IFBlcmlvZCh5ZWFycywgbW9udGhzLCBkYXlzKTtcbiAgfTtcbiAgdmFyIF9wcm90byA9IFBlcmlvZC5wcm90b3R5cGU7XG4gIF9wcm90by51bml0cyA9IGZ1bmN0aW9uIHVuaXRzKCkge1xuICAgIHJldHVybiBbQ2hyb25vVW5pdC5ZRUFSUywgQ2hyb25vVW5pdC5NT05USFMsIENocm9ub1VuaXQuREFZU107XG4gIH07XG4gIF9wcm90by5jaHJvbm9sb2d5ID0gZnVuY3Rpb24gY2hyb25vbG9neSgpIHtcbiAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCh1bml0KSB7XG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuWUVBUlMpIHtcbiAgICAgIHJldHVybiB0aGlzLl95ZWFycztcbiAgICB9XG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuTU9OVEhTKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9udGhzO1xuICAgIH1cbiAgICBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5EQVlTKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF5cztcbiAgICB9XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgdW5pdDogXCIgKyB1bml0KTtcbiAgfTtcbiAgX3Byb3RvLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gUGVyaW9kLlpFUk87XG4gIH07XG4gIF9wcm90by5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhcnMgPCAwIHx8IHRoaXMuX21vbnRocyA8IDAgfHwgdGhpcy5fZGF5cyA8IDA7XG4gIH07XG4gIF9wcm90by55ZWFycyA9IGZ1bmN0aW9uIHllYXJzKCkge1xuICAgIHJldHVybiB0aGlzLl95ZWFycztcbiAgfTtcbiAgX3Byb3RvLm1vbnRocyA9IGZ1bmN0aW9uIG1vbnRocygpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9udGhzO1xuICB9O1xuICBfcHJvdG8uZGF5cyA9IGZ1bmN0aW9uIGRheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RheXM7XG4gIH07XG4gIF9wcm90by53aXRoWWVhcnMgPSBmdW5jdGlvbiB3aXRoWWVhcnMoeWVhcnMpIHtcbiAgICBpZiAoeWVhcnMgPT09IHRoaXMuX3llYXJzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIHRoaXMuX21vbnRocywgdGhpcy5fZGF5cyk7XG4gIH07XG4gIF9wcm90by53aXRoTW9udGhzID0gZnVuY3Rpb24gd2l0aE1vbnRocyhtb250aHMpIHtcbiAgICBpZiAobW9udGhzID09PSB0aGlzLl9tb250aHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSh0aGlzLl95ZWFycywgbW9udGhzLCB0aGlzLl9kYXlzKTtcbiAgfTtcbiAgX3Byb3RvLndpdGhEYXlzID0gZnVuY3Rpb24gd2l0aERheXMoZGF5cykge1xuICAgIGlmIChkYXlzID09PSB0aGlzLl9kYXlzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUodGhpcy5feWVhcnMsIHRoaXMuX21vbnRocywgZGF5cyk7XG4gIH07XG4gIF9wcm90by5wbHVzID0gZnVuY3Rpb24gcGx1cyhhbW91bnRUb0FkZCkge1xuICAgIHZhciBhbW91bnQgPSBQZXJpb2QuZnJvbShhbW91bnRUb0FkZCk7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl95ZWFycywgYW1vdW50Ll95ZWFycyksIE1hdGhVdGlsLnNhZmVBZGQodGhpcy5fbW9udGhzLCBhbW91bnQuX21vbnRocyksIE1hdGhVdGlsLnNhZmVBZGQodGhpcy5fZGF5cywgYW1vdW50Ll9kYXlzKSk7XG4gIH07XG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnNUb0FkZCkge1xuICAgIGlmICh5ZWFyc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoTWF0aFV0aWwuc2FmZVRvSW50KE1hdGhVdGlsLnNhZmVBZGQodGhpcy5feWVhcnMsIHllYXJzVG9BZGQpKSwgdGhpcy5fbW9udGhzLCB0aGlzLl9kYXlzKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRoc1RvQWRkKSB7XG4gICAgaWYgKG1vbnRoc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUodGhpcy5feWVhcnMsIE1hdGhVdGlsLnNhZmVUb0ludChNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX21vbnRocywgbW9udGhzVG9BZGQpKSwgdGhpcy5fZGF5cyk7XG4gIH07XG4gIF9wcm90by5wbHVzRGF5cyA9IGZ1bmN0aW9uIHBsdXNEYXlzKGRheXNUb0FkZCkge1xuICAgIGlmIChkYXlzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSh0aGlzLl95ZWFycywgdGhpcy5fbW9udGhzLCBNYXRoVXRpbC5zYWZlVG9JbnQoTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl9kYXlzLCBkYXlzVG9BZGQpKSk7XG4gIH07XG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGFtb3VudFRvU3VidHJhY3QpIHtcbiAgICB2YXIgYW1vdW50ID0gUGVyaW9kLmZyb20oYW1vdW50VG9TdWJ0cmFjdCk7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoTWF0aFV0aWwuc2FmZVN1YnRyYWN0KHRoaXMuX3llYXJzLCBhbW91bnQuX3llYXJzKSwgTWF0aFV0aWwuc2FmZVN1YnRyYWN0KHRoaXMuX21vbnRocywgYW1vdW50Ll9tb250aHMpLCBNYXRoVXRpbC5zYWZlU3VidHJhY3QodGhpcy5fZGF5cywgYW1vdW50Ll9kYXlzKSk7XG4gIH07XG4gIF9wcm90by5taW51c1llYXJzID0gZnVuY3Rpb24gbWludXNZZWFycyh5ZWFyc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoLTEgKiB5ZWFyc1RvU3VidHJhY3QpO1xuICB9O1xuICBfcHJvdG8ubWludXNNb250aHMgPSBmdW5jdGlvbiBtaW51c01vbnRocyhtb250aHNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c01vbnRocygtMSAqIG1vbnRoc1RvU3VidHJhY3QpO1xuICB9O1xuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c0RheXMoLTEgKiBkYXlzVG9TdWJ0cmFjdCk7XG4gIH07XG4gIF9wcm90by5tdWx0aXBsaWVkQnkgPSBmdW5jdGlvbiBtdWx0aXBsaWVkQnkoc2NhbGFyKSB7XG4gICAgaWYgKHRoaXMgPT09IFBlcmlvZC5aRVJPIHx8IHNjYWxhciA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl95ZWFycywgc2NhbGFyKSwgTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX21vbnRocywgc2NhbGFyKSwgTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX2RheXMsIHNjYWxhcikpO1xuICB9O1xuICBfcHJvdG8ubmVnYXRlZCA9IGZ1bmN0aW9uIG5lZ2F0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGllZEJ5KC0xKTtcbiAgfTtcbiAgX3Byb3RvLm5vcm1hbGl6ZWQgPSBmdW5jdGlvbiBub3JtYWxpemVkKCkge1xuICAgIHZhciB0b3RhbE1vbnRocyA9IHRoaXMudG9Ub3RhbE1vbnRocygpO1xuICAgIHZhciBzcGxpdFllYXJzID0gTWF0aFV0aWwuaW50RGl2KHRvdGFsTW9udGhzLCAxMik7XG4gICAgdmFyIHNwbGl0TW9udGhzID0gTWF0aFV0aWwuaW50TW9kKHRvdGFsTW9udGhzLCAxMik7XG4gICAgaWYgKHNwbGl0WWVhcnMgPT09IHRoaXMuX3llYXJzICYmIHNwbGl0TW9udGhzID09PSB0aGlzLl9tb250aHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZShNYXRoVXRpbC5zYWZlVG9JbnQoc3BsaXRZZWFycyksIHNwbGl0TW9udGhzLCB0aGlzLl9kYXlzKTtcbiAgfTtcbiAgX3Byb3RvLnRvVG90YWxNb250aHMgPSBmdW5jdGlvbiB0b1RvdGFsTW9udGhzKCkge1xuICAgIHJldHVybiB0aGlzLl95ZWFycyAqIDEyICsgdGhpcy5fbW9udGhzO1xuICB9O1xuICBfcHJvdG8uYWRkVG8gPSBmdW5jdGlvbiBhZGRUbyh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICBpZiAodGhpcy5feWVhcnMgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9tb250aHMgIT09IDApIHtcbiAgICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5wbHVzKHRoaXMudG9Ub3RhbE1vbnRocygpLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5feWVhcnMsIENocm9ub1VuaXQuWUVBUlMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbW9udGhzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5fbW9udGhzLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kYXlzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5fZGF5cywgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBvcmFsO1xuICB9O1xuICBfcHJvdG8uc3VidHJhY3RGcm9tID0gZnVuY3Rpb24gc3VidHJhY3RGcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIGlmICh0aGlzLl95ZWFycyAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMuX21vbnRocyAhPT0gMCkge1xuICAgICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMudG9Ub3RhbE1vbnRocygpLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX3llYXJzLCBDaHJvbm9Vbml0LllFQVJTKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21vbnRocyAhPT0gMCkge1xuICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5taW51cyh0aGlzLl9tb250aHMsIENocm9ub1VuaXQuTU9OVEhTKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RheXMgIT09IDApIHtcbiAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwubWludXModGhpcy5fZGF5cywgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBvcmFsO1xuICB9O1xuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG9iaikge1xuICAgIGlmICh0aGlzID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUGVyaW9kKSB7XG4gICAgICB2YXIgb3RoZXIgPSBvYmo7XG4gICAgICByZXR1cm4gdGhpcy5feWVhcnMgPT09IG90aGVyLl95ZWFycyAmJiB0aGlzLl9tb250aHMgPT09IG90aGVyLl9tb250aHMgJiYgdGhpcy5fZGF5cyA9PT0gb3RoZXIuX2RheXM7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2hDb2RlKHRoaXMuX3llYXJzLCB0aGlzLl9tb250aHMsIHRoaXMuX2RheXMpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICBpZiAodGhpcyA9PT0gUGVyaW9kLlpFUk8pIHtcbiAgICAgIHJldHVybiAnUDBEJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9ICdQJztcbiAgICAgIGlmICh0aGlzLl95ZWFycyAhPT0gMCkge1xuICAgICAgICBidWYgKz0gdGhpcy5feWVhcnMgKyBcIllcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tb250aHMgIT09IDApIHtcbiAgICAgICAgYnVmICs9IHRoaXMuX21vbnRocyArIFwiTVwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RheXMgIT09IDApIHtcbiAgICAgICAgYnVmICs9IHRoaXMuX2RheXMgKyBcIkRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIHJldHVybiBQZXJpb2Q7XG59KFRlbXBvcmFsQW1vdW50KTtcbmZ1bmN0aW9uIF9pbml0JGgoKSB7XG4gIFBlcmlvZC5vZkRheXMoMCk7XG59XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL3ZhciBQYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9lcnJvckluZGV4ID0gLTE7XG4gIH1cbiAgdmFyIF9wcm90byA9IFBhcnNlUG9zaXRpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uZ2V0SW5kZXggPSBmdW5jdGlvbiBnZXRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gIH07XG4gIF9wcm90by5zZXRJbmRleCA9IGZ1bmN0aW9uIHNldEluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgfTtcbiAgX3Byb3RvLmdldEVycm9ySW5kZXggPSBmdW5jdGlvbiBnZXRFcnJvckluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9lcnJvckluZGV4O1xuICB9O1xuICBfcHJvdG8uc2V0RXJyb3JJbmRleCA9IGZ1bmN0aW9uIHNldEVycm9ySW5kZXgoZXJyb3JJbmRleCkge1xuICAgIHRoaXMuX2Vycm9ySW5kZXggPSBlcnJvckluZGV4O1xuICB9O1xuICByZXR1cm4gUGFyc2VQb3NpdGlvbjtcbn0oKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL3ZhciBFbnVtTWFwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtTWFwKCkge1xuICAgIHRoaXMuX21hcCA9IHt9O1xuICB9XG4gIHZhciBfcHJvdG8gPSBFbnVtTWFwLnByb3RvdHlwZTtcbiAgX3Byb3RvLnB1dEFsbCA9IGZ1bmN0aW9uIHB1dEFsbChvdGhlck1hcCkge1xuICAgIGZvciAodmFyIGtleSBpbiBvdGhlck1hcC5fbWFwKSB7XG4gICAgICB0aGlzLl9tYXBba2V5XSA9IG90aGVyTWFwLl9tYXBba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5jb250YWluc0tleSA9IGZ1bmN0aW9uIGNvbnRhaW5zS2V5KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzT3duUHJvcGVydHkoa2V5Lm5hbWUoKSkgJiYgdGhpcy5nZXQoa2V5KSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXBba2V5Lm5hbWUoKV07XG4gIH07XG4gIF9wcm90by5wdXQgPSBmdW5jdGlvbiBwdXQoa2V5LCB2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoa2V5LCB2YWwpO1xuICB9O1xuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgdGhpcy5fbWFwW2tleS5uYW1lKCldID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8ucmV0YWluQWxsID0gZnVuY3Rpb24gcmV0YWluQWxsKGtleUxpc3QpIHtcbiAgICB2YXIgbWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5TGlzdFtpXS5uYW1lKCk7XG4gICAgICBtYXBba2V5XSA9IHRoaXMuX21hcFtrZXldO1xuICAgIH1cbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgdmFyIGtleU5hbWUgPSBrZXkubmFtZSgpO1xuICAgIHZhciB2YWwgPSB0aGlzLl9tYXBba2V5TmFtZV07XG4gICAgdGhpcy5fbWFwW2tleU5hbWVdID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIF9wcm90by5rZXlTZXQgPSBmdW5jdGlvbiBrZXlTZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgfTtcbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5fbWFwID0ge307XG4gIH07XG4gIHJldHVybiBFbnVtTWFwO1xufSgpO1xuXG52YXIgUmVzb2x2ZXJTdHlsZSA9IGZ1bmN0aW9uIChfRW51bSkge1xuICBfaW5oZXJpdHNMb29zZShSZXNvbHZlclN0eWxlLCBfRW51bSk7XG4gIGZ1bmN0aW9uIFJlc29sdmVyU3R5bGUoKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICByZXR1cm4gUmVzb2x2ZXJTdHlsZTtcbn0oRW51bSk7XG5SZXNvbHZlclN0eWxlLlNUUklDVCA9IG5ldyBSZXNvbHZlclN0eWxlKCdTVFJJQ1QnKTtcblJlc29sdmVyU3R5bGUuU01BUlQgPSBuZXcgUmVzb2x2ZXJTdHlsZSgnU01BUlQnKTtcblJlc29sdmVyU3R5bGUuTEVOSUVOVCA9IG5ldyBSZXNvbHZlclN0eWxlKCdMRU5JRU5UJyk7XG5cbnZhciBUZW1wb3JhbCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShUZW1wb3JhbCwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuICBmdW5jdGlvbiBUZW1wb3JhbCgpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsQWNjZXNzb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBUZW1wb3JhbC5wcm90b3R5cGU7XG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc1N1cHBvcnRlZCcpO1xuICB9O1xuICBfcHJvdG8ubWludXMgPSBmdW5jdGlvbiBtaW51cyhhbW91bnQsIHVuaXQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW51c0Ftb3VudChhbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWludXNVbml0KGFtb3VudCwgdW5pdCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX21pbnVzQW1vdW50ID0gZnVuY3Rpb24gX21pbnVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShhbW91bnQsIFRlbXBvcmFsQW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmV0dXJuIGFtb3VudC5zdWJ0cmFjdEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5fbWludXNVbml0ID0gZnVuY3Rpb24gX21pbnVzVW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9TdWJ0cmFjdCwgJ2Ftb3VudFRvU3VidHJhY3QnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh1bml0LCBUZW1wb3JhbFVuaXQsICd1bml0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KC1hbW91bnRUb1N1YnRyYWN0LCB1bml0KTtcbiAgfTtcbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGFtb3VudCwgdW5pdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsdXNBbW91bnQoYW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KGFtb3VudCwgdW5pdCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX3BsdXNBbW91bnQgPSBmdW5jdGlvbiBfcGx1c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoYW1vdW50LCBUZW1wb3JhbEFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuYWRkVG8odGhpcyk7XG4gIH07XG4gIF9wcm90by5fcGx1c1VuaXQgPSBmdW5jdGlvbiBfcGx1c1VuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ19wbHVzVW5pdCcpO1xuICB9O1xuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRUZW1wb3JhbCwgdW5pdCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgndW50aWwnKTtcbiAgfTtcbiAgX3Byb3RvLndpdGggPSBmdW5jdGlvbiBfd2l0aChhZGp1c3Rlck9yRmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aEFkanVzdGVyKGFkanVzdGVyT3JGaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRmllbGQoYWRqdXN0ZXJPckZpZWxkLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX3dpdGhBZGp1c3RlciA9IGZ1bmN0aW9uIF93aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhZGp1c3RlciwgJ2FkanVzdGVyJyk7XG4gICAgYXNzZXJ0KHR5cGVvZiBhZGp1c3Rlci5hZGp1c3RJbnRvID09PSAnZnVuY3Rpb24nLCAnYWRqdXN0ZXIgbXVzdCBiZSBhIFRlbXBvcmFsQWRqdXN0ZXInLCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24pO1xuICAgIHJldHVybiBhZGp1c3Rlci5hZGp1c3RJbnRvKHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdfd2l0aEZpZWxkJyk7XG4gIH07XG4gIHJldHVybiBUZW1wb3JhbDtcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlKSB7XG4gIFRlbXBvcmFsLnByb3RvdHlwZVtTeW1ib2wudG9QcmltaXRpdmVdID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgICBpZiAoaGludCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgY29udmVyc2lvbiBmcm9tIFRlbXBvcmFsIHRvIGEgbnVtYmVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ1RvIGNvbXBhcmUgdXNlIHRoZSBtZXRob2RzIC5lcXVhbHMoKSwgLmNvbXBhcmVUbygpLCAuaXNCZWZvcmUoKSAnICsgJ29yIG9uZSB0aGF0IGlzIG1vcmUgc3VpdGFibGUgdG8geW91ciB1c2UgY2FzZS4nKTtcbiAgfTtcbn1cblxudmFyIENocm9ub0xvY2FsRGF0ZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hyb25vTG9jYWxEYXRlLCBfVGVtcG9yYWwpO1xuICBmdW5jdGlvbiBDaHJvbm9Mb2NhbERhdGUoKSB7XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IENocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGU7XG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpO1xuICAgIH0gZWxzZSBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNEYXRlQmFzZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hyb25vbG9neSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0LkRBWVM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KHRoaXMudG9FcG9jaERheSgpKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuRVBPQ0hfREFZLCB0aGlzLnRvRXBvY2hEYXkoKSk7XG4gIH07XG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZvcm1hdHRlciwgRGF0ZVRpbWVGb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcbiAgcmV0dXJuIENocm9ub0xvY2FsRGF0ZTtcbn0oVGVtcG9yYWwpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBTdHJpbmdVdGlsID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJpbmdVdGlsKCkge31cbiAgU3RyaW5nVXRpbC5zdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aCh0ZXh0LCBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHRleHQuaW5kZXhPZihwYXR0ZXJuKSA9PT0gMDtcbiAgfTtcbiAgU3RyaW5nVXRpbC5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKHRleHQpIHtcbiAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBoYXNoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2hyID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjtcbiAgICAgIGhhc2ggfD0gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNtaShoYXNoKTtcbiAgfTtcbiAgcmV0dXJuIFN0cmluZ1V0aWw7XG59KCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG52YXIgWm9uZUlkID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lSWQoKSB7fVxuICBab25lSWQuc3lzdGVtRGVmYXVsdCA9IGZ1bmN0aW9uIHN5c3RlbURlZmF1bHQoKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdub3Qgc3VwcG9ydGVkIG9wZXJhdGlvbicpO1xuICB9O1xuICBab25lSWQuZ2V0QXZhaWxhYmxlWm9uZUlkcyA9IGZ1bmN0aW9uIGdldEF2YWlsYWJsZVpvbmVJZHMoKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdub3Qgc3VwcG9ydGVkIG9wZXJhdGlvbicpO1xuICB9O1xuICBab25lSWQub2YgPSBmdW5jdGlvbiBvZih6b25lSWQpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJub3Qgc3VwcG9ydGVkIG9wZXJhdGlvblwiICsgem9uZUlkKTtcbiAgfTtcbiAgWm9uZUlkLm9mT2Zmc2V0ID0gZnVuY3Rpb24gb2ZPZmZzZXQocHJlZml4LCBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJub3Qgc3VwcG9ydGVkIG9wZXJhdGlvblwiICsgcHJlZml4ICsgb2Zmc2V0KTtcbiAgfTtcbiAgWm9uZUlkLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwibm90IHN1cHBvcnRlZCBvcGVyYXRpb25cIiArIHRlbXBvcmFsKTtcbiAgfTtcbiAgdmFyIF9wcm90byA9IFpvbmVJZC5wcm90b3R5cGU7XG4gIF9wcm90by5pZCA9IGZ1bmN0aW9uIGlkKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZUlkLmlkJyk7XG4gIH07XG4gIF9wcm90by5ydWxlcyA9IGZ1bmN0aW9uIHJ1bGVzKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZUlkLnJ1bGVzJyk7XG4gIH07XG4gIF9wcm90by5ub3JtYWxpemVkID0gZnVuY3Rpb24gbm9ybWFsaXplZCgpIHtcbiAgICB2YXIgcnVsZXMgPSB0aGlzLnJ1bGVzKCk7XG4gICAgaWYgKHJ1bGVzLmlzRml4ZWRPZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIHJ1bGVzLm9mZnNldChJbnN0YW50LkVQT0NIKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBab25lSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkKCkgPT09IG90aGVyLmlkKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIFN0cmluZ1V0aWwuaGFzaENvZGUodGhpcy5pZCgpKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQoKTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICByZXR1cm4gWm9uZUlkO1xufSgpO1xuXG52YXIgWm9uZVJ1bGVzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lUnVsZXMoKSB7fVxuICBab25lUnVsZXMub2YgPSBmdW5jdGlvbiBvZihvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXR1cm4gbmV3IEZpeGVkKG9mZnNldCk7XG4gIH07XG4gIHZhciBfcHJvdG8gPSBab25lUnVsZXMucHJvdG90eXBlO1xuICBfcHJvdG8uaXNGaXhlZE9mZnNldCA9IGZ1bmN0aW9uIGlzRml4ZWRPZmZzZXQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMuaXNGaXhlZE9mZnNldCcpO1xuICB9O1xuICBfcHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KGluc3RhbnRPckxvY2FsRGF0ZVRpbWUpIHtcbiAgICBpZiAoaW5zdGFudE9yTG9jYWxEYXRlVGltZSBpbnN0YW5jZW9mIEluc3RhbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldE9mSW5zdGFudChpbnN0YW50T3JMb2NhbERhdGVUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0T2ZMb2NhbERhdGVUaW1lKGluc3RhbnRPckxvY2FsRGF0ZVRpbWUpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLm9mZnNldE9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mZnNldE9mSW5zdGFudChpbnN0YW50KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMub2Zmc2V0SW5zdGFudCcpO1xuICB9O1xuICBfcHJvdG8ub2Zmc2V0T2ZFcG9jaE1pbGxpID0gZnVuY3Rpb24gb2Zmc2V0T2ZFcG9jaE1pbGxpKGVwb2NoTWlsbGkpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5vZmZzZXRPZkVwb2NoTWlsbGknKTtcbiAgfTtcbiAgX3Byb3RvLm9mZnNldE9mTG9jYWxEYXRlVGltZSA9IGZ1bmN0aW9uIG9mZnNldE9mTG9jYWxEYXRlVGltZShsb2NhbERhdGVUaW1lKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMub2Zmc2V0TG9jYWxEYXRlVGltZScpO1xuICB9O1xuICBfcHJvdG8udmFsaWRPZmZzZXRzID0gZnVuY3Rpb24gdmFsaWRPZmZzZXRzKGxvY2FsRGF0ZVRpbWUpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy52YWxpZE9mZnNldHMnKTtcbiAgfTtcbiAgX3Byb3RvLnRyYW5zaXRpb24gPSBmdW5jdGlvbiB0cmFuc2l0aW9uKGxvY2FsRGF0ZVRpbWUpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy50cmFuc2l0aW9uJyk7XG4gIH07XG4gIF9wcm90by5zdGFuZGFyZE9mZnNldCA9IGZ1bmN0aW9uIHN0YW5kYXJkT2Zmc2V0KGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5zdGFuZGFyZE9mZnNldCcpO1xuICB9O1xuICBfcHJvdG8uZGF5bGlnaHRTYXZpbmdzID0gZnVuY3Rpb24gZGF5bGlnaHRTYXZpbmdzKGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5kYXlsaWdodFNhdmluZ3MnKTtcbiAgfTtcbiAgX3Byb3RvLmlzRGF5bGlnaHRTYXZpbmdzID0gZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ3MoaW5zdGFudCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLmlzRGF5bGlnaHRTYXZpbmdzJyk7XG4gIH07XG4gIF9wcm90by5pc1ZhbGlkT2Zmc2V0ID0gZnVuY3Rpb24gaXNWYWxpZE9mZnNldChsb2NhbERhdGVUaW1lLCBvZmZzZXQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5pc1ZhbGlkT2Zmc2V0Jyk7XG4gIH07XG4gIF9wcm90by5uZXh0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIG5leHRUcmFuc2l0aW9uKGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5uZXh0VHJhbnNpdGlvbicpO1xuICB9O1xuICBfcHJvdG8ucHJldmlvdXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gcHJldmlvdXNUcmFuc2l0aW9uKGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5wcmV2aW91c1RyYW5zaXRpb24nKTtcbiAgfTtcbiAgX3Byb3RvLnRyYW5zaXRpb25zID0gZnVuY3Rpb24gdHJhbnNpdGlvbnMoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMudHJhbnNpdGlvbnMnKTtcbiAgfTtcbiAgX3Byb3RvLnRyYW5zaXRpb25SdWxlcyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25SdWxlcygpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy50cmFuc2l0aW9uUnVsZXMnKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMudG9TdHJpbmcnKTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICByZXR1cm4gWm9uZVJ1bGVzO1xufSgpO1xudmFyIEZpeGVkID0gZnVuY3Rpb24gKF9ab25lUnVsZXMpIHtcbiAgX2luaGVyaXRzTG9vc2UoRml4ZWQsIF9ab25lUnVsZXMpO1xuICBmdW5jdGlvbiBGaXhlZChvZmZzZXQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfWm9uZVJ1bGVzLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvMiA9IEZpeGVkLnByb3RvdHlwZTtcbiAgX3Byb3RvMi5pc0ZpeGVkT2Zmc2V0ID0gZnVuY3Rpb24gaXNGaXhlZE9mZnNldCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvMi5vZmZzZXRPZkluc3RhbnQgPSBmdW5jdGlvbiBvZmZzZXRPZkluc3RhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcbiAgX3Byb3RvMi5vZmZzZXRPZkVwb2NoTWlsbGkgPSBmdW5jdGlvbiBvZmZzZXRPZkVwb2NoTWlsbGkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcbiAgX3Byb3RvMi5vZmZzZXRPZkxvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiBvZmZzZXRPZkxvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcbiAgX3Byb3RvMi52YWxpZE9mZnNldHMgPSBmdW5jdGlvbiB2YWxpZE9mZnNldHMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl9vZmZzZXRdO1xuICB9O1xuICBfcHJvdG8yLnRyYW5zaXRpb24gPSBmdW5jdGlvbiB0cmFuc2l0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBfcHJvdG8yLnN0YW5kYXJkT2Zmc2V0ID0gZnVuY3Rpb24gc3RhbmRhcmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcbiAgX3Byb3RvMi5kYXlsaWdodFNhdmluZ3MgPSBmdW5jdGlvbiBkYXlsaWdodFNhdmluZ3MoKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLlpFUk87XG4gIH07XG4gIF9wcm90bzIuaXNEYXlsaWdodFNhdmluZ3MgPSBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5ncygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90bzIuaXNWYWxpZE9mZnNldCA9IGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQobG9jYWxEYXRlVGltZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldC5lcXVhbHMob2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvMi5uZXh0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIG5leHRUcmFuc2l0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBfcHJvdG8yLnByZXZpb3VzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHByZXZpb3VzVHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgX3Byb3RvMi50cmFuc2l0aW9ucyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25zKCkge1xuICAgIHJldHVybiBbXTtcbiAgfTtcbiAgX3Byb3RvMi50cmFuc2l0aW9uUnVsZXMgPSBmdW5jdGlvbiB0cmFuc2l0aW9uUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuICBfcHJvdG8yLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEZpeGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0LmVxdWFscyhvdGhlci5fb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiRml4ZWRSdWxlczpcIiArIHRoaXMuX29mZnNldC50b1N0cmluZygpO1xuICB9O1xuICByZXR1cm4gRml4ZWQ7XG59KFpvbmVSdWxlcyk7XG5cbnZhciBTRUNPTkRTX0NBQ0hFID0ge307XG52YXIgSURfQ0FDSEUgPSB7fTtcbnZhciBab25lT2Zmc2V0ID0gZnVuY3Rpb24gKF9ab25lSWQpIHtcbiAgX2luaGVyaXRzTG9vc2UoWm9uZU9mZnNldCwgX1pvbmVJZCk7XG4gIGZ1bmN0aW9uIFpvbmVPZmZzZXQodG90YWxTZWNvbmRzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX1pvbmVJZC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgWm9uZU9mZnNldC5fdmFsaWRhdGVUb3RhbFNlY29uZHModG90YWxTZWNvbmRzKTtcbiAgICBfdGhpcy5fdG90YWxTZWNvbmRzID0gTWF0aFV0aWwuc2FmZVRvSW50KHRvdGFsU2Vjb25kcyk7XG4gICAgX3RoaXMuX3J1bGVzID0gWm9uZVJ1bGVzLm9mKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5faWQgPSBab25lT2Zmc2V0Ll9idWlsZElkKHRvdGFsU2Vjb25kcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBab25lT2Zmc2V0LnByb3RvdHlwZTtcbiAgX3Byb3RvLnRvdGFsU2Vjb25kcyA9IGZ1bmN0aW9uIHRvdGFsU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxTZWNvbmRzO1xuICB9O1xuICBfcHJvdG8uaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH07XG4gIFpvbmVPZmZzZXQuX2J1aWxkSWQgPSBmdW5jdGlvbiBfYnVpbGRJZCh0b3RhbFNlY29uZHMpIHtcbiAgICBpZiAodG90YWxTZWNvbmRzID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1onO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWJzVG90YWxTZWNvbmRzID0gTWF0aC5hYnModG90YWxTZWNvbmRzKTtcbiAgICAgIHZhciBhYnNIb3VycyA9IE1hdGhVdGlsLmludERpdihhYnNUb3RhbFNlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKTtcbiAgICAgIHZhciBhYnNNaW51dGVzID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludERpdihhYnNUb3RhbFNlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUik7XG4gICAgICB2YXIgYnVmID0gXCJcIiArICh0b3RhbFNlY29uZHMgPCAwID8gJy0nIDogJysnKSArIChhYnNIb3VycyA8IDEwID8gJzAnIDogJycpICsgYWJzSG91cnMgKyAoYWJzTWludXRlcyA8IDEwID8gJzowJyA6ICc6JykgKyBhYnNNaW51dGVzO1xuICAgICAgdmFyIGFic1NlY29uZHMgPSBNYXRoVXRpbC5pbnRNb2QoYWJzVG90YWxTZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICAgIGlmIChhYnNTZWNvbmRzICE9PSAwKSB7XG4gICAgICAgIGJ1ZiArPSAoYWJzU2Vjb25kcyA8IDEwID8gJzowJyA6ICc6JykgKyBhYnNTZWNvbmRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gIH07XG4gIFpvbmVPZmZzZXQuX3ZhbGlkYXRlVG90YWxTZWNvbmRzID0gZnVuY3Rpb24gX3ZhbGlkYXRlVG90YWxTZWNvbmRzKHRvdGFsU2Vjb25kcykge1xuICAgIGlmIChNYXRoLmFicyh0b3RhbFNlY29uZHMpID4gWm9uZU9mZnNldC5NQVhfU0VDT05EUykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBub3QgaW4gdmFsaWQgcmFuZ2U6IC0xODowMCB0byArMTg6MDAnKTtcbiAgICB9XG4gIH07XG4gIFpvbmVPZmZzZXQuX3ZhbGlkYXRlID0gZnVuY3Rpb24gX3ZhbGlkYXRlKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgaWYgKGhvdXJzIDwgLTE4IHx8IGhvdXJzID4gMTgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlpvbmUgb2Zmc2V0IGhvdXJzIG5vdCBpbiB2YWxpZCByYW5nZTogdmFsdWUgXCIgKyBob3VycyArIFwiIGlzIG5vdCBpbiB0aGUgcmFuZ2UgLTE4IHRvIDE4XCIpO1xuICAgIH1cbiAgICBpZiAoaG91cnMgPiAwKSB7XG4gICAgICBpZiAobWludXRlcyA8IDAgfHwgc2Vjb25kcyA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBtaW51dGVzIGFuZCBzZWNvbmRzIG11c3QgYmUgcG9zaXRpdmUgYmVjYXVzZSBob3VycyBpcyBwb3NpdGl2ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG91cnMgPCAwKSB7XG4gICAgICBpZiAobWludXRlcyA+IDAgfHwgc2Vjb25kcyA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBtaW51dGVzIGFuZCBzZWNvbmRzIG11c3QgYmUgbmVnYXRpdmUgYmVjYXVzZSBob3VycyBpcyBuZWdhdGl2ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWludXRlcyA+IDAgJiYgc2Vjb25kcyA8IDAgfHwgbWludXRlcyA8IDAgJiYgc2Vjb25kcyA+IDApIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignWm9uZSBvZmZzZXQgbWludXRlcyBhbmQgc2Vjb25kcyBtdXN0IGhhdmUgdGhlIHNhbWUgc2lnbicpO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMobWludXRlcykgPiA1OSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiWm9uZSBvZmZzZXQgbWludXRlcyBub3QgaW4gdmFsaWQgcmFuZ2U6IGFicyh2YWx1ZSkgXCIgKyBNYXRoLmFicyhtaW51dGVzKSArIFwiIGlzIG5vdCBpbiB0aGUgcmFuZ2UgMCB0byA1OVwiKTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHNlY29uZHMpID4gNTkpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlpvbmUgb2Zmc2V0IHNlY29uZHMgbm90IGluIHZhbGlkIHJhbmdlOiBhYnModmFsdWUpIFwiICsgTWF0aC5hYnMoc2Vjb25kcykgKyBcIiBpcyBub3QgaW4gdGhlIHJhbmdlIDAgdG8gNTlcIik7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhob3VycykgPT09IDE4ICYmIChNYXRoLmFicyhtaW51dGVzKSA+IDAgfHwgTWF0aC5hYnMoc2Vjb25kcykgPiAwKSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBub3QgaW4gdmFsaWQgcmFuZ2U6IC0xODowMCB0byArMTg6MDAnKTtcbiAgICB9XG4gIH07XG4gIFpvbmVPZmZzZXQub2YgPSBmdW5jdGlvbiBvZihvZmZzZXRJZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldElkLCAnb2Zmc2V0SWQnKTtcbiAgICB2YXIgb2Zmc2V0ID0gSURfQ0FDSEVbb2Zmc2V0SWRdO1xuICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgdmFyIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzO1xuICAgIHN3aXRjaCAob2Zmc2V0SWQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG9mZnNldElkID0gb2Zmc2V0SWRbMF0gKyBcIjBcIiArIG9mZnNldElkWzFdO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBob3VycyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAxLCBmYWxzZSk7XG4gICAgICAgIG1pbnV0ZXMgPSAwO1xuICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIGhvdXJzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDEsIGZhbHNlKTtcbiAgICAgICAgbWludXRlcyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAzLCBmYWxzZSk7XG4gICAgICAgIHNlY29uZHMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgaG91cnMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgMSwgZmFsc2UpO1xuICAgICAgICBtaW51dGVzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDQsIHRydWUpO1xuICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc6XG4gICAgICAgIGhvdXJzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDEsIGZhbHNlKTtcbiAgICAgICAgbWludXRlcyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAzLCBmYWxzZSk7XG4gICAgICAgIHNlY29uZHMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgNSwgZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgaG91cnMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgMSwgZmFsc2UpO1xuICAgICAgICBtaW51dGVzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDQsIHRydWUpO1xuICAgICAgICBzZWNvbmRzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDcsIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkludmFsaWQgSUQgZm9yIFpvbmVPZmZzZXQsIGludmFsaWQgZm9ybWF0OiBcIiArIG9mZnNldElkKTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gb2Zmc2V0SWRbMF07XG4gICAgaWYgKGZpcnN0ICE9PSAnKycgJiYgZmlyc3QgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCBJRCBmb3IgWm9uZU9mZnNldCwgcGx1cy9taW51cyBub3QgZm91bmQgd2hlbiBleHBlY3RlZDogXCIgKyBvZmZzZXRJZCk7XG4gICAgfVxuICAgIGlmIChmaXJzdCA9PT0gJy0nKSB7XG4gICAgICByZXR1cm4gWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMoLWhvdXJzLCAtbWludXRlcywgLXNlY29uZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuICAgIH1cbiAgfTtcbiAgWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIgPSBmdW5jdGlvbiBfcGFyc2VOdW1iZXIob2Zmc2V0SWQsIHBvcywgcHJlY2VkZWRCeUNvbG9uKSB7XG4gICAgaWYgKHByZWNlZGVkQnlDb2xvbiAmJiBvZmZzZXRJZFtwb3MgLSAxXSAhPT0gJzonKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbnZhbGlkIElEIGZvciBab25lT2Zmc2V0LCBjb2xvbiBub3QgZm91bmQgd2hlbiBleHBlY3RlZDogXCIgKyBvZmZzZXRJZCk7XG4gICAgfVxuICAgIHZhciBjaDEgPSBvZmZzZXRJZFtwb3NdO1xuICAgIHZhciBjaDIgPSBvZmZzZXRJZFtwb3MgKyAxXTtcbiAgICBpZiAoY2gxIDwgJzAnIHx8IGNoMSA+ICc5JyB8fCBjaDIgPCAnMCcgfHwgY2gyID4gJzknKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbnZhbGlkIElEIGZvciBab25lT2Zmc2V0LCBub24gbnVtZXJpYyBjaGFyYWN0ZXJzIGZvdW5kOiBcIiArIG9mZnNldElkKTtcbiAgICB9XG4gICAgcmV0dXJuIChjaDEuY2hhckNvZGVBdCgwKSAtIDQ4KSAqIDEwICsgKGNoMi5jaGFyQ29kZUF0KDApIC0gNDgpO1xuICB9O1xuICBab25lT2Zmc2V0Lm9mSG91cnMgPSBmdW5jdGlvbiBvZkhvdXJzKGhvdXJzKSB7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZIb3Vyc01pbnV0ZXNTZWNvbmRzKGhvdXJzLCAwLCAwKTtcbiAgfTtcbiAgWm9uZU9mZnNldC5vZkhvdXJzTWludXRlcyA9IGZ1bmN0aW9uIG9mSG91cnNNaW51dGVzKGhvdXJzLCBtaW51dGVzKSB7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZIb3Vyc01pbnV0ZXNTZWNvbmRzKGhvdXJzLCBtaW51dGVzLCAwKTtcbiAgfTtcbiAgWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMgPSBmdW5jdGlvbiBvZkhvdXJzTWludXRlc1NlY29uZHMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICBab25lT2Zmc2V0Ll92YWxpZGF0ZShob3VycywgbWludXRlcywgc2Vjb25kcyk7XG4gICAgdmFyIHRvdGFsU2Vjb25kcyA9IGhvdXJzICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIgKyBtaW51dGVzICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSArIHNlY29uZHM7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHModG90YWxTZWNvbmRzKTtcbiAgfTtcbiAgWm9uZU9mZnNldC5vZlRvdGFsTWludXRlcyA9IGZ1bmN0aW9uIG9mVG90YWxNaW51dGVzKHRvdGFsTWludXRlcykge1xuICAgIHZhciB0b3RhbFNlY29uZHMgPSB0b3RhbE1pbnV0ZXMgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFO1xuICAgIHJldHVybiBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKHRvdGFsU2Vjb25kcyk7XG4gIH07XG4gIFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHMgPSBmdW5jdGlvbiBvZlRvdGFsU2Vjb25kcyh0b3RhbFNlY29uZHMpIHtcbiAgICBpZiAodG90YWxTZWNvbmRzICUgKDE1ICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSkgPT09IDApIHtcbiAgICAgIHZhciB0b3RhbFNlY3MgPSB0b3RhbFNlY29uZHM7XG4gICAgICB2YXIgcmVzdWx0ID0gU0VDT05EU19DQUNIRVt0b3RhbFNlY3NdO1xuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBab25lT2Zmc2V0KHRvdGFsU2Vjb25kcyk7XG4gICAgICAgIFNFQ09ORFNfQ0FDSEVbdG90YWxTZWNzXSA9IHJlc3VsdDtcbiAgICAgICAgSURfQ0FDSEVbcmVzdWx0LmlkKCldID0gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBab25lT2Zmc2V0KHRvdGFsU2Vjb25kcyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucnVsZXMgPSBmdW5jdGlvbiBydWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVsZXM7XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsU2Vjb25kcztcbiAgICB9IGVsc2UgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3F1ZXJ5LnF1ZXJ5RnJvbSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMsIHRoaXMuX3RvdGFsU2Vjb25kcyk7XG4gIH07XG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIG90aGVyLl90b3RhbFNlY29uZHMgLSB0aGlzLl90b3RhbFNlY29uZHM7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBab25lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG90YWxTZWNvbmRzID09PSBvYmouX3RvdGFsU2Vjb25kcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxTZWNvbmRzO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH07XG4gIHJldHVybiBab25lT2Zmc2V0O1xufShab25lSWQpO1xuZnVuY3Rpb24gX2luaXQkZygpIHtcbiAgWm9uZU9mZnNldC5NQVhfU0VDT05EUyA9IDE4ICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVI7XG4gIFpvbmVPZmZzZXQuVVRDID0gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcygwKTtcbiAgWm9uZU9mZnNldC5NSU4gPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKC1ab25lT2Zmc2V0Lk1BWF9TRUNPTkRTKTtcbiAgWm9uZU9mZnNldC5NQVggPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKFpvbmVPZmZzZXQuTUFYX1NFQ09ORFMpO1xufVxuXG52YXIgRGF0ZVRpbWVCdWlsZGVyID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFjY2Vzc29yKSB7XG4gIF9pbmhlcml0c0xvb3NlKERhdGVUaW1lQnVpbGRlciwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuICBEYXRlVGltZUJ1aWxkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGZpZWxkLCB2YWx1ZSkge1xuICAgIHZhciBkdGIgPSBuZXcgRGF0ZVRpbWVCdWlsZGVyKCk7XG4gICAgZHRiLl9hZGRGaWVsZFZhbHVlKGZpZWxkLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGR0YjtcbiAgfTtcbiAgZnVuY3Rpb24gRGF0ZVRpbWVCdWlsZGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9UZW1wb3JhbEFjY2Vzc29yLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5maWVsZFZhbHVlcyA9IG5ldyBFbnVtTWFwKCk7XG4gICAgX3RoaXMuY2hyb25vID0gbnVsbDtcbiAgICBfdGhpcy56b25lID0gbnVsbDtcbiAgICBfdGhpcy5kYXRlID0gbnVsbDtcbiAgICBfdGhpcy50aW1lID0gbnVsbDtcbiAgICBfdGhpcy5sZWFwU2Vjb25kID0gZmFsc2U7XG4gICAgX3RoaXMuZXhjZXNzRGF5cyA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBEYXRlVGltZUJ1aWxkZXIucHJvdG90eXBlO1xuICBfcHJvdG8uZ2V0RmllbGRWYWx1ZTAgPSBmdW5jdGlvbiBnZXRGaWVsZFZhbHVlMChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkVmFsdWVzLmdldChmaWVsZCk7XG4gIH07XG4gIF9wcm90by5fYWRkRmllbGRWYWx1ZSA9IGZ1bmN0aW9uIF9hZGRGaWVsZFZhbHVlKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICB2YXIgb2xkID0gdGhpcy5nZXRGaWVsZFZhbHVlMChmaWVsZCk7XG4gICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkNvbmZsaWN0IGZvdW5kOiBcIiArIGZpZWxkICsgXCIgXCIgKyBvbGQgKyBcIiBkaWZmZXJzIGZyb20gXCIgKyBmaWVsZCArIFwiIFwiICsgdmFsdWUgKyBcIjogXCIgKyB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1dEZpZWxkVmFsdWUwKGZpZWxkLCB2YWx1ZSk7XG4gIH07XG4gIF9wcm90by5fcHV0RmllbGRWYWx1ZTAgPSBmdW5jdGlvbiBfcHV0RmllbGRWYWx1ZTAoZmllbGQsIHZhbHVlKSB7XG4gICAgdGhpcy5maWVsZFZhbHVlcy5wdXQoZmllbGQsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHJlc29sdmVyU3R5bGUsIHJlc29sdmVyRmllbGRzKSB7XG4gICAgaWYgKHJlc29sdmVyRmllbGRzICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZmllbGRWYWx1ZXMucmV0YWluQWxsKHJlc29sdmVyRmllbGRzKTtcbiAgICB9XG4gICAgdGhpcy5fbWVyZ2VEYXRlKHJlc29sdmVyU3R5bGUpO1xuICAgIHRoaXMuX21lcmdlVGltZShyZXNvbHZlclN0eWxlKTtcbiAgICB0aGlzLl9yZXNvbHZlVGltZUluZmVyWmVyb2VzKHJlc29sdmVyU3R5bGUpO1xuICAgIGlmICh0aGlzLmV4Y2Vzc0RheXMgIT0gbnVsbCAmJiB0aGlzLmV4Y2Vzc0RheXMuaXNaZXJvKCkgPT09IGZhbHNlICYmIHRoaXMuZGF0ZSAhPSBudWxsICYmIHRoaXMudGltZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRhdGUgPSB0aGlzLmRhdGUucGx1cyh0aGlzLmV4Y2Vzc0RheXMpO1xuICAgICAgdGhpcy5leGNlc3NEYXlzID0gUGVyaW9kLlpFUk87XG4gICAgfVxuICAgIHRoaXMuX3Jlc29sdmVJbnN0YW50KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5fbWVyZ2VEYXRlID0gZnVuY3Rpb24gX21lcmdlRGF0ZShyZXNvbHZlclN0eWxlKSB7XG4gICAgdGhpcy5fY2hlY2tEYXRlKElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UucmVzb2x2ZURhdGUodGhpcy5maWVsZFZhbHVlcywgcmVzb2x2ZXJTdHlsZSkpO1xuICB9O1xuICBfcHJvdG8uX2NoZWNrRGF0ZSA9IGZ1bmN0aW9uIF9jaGVja0RhdGUoZGF0ZSkge1xuICAgIGlmIChkYXRlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX2FkZE9iamVjdChkYXRlKTtcbiAgICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiB0aGlzLmZpZWxkVmFsdWVzLmtleVNldCgpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IENocm9ub0ZpZWxkLmJ5TmFtZShmaWVsZE5hbWUpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5nZXQoZmllbGQpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5pc0RhdGVCYXNlZCgpKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwxID0gdm9pZCAwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbDEgPSBkYXRlLmdldExvbmcoZmllbGQpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIERhdGVUaW1lRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciB2YWwyID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoZmllbGQpO1xuICAgICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkNvbmZsaWN0IGZvdW5kOiBGaWVsZCBcIiArIGZpZWxkICsgXCIgXCIgKyB2YWwxICsgXCIgZGlmZmVycyBmcm9tIFwiICsgZmllbGQgKyBcIiBcIiArIHZhbDIgKyBcIiBkZXJpdmVkIGZyb20gXCIgKyBkYXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLl9tZXJnZVRpbWUgPSBmdW5jdGlvbiBfbWVyZ2VUaW1lKHJlc29sdmVyU3R5bGUpIHtcbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWSkpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZKTtcbiAgICAgIGlmIChyZXNvbHZlclN0eWxlICE9PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU01BUlQgJiYgY2ggPT09IDApIDsgZWxzZSB7XG4gICAgICAgICAgQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9EQVkuY2hlY2tWYWxpZFZhbHVlKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSwgY2ggPT09IDI0ID8gMCA6IGNoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNKSkge1xuICAgICAgdmFyIF9jaCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfQU1QTSk7XG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNNQVJUICYmIF9jaCA9PT0gMCkgOyBlbHNlIHtcbiAgICAgICAgICBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE0uY2hlY2tWYWxpZFZhbHVlKF9jaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNLCBfY2ggPT09IDEyID8gMCA6IF9jaCk7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlclN0eWxlICE9PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkFNUE1fT0ZfREFZKSkge1xuICAgICAgICBDaHJvbm9GaWVsZC5BTVBNX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUodGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSkpIHtcbiAgICAgICAgQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNLmNoZWNrVmFsaWRWYWx1ZSh0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNKSkge1xuICAgICAgdmFyIGFwID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpO1xuICAgICAgdmFyIGhhcCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSk7XG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLCBhcCAqIDEyICsgaGFwKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTkFOT19PRl9EQVkpKSB7XG4gICAgICB2YXIgbm9kID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTkFOT19PRl9EQVkpO1xuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobm9kKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSwgTWF0aFV0aWwuaW50RGl2KG5vZCwgMTAwMDAwMDAwMCkpO1xuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCwgTWF0aFV0aWwuaW50TW9kKG5vZCwgMTAwMDAwMDAwMCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9EQVkpKSB7XG4gICAgICB2YXIgY29kID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfREFZKTtcbiAgICAgIGlmIChyZXNvbHZlclN0eWxlICE9PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgQ2hyb25vRmllbGQuTUlDUk9fT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShjb2QpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYoY29kLCAxMDAwMDAwKSk7XG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCwgTWF0aFV0aWwuaW50TW9kKGNvZCwgMTAwMDAwMCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVkpKSB7XG4gICAgICB2YXIgbG9kID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZKTtcbiAgICAgIGlmIChyZXNvbHZlclN0eWxlICE9PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShsb2QpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYobG9kLCAxMDAwKSk7XG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORCwgTWF0aFV0aWwuaW50TW9kKGxvZCwgMTAwMCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZKSkge1xuICAgICAgdmFyIHNvZCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLlNFQ09ORF9PRl9EQVkpO1xuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShzb2QpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSwgTWF0aFV0aWwuaW50RGl2KHNvZCwgMzYwMCkpO1xuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiwgTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludERpdihzb2QsIDYwKSwgNjApKTtcbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSwgTWF0aFV0aWwuaW50TW9kKHNvZCwgNjApKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTUlOVVRFX09GX0RBWSkpIHtcbiAgICAgIHZhciBtb2QgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZKTtcbiAgICAgIGlmIChyZXNvbHZlclN0eWxlICE9PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgQ2hyb25vRmllbGQuTUlOVVRFX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobW9kKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIE1hdGhVdGlsLmludERpdihtb2QsIDYwKSk7XG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSLCBNYXRoVXRpbC5pbnRNb2QobW9kLCA2MCkpO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORC5jaGVja1ZhbGlkVmFsdWUodGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORC5jaGVja1ZhbGlkVmFsdWUodGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORCkgJiYgdGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpKSB7XG4gICAgICB2YXIgbG9zID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKTtcbiAgICAgIHZhciBjb3MgPSB0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpO1xuICAgICAgdGhpcy5fcHV0RmllbGRWYWx1ZTAoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05ELCBsb3MgKiAxMDAwICsgTWF0aFV0aWwuaW50TW9kKGNvcywgMTAwMCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB2YXIgbm9zID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuICAgICAgdGhpcy5fcHV0RmllbGRWYWx1ZTAoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05ELCBNYXRoVXRpbC5pbnREaXYobm9zLCAxMDAwKSk7XG4gICAgICB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB2YXIgX25vcyA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICAgIHRoaXMuX3B1dEZpZWxkVmFsdWUwKENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORCwgTWF0aFV0aWwuaW50RGl2KF9ub3MsIDEwMDAwMDApKTtcbiAgICAgIHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCkpIHtcbiAgICAgIHZhciBfY29zID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKTtcbiAgICAgIHRoaXMuX3B1dEZpZWxkVmFsdWUwKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCBfY29zICogMTAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORCkpIHtcbiAgICAgIHZhciBfbG9zID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKTtcbiAgICAgIHRoaXMuX3B1dEZpZWxkVmFsdWUwKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCBfbG9zICogMTAwMDAwMCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX3Jlc29sdmVUaW1lSW5mZXJaZXJvZXMgPSBmdW5jdGlvbiBfcmVzb2x2ZVRpbWVJbmZlclplcm9lcyhyZXNvbHZlclN0eWxlKSB7XG4gICAgdmFyIGhvZCA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZKTtcbiAgICB2YXIgbW9oID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIpO1xuICAgIHZhciBzb20gPSB0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFKTtcbiAgICB2YXIgbm9zID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuICAgIGlmIChob2QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9oID09IG51bGwgJiYgKHNvbSAhPSBudWxsIHx8IG5vcyAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9oICE9IG51bGwgJiYgc29tID09IG51bGwgJiYgbm9zICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgaWYgKGhvZCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNNQVJUICYmIGhvZCA9PT0gMjQgJiYgKG1vaCA9PSBudWxsIHx8IG1vaCA9PT0gMCkgJiYgKHNvbSA9PSBudWxsIHx8IHNvbSA9PT0gMCkgJiYgKG5vcyA9PSBudWxsIHx8IG5vcyA9PT0gMCkpIHtcbiAgICAgICAgICBob2QgPSAwO1xuICAgICAgICAgIHRoaXMuZXhjZXNzRGF5cyA9IFBlcmlvZC5vZkRheXMoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvZFZhbCA9IENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLmNoZWNrVmFsaWRJbnRWYWx1ZShob2QpO1xuICAgICAgICBpZiAobW9oICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgbW9oVmFsID0gQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIuY2hlY2tWYWxpZEludFZhbHVlKG1vaCk7XG4gICAgICAgICAgaWYgKHNvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc29tVmFsID0gQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURS5jaGVja1ZhbGlkSW50VmFsdWUoc29tKTtcbiAgICAgICAgICAgIGlmIChub3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgbm9zVmFsID0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZEludFZhbHVlKG5vcyk7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZE9iamVjdChMb2NhbFRpbWUub2YoaG9kVmFsLCBtb2hWYWwsIHNvbVZhbCwgbm9zVmFsKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mKGhvZFZhbCwgbW9oVmFsLCBzb21WYWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZE9iamVjdChMb2NhbFRpbWUub2YoaG9kVmFsLCBtb2hWYWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNvbSA9PSBudWxsICYmIG5vcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mKGhvZFZhbCwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaG9kICE9IG51bGwpIHtcbiAgICAgICAgdmFyIF9ob2RWYWwgPSBob2Q7XG4gICAgICAgIGlmIChtb2ggIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5vcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG90YWxOYW5vcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShfaG9kVmFsLCAzNjAwMDAwMDAwMDAwKTtcbiAgICAgICAgICAgIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlQWRkKHRvdGFsTmFub3MsIE1hdGhVdGlsLnNhZmVNdWx0aXBseShtb2gsIDYwMDAwMDAwMDAwKSk7XG4gICAgICAgICAgICB0b3RhbE5hbm9zID0gTWF0aFV0aWwuc2FmZUFkZCh0b3RhbE5hbm9zLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoc29tLCAxMDAwMDAwMDAwKSk7XG4gICAgICAgICAgICB0b3RhbE5hbm9zID0gTWF0aFV0aWwuc2FmZUFkZCh0b3RhbE5hbm9zLCBub3MpO1xuICAgICAgICAgICAgdmFyIGV4Y2Vzc0RheXMgPSBNYXRoVXRpbC5mbG9vckRpdih0b3RhbE5hbm9zLCA4NjQwMDAwMDAwMDAwMCk7XG4gICAgICAgICAgICB2YXIgbm9kID0gTWF0aFV0aWwuZmxvb3JNb2QodG90YWxOYW5vcywgODY0MDAwMDAwMDAwMDApO1xuICAgICAgICAgICAgdGhpcy5fYWRkT2JqZWN0KExvY2FsVGltZS5vZk5hbm9PZkRheShub2QpKTtcbiAgICAgICAgICAgIHRoaXMuZXhjZXNzRGF5cyA9IFBlcmlvZC5vZkRheXMoZXhjZXNzRGF5cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3RhbFNlY3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoX2hvZFZhbCwgMzYwMCk7XG4gICAgICAgICAgICB0b3RhbFNlY3MgPSBNYXRoVXRpbC5zYWZlQWRkKHRvdGFsU2VjcywgTWF0aFV0aWwuc2FmZU11bHRpcGx5KG1vaCwgNjApKTtcbiAgICAgICAgICAgIHZhciBfZXhjZXNzRGF5cyA9IE1hdGhVdGlsLmZsb29yRGl2KHRvdGFsU2VjcywgODY0MDApO1xuICAgICAgICAgICAgdmFyIHNvZCA9IE1hdGhVdGlsLmZsb29yTW9kKHRvdGFsU2VjcywgODY0MDApO1xuICAgICAgICAgICAgdGhpcy5fYWRkT2JqZWN0KExvY2FsVGltZS5vZlNlY29uZE9mRGF5KHNvZCkpO1xuICAgICAgICAgICAgdGhpcy5leGNlc3NEYXlzID0gUGVyaW9kLm9mRGF5cyhfZXhjZXNzRGF5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZXhjZXNzRGF5czIgPSBNYXRoVXRpbC5zYWZlVG9JbnQoTWF0aFV0aWwuZmxvb3JEaXYoX2hvZFZhbCwgMjQpKTtcbiAgICAgICAgICBfaG9kVmFsID0gTWF0aFV0aWwuZmxvb3JNb2QoX2hvZFZhbCwgMjQpO1xuICAgICAgICAgIHRoaXMuX2FkZE9iamVjdChMb2NhbFRpbWUub2YoX2hvZFZhbCwgMCkpO1xuICAgICAgICAgIHRoaXMuZXhjZXNzRGF5cyA9IFBlcmlvZC5vZkRheXMoX2V4Y2Vzc0RheXMyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSk7XG4gICAgdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIpO1xuICAgIHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUpO1xuICAgIHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgfTtcbiAgX3Byb3RvLl9hZGRPYmplY3QgPSBmdW5jdGlvbiBfYWRkT2JqZWN0KGRhdGVPclRpbWUpIHtcbiAgICBpZiAoZGF0ZU9yVGltZSBpbnN0YW5jZW9mIENocm9ub0xvY2FsRGF0ZSkge1xuICAgICAgdGhpcy5kYXRlID0gZGF0ZU9yVGltZTtcbiAgICB9IGVsc2UgaWYgKGRhdGVPclRpbWUgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHRoaXMudGltZSA9IGRhdGVPclRpbWU7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX3Jlc29sdmVJbnN0YW50ID0gZnVuY3Rpb24gX3Jlc29sdmVJbnN0YW50KCkge1xuICAgIGlmICh0aGlzLmRhdGUgIT0gbnVsbCAmJiB0aGlzLnRpbWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG9mZnNldFNlY3MgPSB0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUyk7XG4gICAgICBpZiAob2Zmc2V0U2VjcyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKG9mZnNldFNlY3MpO1xuICAgICAgICB2YXIgaW5zdGFudCA9IHRoaXMuZGF0ZS5hdFRpbWUodGhpcy50aW1lKS5hdFpvbmUob2Zmc2V0KS5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgICAgIHRoaXMuZmllbGRWYWx1ZXMucHV0KENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUywgaW5zdGFudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBfaW5zdGFudCA9IHRoaXMuZGF0ZS5hdFRpbWUodGhpcy50aW1lKS5hdFpvbmUodGhpcy56b25lKS5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgICAgIHRoaXMuZmllbGRWYWx1ZXMucHV0KENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUywgX2luc3RhbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmJ1aWxkID0gZnVuY3Rpb24gYnVpbGQodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnF1ZXJ5RnJvbSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShmaWVsZCkgJiYgdGhpcy5maWVsZFZhbHVlcy5nZXQoZmllbGQpICE9PSB1bmRlZmluZWQgfHwgdGhpcy5kYXRlICE9IG51bGwgJiYgdGhpcy5kYXRlLmlzU3VwcG9ydGVkKGZpZWxkKSB8fCB0aGlzLnRpbWUgIT0gbnVsbCAmJiB0aGlzLnRpbWUuaXNTdXBwb3J0ZWQoZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRGaWVsZFZhbHVlMChmaWVsZCk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmRhdGUgIT0gbnVsbCAmJiB0aGlzLmRhdGUuaXNTdXBwb3J0ZWQoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50aW1lICE9IG51bGwgJiYgdGhpcy50aW1lLmlzU3VwcG9ydGVkKGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lLmdldExvbmcoZmllbGQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiRmllbGQgbm90IGZvdW5kOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmU7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNocm9ubztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlICE9IG51bGwgPyBMb2NhbERhdGUuZnJvbSh0aGlzLmRhdGUpIDogbnVsbDtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpKSB7XG4gICAgICByZXR1cm4gX3F1ZXJ5LnF1ZXJ5RnJvbSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG4gIHJldHVybiBEYXRlVGltZUJ1aWxkZXI7XG59KFRlbXBvcmFsQWNjZXNzb3IpO1xuXG52YXIgRGF0ZVRpbWVQYXJzZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGVUaW1lUGFyc2VDb250ZXh0KCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRGF0ZVRpbWVQYXJzZUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29uc3RydWN0b3JTZWxmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbnN0cnVjdG9yRm9ybWF0dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnN0cnVjdG9yUGFyYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdGhpcy5fY2FzZVNlbnNpdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fc3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXJzZWQgPSBbbmV3IFBhcnNlZCh0aGlzKV07XG4gIH1cbiAgdmFyIF9wcm90byA9IERhdGVUaW1lUGFyc2VDb250ZXh0LnByb3RvdHlwZTtcbiAgX3Byb3RvLl9jb25zdHJ1Y3RvclBhcmFtID0gZnVuY3Rpb24gX2NvbnN0cnVjdG9yUGFyYW0obG9jYWxlLCBzeW1ib2xzLCBjaHJvbm9sb2d5KSB7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuX3N5bWJvbHMgPSBzeW1ib2xzO1xuICAgIHRoaXMuX292ZXJyaWRlQ2hyb25vbG9neSA9IGNocm9ub2xvZ3k7XG4gIH07XG4gIF9wcm90by5fY29uc3RydWN0b3JGb3JtYXR0ZXIgPSBmdW5jdGlvbiBfY29uc3RydWN0b3JGb3JtYXR0ZXIoZm9ybWF0dGVyKSB7XG4gICAgdGhpcy5fbG9jYWxlID0gZm9ybWF0dGVyLmxvY2FsZSgpO1xuICAgIHRoaXMuX3N5bWJvbHMgPSBmb3JtYXR0ZXIuZGVjaW1hbFN0eWxlKCk7XG4gICAgdGhpcy5fb3ZlcnJpZGVDaHJvbm9sb2d5ID0gZm9ybWF0dGVyLmNocm9ub2xvZ3koKTtcbiAgfTtcbiAgX3Byb3RvLl9jb25zdHJ1Y3RvclNlbGYgPSBmdW5jdGlvbiBfY29uc3RydWN0b3JTZWxmKG90aGVyKSB7XG4gICAgdGhpcy5fbG9jYWxlID0gb3RoZXIuX2xvY2FsZTtcbiAgICB0aGlzLl9zeW1ib2xzID0gb3RoZXIuX3N5bWJvbHM7XG4gICAgdGhpcy5fb3ZlcnJpZGVDaHJvbm9sb2d5ID0gb3RoZXIuX292ZXJyaWRlQ2hyb25vbG9neTtcbiAgICB0aGlzLl9vdmVycmlkZVpvbmUgPSBvdGhlci5fb3ZlcnJpZGVab25lO1xuICAgIHRoaXMuX2Nhc2VTZW5zaXRpdmUgPSBvdGhlci5fY2FzZVNlbnNpdGl2ZTtcbiAgICB0aGlzLl9zdHJpY3QgPSBvdGhlci5fc3RyaWN0O1xuICAgIHRoaXMuX3BhcnNlZCA9IFtuZXcgUGFyc2VkKHRoaXMpXTtcbiAgfTtcbiAgX3Byb3RvLmNvcHkgPSBmdW5jdGlvbiBjb3B5KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVQYXJzZUNvbnRleHQodGhpcyk7XG4gIH07XG4gIF9wcm90by5zeW1ib2xzID0gZnVuY3Rpb24gc3ltYm9scygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ltYm9scztcbiAgfTtcbiAgX3Byb3RvLmlzU3RyaWN0ID0gZnVuY3Rpb24gaXNTdHJpY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmljdDtcbiAgfTtcbiAgX3Byb3RvLnNldFN0cmljdCA9IGZ1bmN0aW9uIHNldFN0cmljdChzdHJpY3QpIHtcbiAgICB0aGlzLl9zdHJpY3QgPSBzdHJpY3Q7XG4gIH07XG4gIF9wcm90by5sb2NhbGUgPSBmdW5jdGlvbiBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgfTtcbiAgX3Byb3RvLnNldExvY2FsZSA9IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gIH07XG4gIF9wcm90by5zdGFydE9wdGlvbmFsID0gZnVuY3Rpb24gc3RhcnRPcHRpb25hbCgpIHtcbiAgICB0aGlzLl9wYXJzZWQucHVzaCh0aGlzLmN1cnJlbnRQYXJzZWQoKS5jb3B5KCkpO1xuICB9O1xuICBfcHJvdG8uZW5kT3B0aW9uYWwgPSBmdW5jdGlvbiBlbmRPcHRpb25hbChzdWNjZXNzZnVsKSB7XG4gICAgaWYgKHN1Y2Nlc3NmdWwpIHtcbiAgICAgIHRoaXMuX3BhcnNlZC5zcGxpY2UodGhpcy5fcGFyc2VkLmxlbmd0aCAtIDIsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJzZWQuc3BsaWNlKHRoaXMuX3BhcnNlZC5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5pc0Nhc2VTZW5zaXRpdmUgPSBmdW5jdGlvbiBpc0Nhc2VTZW5zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc2VTZW5zaXRpdmU7XG4gIH07XG4gIF9wcm90by5zZXRDYXNlU2Vuc2l0aXZlID0gZnVuY3Rpb24gc2V0Q2FzZVNlbnNpdGl2ZShjYXNlU2Vuc2l0aXZlKSB7XG4gICAgdGhpcy5fY2FzZVNlbnNpdGl2ZSA9IGNhc2VTZW5zaXRpdmU7XG4gIH07XG4gIF9wcm90by5zdWJTZXF1ZW5jZUVxdWFscyA9IGZ1bmN0aW9uIHN1YlNlcXVlbmNlRXF1YWxzKGNzMSwgb2Zmc2V0MSwgY3MyLCBvZmZzZXQyLCBsZW5ndGgpIHtcbiAgICBpZiAob2Zmc2V0MSArIGxlbmd0aCA+IGNzMS5sZW5ndGggfHwgb2Zmc2V0MiArIGxlbmd0aCA+IGNzMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQ2FzZVNlbnNpdGl2ZSgpKSB7XG4gICAgICBjczEgPSBjczEudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNzMiA9IGNzMi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2gxID0gY3MxW29mZnNldDEgKyBpXTtcbiAgICAgIHZhciBjaDIgPSBjczJbb2Zmc2V0MiArIGldO1xuICAgICAgaWYgKGNoMSAhPT0gY2gyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5jaGFyRXF1YWxzID0gZnVuY3Rpb24gY2hhckVxdWFscyhjaDEsIGNoMikge1xuICAgIGlmICh0aGlzLmlzQ2FzZVNlbnNpdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gY2gxID09PSBjaDI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNoYXJFcXVhbHNJZ25vcmVDYXNlKGNoMSwgY2gyKTtcbiAgfTtcbiAgX3Byb3RvLmNoYXJFcXVhbHNJZ25vcmVDYXNlID0gZnVuY3Rpb24gY2hhckVxdWFsc0lnbm9yZUNhc2UoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMxID09PSBjMiB8fCBjMS50b0xvd2VyQ2FzZSgpID09PSBjMi50b0xvd2VyQ2FzZSgpO1xuICB9O1xuICBfcHJvdG8uc2V0UGFyc2VkRmllbGQgPSBmdW5jdGlvbiBzZXRQYXJzZWRGaWVsZChmaWVsZCwgdmFsdWUsIGVycm9yUG9zLCBzdWNjZXNzUG9zKSB7XG4gICAgdmFyIGN1cnJlbnRQYXJzZWRGaWVsZFZhbHVlcyA9IHRoaXMuY3VycmVudFBhcnNlZCgpLmZpZWxkVmFsdWVzO1xuICAgIHZhciBvbGQgPSBjdXJyZW50UGFyc2VkRmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgICBjdXJyZW50UGFyc2VkRmllbGRWYWx1ZXMuc2V0KGZpZWxkLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG9sZCAhPSBudWxsICYmIG9sZCAhPT0gdmFsdWUgPyB+ZXJyb3JQb3MgOiBzdWNjZXNzUG9zO1xuICB9O1xuICBfcHJvdG8uc2V0UGFyc2VkWm9uZSA9IGZ1bmN0aW9uIHNldFBhcnNlZFpvbmUoem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgdGhpcy5jdXJyZW50UGFyc2VkKCkuem9uZSA9IHpvbmU7XG4gIH07XG4gIF9wcm90by5nZXRQYXJzZWQgPSBmdW5jdGlvbiBnZXRQYXJzZWQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFyc2VkKCkuZmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLnRvUGFyc2VkID0gZnVuY3Rpb24gdG9QYXJzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFBhcnNlZCgpO1xuICB9O1xuICBfcHJvdG8uY3VycmVudFBhcnNlZCA9IGZ1bmN0aW9uIGN1cnJlbnRQYXJzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlZFt0aGlzLl9wYXJzZWQubGVuZ3RoIC0gMV07XG4gIH07XG4gIF9wcm90by5zZXRQYXJzZWRMZWFwU2Vjb25kID0gZnVuY3Rpb24gc2V0UGFyc2VkTGVhcFNlY29uZCgpIHtcbiAgICB0aGlzLmN1cnJlbnRQYXJzZWQoKS5sZWFwU2Vjb25kID0gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvLmdldEVmZmVjdGl2ZUNocm9ub2xvZ3kgPSBmdW5jdGlvbiBnZXRFZmZlY3RpdmVDaHJvbm9sb2d5KCkge1xuICAgIHZhciBjaHJvbm8gPSB0aGlzLmN1cnJlbnRQYXJzZWQoKS5jaHJvbm87XG4gICAgaWYgKGNocm9ubyA9PSBudWxsKSB7XG4gICAgICBjaHJvbm8gPSB0aGlzLl9vdmVycmlkZUNocm9ub2xvZ3k7XG4gICAgICBpZiAoY2hyb25vID09IG51bGwpIHtcbiAgICAgICAgY2hyb25vID0gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNocm9ubztcbiAgfTtcbiAgcmV0dXJuIERhdGVUaW1lUGFyc2VDb250ZXh0O1xufSgpO1xudmFyIFBhcnNlZCA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGFyc2VkLCBfVGVtcG9yYWwpO1xuICBmdW5jdGlvbiBQYXJzZWQoZGF0ZVRpbWVQYXJzZUNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfVGVtcG9yYWwuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLmNocm9ubyA9IG51bGw7XG4gICAgX3RoaXMuem9uZSA9IG51bGw7XG4gICAgX3RoaXMuZmllbGRWYWx1ZXMgPSBuZXcgRW51bU1hcCgpO1xuICAgIF90aGlzLmxlYXBTZWNvbmQgPSBmYWxzZTtcbiAgICBfdGhpcy5kYXRlVGltZVBhcnNlQ29udGV4dCA9IGRhdGVUaW1lUGFyc2VDb250ZXh0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvMiA9IFBhcnNlZC5wcm90b3R5cGU7XG4gIF9wcm90bzIuY29weSA9IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBQYXJzZWQoKTtcbiAgICBjbG9uZWQuY2hyb25vID0gdGhpcy5jaHJvbm87XG4gICAgY2xvbmVkLnpvbmUgPSB0aGlzLnpvbmU7XG4gICAgY2xvbmVkLmZpZWxkVmFsdWVzLnB1dEFsbCh0aGlzLmZpZWxkVmFsdWVzKTtcbiAgICBjbG9uZWQubGVhcFNlY29uZCA9IHRoaXMubGVhcFNlY29uZDtcbiAgICBjbG9uZWQuZGF0ZVRpbWVQYXJzZUNvbnRleHQgPSB0aGlzLmRhdGVUaW1lUGFyc2VDb250ZXh0O1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH07XG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZFZhbHVlcyArIFwiLCBcIiArIHRoaXMuY2hyb25vICsgXCIsIFwiICsgdGhpcy56b25lO1xuICB9O1xuICBfcHJvdG8yLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShmaWVsZCk7XG4gIH07XG4gIF9wcm90bzIuZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgdmFyIHZhbCA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgICBhc3NlcnQodmFsICE9IG51bGwpO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIF9wcm90bzIucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaHJvbm87XG4gICAgfVxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmU7XG4gICAgfVxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcbiAgX3Byb3RvMi50b0J1aWxkZXIgPSBmdW5jdGlvbiB0b0J1aWxkZXIoKSB7XG4gICAgdmFyIGJ1aWxkZXIgPSBuZXcgRGF0ZVRpbWVCdWlsZGVyKCk7XG4gICAgYnVpbGRlci5maWVsZFZhbHVlcy5wdXRBbGwodGhpcy5maWVsZFZhbHVlcyk7XG4gICAgYnVpbGRlci5jaHJvbm8gPSB0aGlzLmRhdGVUaW1lUGFyc2VDb250ZXh0LmdldEVmZmVjdGl2ZUNocm9ub2xvZ3koKTtcbiAgICBpZiAodGhpcy56b25lICE9IG51bGwpIHtcbiAgICAgIGJ1aWxkZXIuem9uZSA9IHRoaXMuem9uZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVpbGRlci56b25lID0gdGhpcy5vdmVycmlkZVpvbmU7XG4gICAgfVxuICAgIGJ1aWxkZXIubGVhcFNlY29uZCA9IHRoaXMubGVhcFNlY29uZDtcbiAgICBidWlsZGVyLmV4Y2Vzc0RheXMgPSB0aGlzLmV4Y2Vzc0RheXM7XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH07XG4gIHJldHVybiBQYXJzZWQ7XG59KFRlbXBvcmFsKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBEYXRlVGltZVByaW50Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0ZVRpbWVQcmludENvbnRleHQodGVtcG9yYWwsIGxvY2FsZU9yRm9ybWF0dGVyLCBzeW1ib2xzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRGF0ZVRpbWVGb3JtYXR0ZXIpIHtcbiAgICAgIHRoaXMuX3RlbXBvcmFsID0gRGF0ZVRpbWVQcmludENvbnRleHQuYWRqdXN0KHRlbXBvcmFsLCBsb2NhbGVPckZvcm1hdHRlcik7XG4gICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVPckZvcm1hdHRlci5sb2NhbGUoKTtcbiAgICAgIHRoaXMuX3N5bWJvbHMgPSBsb2NhbGVPckZvcm1hdHRlci5kZWNpbWFsU3R5bGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGVtcG9yYWwgPSB0ZW1wb3JhbDtcbiAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZU9yRm9ybWF0dGVyO1xuICAgICAgdGhpcy5fc3ltYm9scyA9IHN5bWJvbHM7XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbmFsID0gMDtcbiAgfVxuICBEYXRlVGltZVByaW50Q29udGV4dC5hZGp1c3QgPSBmdW5jdGlvbiBhZGp1c3QodGVtcG9yYWwsIGZvcm1hdHRlcikge1xuICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgfTtcbiAgdmFyIF9wcm90byA9IERhdGVUaW1lUHJpbnRDb250ZXh0LnByb3RvdHlwZTtcbiAgX3Byb3RvLnN5bWJvbHMgPSBmdW5jdGlvbiBzeW1ib2xzKCkge1xuICAgIHJldHVybiB0aGlzLl9zeW1ib2xzO1xuICB9O1xuICBfcHJvdG8uc3RhcnRPcHRpb25hbCA9IGZ1bmN0aW9uIHN0YXJ0T3B0aW9uYWwoKSB7XG4gICAgdGhpcy5fb3B0aW9uYWwrKztcbiAgfTtcbiAgX3Byb3RvLmVuZE9wdGlvbmFsID0gZnVuY3Rpb24gZW5kT3B0aW9uYWwoKSB7XG4gICAgdGhpcy5fb3B0aW9uYWwtLTtcbiAgfTtcbiAgX3Byb3RvLmdldFZhbHVlUXVlcnkgPSBmdW5jdGlvbiBnZXRWYWx1ZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RlbXBvcmFsLnF1ZXJ5KHF1ZXJ5KTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgdGhpcy5fb3B0aW9uYWwgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBleHRyYWN0IHZhbHVlOiBcIiArIHRoaXMuX3RlbXBvcmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgX3Byb3RvLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoZmllbGQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RlbXBvcmFsLmdldExvbmcoZmllbGQpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBEYXRlVGltZUV4Y2VwdGlvbiAmJiB0aGlzLl9vcHRpb25hbCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gIH07XG4gIF9wcm90by50ZW1wb3JhbCA9IGZ1bmN0aW9uIHRlbXBvcmFsKCkge1xuICAgIHJldHVybiB0aGlzLl90ZW1wb3JhbDtcbiAgfTtcbiAgX3Byb3RvLmxvY2FsZSA9IGZ1bmN0aW9uIGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICB9O1xuICBfcHJvdG8uc2V0RGF0ZVRpbWUgPSBmdW5jdGlvbiBzZXREYXRlVGltZSh0ZW1wb3JhbCkge1xuICAgIHRoaXMuX3RlbXBvcmFsID0gdGVtcG9yYWw7XG4gIH07XG4gIF9wcm90by5zZXRMb2NhbGUgPSBmdW5jdGlvbiBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICB9O1xuICByZXR1cm4gRGF0ZVRpbWVQcmludENvbnRleHQ7XG59KCk7XG5cbnZhciBJc29GaWVsZHMgPSB7fTtcbnZhciBRVUFSVEVSX0RBWVMgPSBbMCwgOTAsIDE4MSwgMjczLCAwLCA5MSwgMTgyLCAyNzRdO1xudmFyIEZpZWxkID0gZnVuY3Rpb24gKF9UZW1wb3JhbEZpZWxkKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZpZWxkLCBfVGVtcG9yYWxGaWVsZCk7XG4gIGZ1bmN0aW9uIEZpZWxkKCkge1xuICAgIHJldHVybiBfVGVtcG9yYWxGaWVsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IEZpZWxkLnByb3RvdHlwZTtcbiAgX3Byb3RvLmlzRGF0ZUJhc2VkID0gZnVuY3Rpb24gaXNEYXRlQmFzZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5pc1RpbWVCYXNlZCA9IGZ1bmN0aW9uIGlzVGltZUJhc2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLl9pc0lzbyA9IGZ1bmN0aW9uIF9pc0lzbygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgRmllbGQuX2dldFdlZWtSYW5nZUJ5TG9jYWxEYXRlID0gZnVuY3Rpb24gX2dldFdlZWtSYW5nZUJ5TG9jYWxEYXRlKGRhdGUpIHtcbiAgICB2YXIgd2J5ID0gRmllbGQuX2dldFdlZWtCYXNlZFllYXIoZGF0ZSk7XG4gICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgRmllbGQuX2dldFdlZWtSYW5nZUJ5WWVhcih3YnkpKTtcbiAgfTtcbiAgRmllbGQuX2dldFdlZWtSYW5nZUJ5WWVhciA9IGZ1bmN0aW9uIF9nZXRXZWVrUmFuZ2VCeVllYXIod2J5KSB7XG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2Yod2J5LCAxLCAxKTtcbiAgICBpZiAoZGF0ZS5kYXlPZldlZWsoKSA9PT0gRGF5T2ZXZWVrLlRIVVJTREFZIHx8IGRhdGUuZGF5T2ZXZWVrKCkgPT09IERheU9mV2Vlay5XRURORVNEQVkgJiYgZGF0ZS5pc0xlYXBZZWFyKCkpIHtcbiAgICAgIHJldHVybiA1MztcbiAgICB9XG4gICAgcmV0dXJuIDUyO1xuICB9O1xuICBGaWVsZC5fZ2V0V2VlayA9IGZ1bmN0aW9uIF9nZXRXZWVrKGRhdGUpIHtcbiAgICB2YXIgZG93MCA9IGRhdGUuZGF5T2ZXZWVrKCkub3JkaW5hbCgpO1xuICAgIHZhciBkb3kwID0gZGF0ZS5kYXlPZlllYXIoKSAtIDE7XG4gICAgdmFyIGRveVRodTAgPSBkb3kwICsgKDMgLSBkb3cwKTtcbiAgICB2YXIgYWxpZ25lZFdlZWsgPSBNYXRoVXRpbC5pbnREaXYoZG95VGh1MCwgNyk7XG4gICAgdmFyIGZpcnN0VGh1RG95MCA9IGRveVRodTAgLSBhbGlnbmVkV2VlayAqIDc7XG4gICAgdmFyIGZpcnN0TW9uRG95MCA9IGZpcnN0VGh1RG95MCAtIDM7XG4gICAgaWYgKGZpcnN0TW9uRG95MCA8IC0zKSB7XG4gICAgICBmaXJzdE1vbkRveTAgKz0gNztcbiAgICB9XG4gICAgaWYgKGRveTAgPCBmaXJzdE1vbkRveTApIHtcbiAgICAgIHJldHVybiBGaWVsZC5fZ2V0V2Vla1JhbmdlQnlMb2NhbERhdGUoZGF0ZS53aXRoRGF5T2ZZZWFyKDE4MCkubWludXNZZWFycygxKSkubWF4aW11bSgpO1xuICAgIH1cbiAgICB2YXIgd2VlayA9IE1hdGhVdGlsLmludERpdihkb3kwIC0gZmlyc3RNb25Eb3kwLCA3KSArIDE7XG4gICAgaWYgKHdlZWsgPT09IDUzKSB7XG4gICAgICBpZiAoKGZpcnN0TW9uRG95MCA9PT0gLTMgfHwgZmlyc3RNb25Eb3kwID09PSAtMiAmJiBkYXRlLmlzTGVhcFllYXIoKSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHdlZWsgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2VlaztcbiAgfTtcbiAgRmllbGQuX2dldFdlZWtCYXNlZFllYXIgPSBmdW5jdGlvbiBfZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKSB7XG4gICAgdmFyIHllYXIgPSBkYXRlLnllYXIoKTtcbiAgICB2YXIgZG95ID0gZGF0ZS5kYXlPZlllYXIoKTtcbiAgICBpZiAoZG95IDw9IDMpIHtcbiAgICAgIHZhciBkb3cgPSBkYXRlLmRheU9mV2VlaygpLm9yZGluYWwoKTtcbiAgICAgIGlmIChkb3kgLSBkb3cgPCAtMikge1xuICAgICAgICB5ZWFyLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkb3kgPj0gMzYzKSB7XG4gICAgICB2YXIgX2RvdyA9IGRhdGUuZGF5T2ZXZWVrKCkub3JkaW5hbCgpO1xuICAgICAgZG95ID0gZG95IC0gMzYzIC0gKGRhdGUuaXNMZWFwWWVhcigpID8gMSA6IDApO1xuICAgICAgaWYgKGRveSAtIF9kb3cgPj0gMCkge1xuICAgICAgICB5ZWFyKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5ZWFyO1xuICB9O1xuICBfcHJvdG8uZGlzcGxheU5hbWUgPSBmdW5jdGlvbiBkaXNwbGF5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIF9wcm90by5uYW1lID0gZnVuY3Rpb24gbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICByZXR1cm4gRmllbGQ7XG59KFRlbXBvcmFsRmllbGQpO1xudmFyIERBWV9PRl9RVUFSVEVSX0ZJRUxEID0gZnVuY3Rpb24gKF9GaWVsZCkge1xuICBfaW5oZXJpdHNMb29zZShEQVlfT0ZfUVVBUlRFUl9GSUVMRCwgX0ZpZWxkKTtcbiAgZnVuY3Rpb24gREFZX09GX1FVQVJURVJfRklFTEQoKSB7XG4gICAgcmV0dXJuIF9GaWVsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9wcm90bzIgPSBEQVlfT0ZfUVVBUlRFUl9GSUVMRC5wcm90b3R5cGU7XG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0RheU9mUXVhcnRlcic7XG4gIH07XG4gIF9wcm90bzIuYmFzZVVuaXQgPSBmdW5jdGlvbiBiYXNlVW5pdCgpIHtcbiAgICByZXR1cm4gQ2hyb25vVW5pdC5EQVlTO1xuICB9O1xuICBfcHJvdG8yLnJhbmdlVW5pdCA9IGZ1bmN0aW9uIHJhbmdlVW5pdCgpIHtcbiAgICByZXR1cm4gUVVBUlRFUl9ZRUFSUztcbiAgfTtcbiAgX3Byb3RvMi5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIDkwLCA5Mik7XG4gIH07XG4gIF9wcm90bzIuaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpICYmIHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpICYmIHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLllFQVIpICYmIHRoaXMuX2lzSXNvKHRlbXBvcmFsKTtcbiAgfTtcbiAgX3Byb3RvMi5yYW5nZVJlZmluZWRCeSA9IGZ1bmN0aW9uIHJhbmdlUmVmaW5lZEJ5KHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogRGF5T2ZRdWFydGVyJyk7XG4gICAgfVxuICAgIHZhciBxb3kgPSB0ZW1wb3JhbC5nZXRMb25nKFFVQVJURVJfT0ZfWUVBUik7XG4gICAgaWYgKHFveSA9PT0gMSkge1xuICAgICAgdmFyIHllYXIgPSB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLllFQVIpO1xuICAgICAgcmV0dXJuIElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5ZWFyKSA/IFZhbHVlUmFuZ2Uub2YoMSwgOTEpIDogVmFsdWVSYW5nZS5vZigxLCA5MCk7XG4gICAgfSBlbHNlIGlmIChxb3kgPT09IDIpIHtcbiAgICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIDkxKTtcbiAgICB9IGVsc2UgaWYgKHFveSA9PT0gMyB8fCBxb3kgPT09IDQpIHtcbiAgICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIDkyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoKTtcbiAgfTtcbiAgX3Byb3RvMi5nZXRGcm9tID0gZnVuY3Rpb24gZ2V0RnJvbSh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6IERheU9mUXVhcnRlcicpO1xuICAgIH1cbiAgICB2YXIgZG95ID0gdGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKTtcbiAgICB2YXIgbW95ID0gdGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpO1xuICAgIHZhciB5ZWFyID0gdGVtcG9yYWwuZ2V0TG9uZyhDaHJvbm9GaWVsZC5ZRUFSKTtcbiAgICByZXR1cm4gZG95IC0gUVVBUlRFUl9EQVlTW01hdGhVdGlsLmludERpdihtb3kgLSAxLCAzKSArIChJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIoeWVhcikgPyA0IDogMCldO1xuICB9O1xuICBfcHJvdG8yLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsLCBuZXdWYWx1ZSkge1xuICAgIHZhciBjdXJWYWx1ZSA9IHRoaXMuZ2V0RnJvbSh0ZW1wb3JhbCk7XG4gICAgdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1lFQVIsIHRlbXBvcmFsLmdldExvbmcoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpICsgKG5ld1ZhbHVlIC0gY3VyVmFsdWUpKTtcbiAgfTtcbiAgX3Byb3RvMi5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShmaWVsZFZhbHVlcywgcGFydGlhbFRlbXBvcmFsLCByZXNvbHZlclN0eWxlKSB7XG4gICAgdmFyIHllYXJMb25nID0gZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLllFQVIpO1xuICAgIHZhciBxb3lMb25nID0gZmllbGRWYWx1ZXMuZ2V0KFFVQVJURVJfT0ZfWUVBUik7XG4gICAgaWYgKHllYXJMb25nID09IG51bGwgfHwgcW95TG9uZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHkgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZSh5ZWFyTG9uZyk7XG4gICAgdmFyIGRvcSA9IGZpZWxkVmFsdWVzLmdldChEQVlfT0ZfUVVBUlRFUik7XG4gICAgdmFyIGRhdGU7XG4gICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgdmFyIHFveSA9IHFveUxvbmc7XG4gICAgICBkYXRlID0gTG9jYWxEYXRlLm9mKHksIDEsIDEpO1xuICAgICAgZGF0ZSA9IGRhdGUucGx1c01vbnRocyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoTWF0aFV0aWwuc2FmZVN1YnRyYWN0KHFveSwgMSksIDMpKTtcbiAgICAgIGRhdGUgPSBkYXRlLnBsdXNEYXlzKE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChkb3EsIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9xb3kgPSBRVUFSVEVSX09GX1lFQVIucmFuZ2UoKS5jaGVja1ZhbGlkSW50VmFsdWUocW95TG9uZywgUVVBUlRFUl9PRl9ZRUFSKTtcbiAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNUUklDVCkge1xuICAgICAgICB2YXIgbWF4ID0gOTI7XG4gICAgICAgIGlmIChfcW95ID09PSAxKSB7XG4gICAgICAgICAgbWF4ID0gSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHkpID8gOTEgOiA5MDtcbiAgICAgICAgfSBlbHNlIGlmIChfcW95ID09PSAyKSB7XG4gICAgICAgICAgbWF4ID0gOTE7XG4gICAgICAgIH1cbiAgICAgICAgVmFsdWVSYW5nZS5vZigxLCBtYXgpLmNoZWNrVmFsaWRWYWx1ZShkb3EsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRWYWx1ZShkb3EsIHRoaXMpO1xuICAgICAgfVxuICAgICAgZGF0ZSA9IExvY2FsRGF0ZS5vZih5LCAoX3FveSAtIDEpICogMyArIDEsIDEpLnBsdXNEYXlzKGRvcSAtIDEpO1xuICAgIH1cbiAgICBmaWVsZFZhbHVlcy5yZW1vdmUodGhpcyk7XG4gICAgZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLllFQVIpO1xuICAgIGZpZWxkVmFsdWVzLnJlbW92ZShRVUFSVEVSX09GX1lFQVIpO1xuICAgIHJldHVybiBkYXRlO1xuICB9O1xuICByZXR1cm4gREFZX09GX1FVQVJURVJfRklFTEQ7XG59KEZpZWxkKTtcbnZhciBRVUFSVEVSX09GX1lFQVJfRklFTEQgPSBmdW5jdGlvbiAoX0ZpZWxkMikge1xuICBfaW5oZXJpdHNMb29zZShRVUFSVEVSX09GX1lFQVJfRklFTEQsIF9GaWVsZDIpO1xuICBmdW5jdGlvbiBRVUFSVEVSX09GX1lFQVJfRklFTEQoKSB7XG4gICAgcmV0dXJuIF9GaWVsZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfcHJvdG8zID0gUVVBUlRFUl9PRl9ZRUFSX0ZJRUxELnByb3RvdHlwZTtcbiAgX3Byb3RvMy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnUXVhcnRlck9mWWVhcic7XG4gIH07XG4gIF9wcm90bzMuYmFzZVVuaXQgPSBmdW5jdGlvbiBiYXNlVW5pdCgpIHtcbiAgICByZXR1cm4gUVVBUlRFUl9ZRUFSUztcbiAgfTtcbiAgX3Byb3RvMy5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIENocm9ub1VuaXQuWUVBUlM7XG4gIH07XG4gIF9wcm90bzMucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSgpIHtcbiAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCA0KTtcbiAgfTtcbiAgX3Byb3RvMy5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSAmJiB0aGlzLl9pc0lzbyh0ZW1wb3JhbCk7XG4gIH07XG4gIF9wcm90bzMucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlKCk7XG4gIH07XG4gIF9wcm90bzMuZ2V0RnJvbSA9IGZ1bmN0aW9uIGdldEZyb20odGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwuaXNTdXBwb3J0ZWQodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiBRdWFydGVyT2ZZZWFyJyk7XG4gICAgfVxuICAgIHZhciBtb3kgPSB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpO1xuICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobW95ICsgMiwgMyk7XG4gIH07XG4gIF9wcm90bzMuYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIGN1clZhbHVlID0gdGhpcy5nZXRGcm9tKHRlbXBvcmFsKTtcbiAgICB0aGlzLnJhbmdlKCkuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlLCB0aGlzKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpICsgKG5ld1ZhbHVlIC0gY3VyVmFsdWUpICogMyk7XG4gIH07XG4gIHJldHVybiBRVUFSVEVSX09GX1lFQVJfRklFTEQ7XG59KEZpZWxkKTtcbnZhciBXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRCA9IGZ1bmN0aW9uIChfRmllbGQzKSB7XG4gIF9pbmhlcml0c0xvb3NlKFdFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSX0ZJRUxELCBfRmllbGQzKTtcbiAgZnVuY3Rpb24gV0VFS19PRl9XRUVLX0JBU0VEX1lFQVJfRklFTEQoKSB7XG4gICAgcmV0dXJuIF9GaWVsZDMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfcHJvdG80ID0gV0VFS19PRl9XRUVLX0JBU0VEX1lFQVJfRklFTEQucHJvdG90eXBlO1xuICBfcHJvdG80LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdXZWVrT2ZXZWVrQmFzZWRZZWFyJztcbiAgfTtcbiAgX3Byb3RvNC5iYXNlVW5pdCA9IGZ1bmN0aW9uIGJhc2VVbml0KCkge1xuICAgIHJldHVybiBDaHJvbm9Vbml0LldFRUtTO1xuICB9O1xuICBfcHJvdG80LnJhbmdlVW5pdCA9IGZ1bmN0aW9uIHJhbmdlVW5pdCgpIHtcbiAgICByZXR1cm4gV0VFS19CQVNFRF9ZRUFSUztcbiAgfTtcbiAgX3Byb3RvNC5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIDUyLCA1Myk7XG4gIH07XG4gIF9wcm90bzQuaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSAmJiB0aGlzLl9pc0lzbyh0ZW1wb3JhbCk7XG4gIH07XG4gIF9wcm90bzQucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6IFdlZWtPZldlZWtCYXNlZFllYXInKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpZWxkLl9nZXRXZWVrUmFuZ2VCeUxvY2FsRGF0ZShMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCkpO1xuICB9O1xuICBfcHJvdG80LmdldEZyb20gPSBmdW5jdGlvbiBnZXRGcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogV2Vla09mV2Vla0Jhc2VkWWVhcicpO1xuICAgIH1cbiAgICByZXR1cm4gRmllbGQuX2dldFdlZWsoTG9jYWxEYXRlLmZyb20odGVtcG9yYWwpKTtcbiAgfTtcbiAgX3Byb3RvNC5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCwgbmV3VmFsdWUpIHtcbiAgICB0aGlzLnJhbmdlKCkuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlLCB0aGlzKTtcbiAgICByZXR1cm4gdGVtcG9yYWwucGx1cyhNYXRoVXRpbC5zYWZlU3VidHJhY3QobmV3VmFsdWUsIHRoaXMuZ2V0RnJvbSh0ZW1wb3JhbCkpLCBDaHJvbm9Vbml0LldFRUtTKTtcbiAgfTtcbiAgX3Byb3RvNC5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShmaWVsZFZhbHVlcywgcGFydGlhbFRlbXBvcmFsLCByZXNvbHZlclN0eWxlKSB7XG4gICAgdmFyIHdieUxvbmcgPSBmaWVsZFZhbHVlcy5nZXQoV0VFS19CQVNFRF9ZRUFSKTtcbiAgICB2YXIgZG93TG9uZyA9IGZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG4gICAgaWYgKHdieUxvbmcgPT0gbnVsbCB8fCBkb3dMb25nID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgd2J5ID0gV0VFS19CQVNFRF9ZRUFSLnJhbmdlKCkuY2hlY2tWYWxpZEludFZhbHVlKHdieUxvbmcsIFdFRUtfQkFTRURfWUVBUik7XG4gICAgdmFyIHdvd2J5ID0gZmllbGRWYWx1ZXMuZ2V0KFdFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSKTtcbiAgICB2YXIgZGF0ZTtcbiAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICB2YXIgZG93ID0gZG93TG9uZztcbiAgICAgIHZhciB3ZWVrcyA9IDA7XG4gICAgICBpZiAoZG93ID4gNykge1xuICAgICAgICB3ZWVrcyA9IE1hdGhVdGlsLmludERpdihkb3cgLSAxLCA3KTtcbiAgICAgICAgZG93ID0gTWF0aFV0aWwuaW50TW9kKGRvdyAtIDEsIDcpICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoZG93IDwgMSkge1xuICAgICAgICB3ZWVrcyA9IE1hdGhVdGlsLmludERpdihkb3csIDcpIC0gMTtcbiAgICAgICAgZG93ID0gTWF0aFV0aWwuaW50TW9kKGRvdywgNykgKyA3O1xuICAgICAgfVxuICAgICAgZGF0ZSA9IExvY2FsRGF0ZS5vZih3YnksIDEsIDQpLnBsdXNXZWVrcyh3b3dieSAtIDEpLnBsdXNXZWVrcyh3ZWVrcykud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSywgZG93KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kb3cyID0gQ2hyb25vRmllbGQuREFZX09GX1dFRUsuY2hlY2tWYWxpZEludFZhbHVlKGRvd0xvbmcpO1xuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU1RSSUNUKSB7XG4gICAgICAgIHZhciB0ZW1wID0gTG9jYWxEYXRlLm9mKHdieSwgMSwgNCk7XG4gICAgICAgIHZhciByYW5nZSA9IEZpZWxkLl9nZXRXZWVrUmFuZ2VCeUxvY2FsRGF0ZSh0ZW1wKTtcbiAgICAgICAgcmFuZ2UuY2hlY2tWYWxpZFZhbHVlKHdvd2J5LCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFuZ2UoKS5jaGVja1ZhbGlkVmFsdWUod293YnksIHRoaXMpO1xuICAgICAgfVxuICAgICAgZGF0ZSA9IExvY2FsRGF0ZS5vZih3YnksIDEsIDQpLnBsdXNXZWVrcyh3b3dieSAtIDEpLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1dFRUssIF9kb3cyKTtcbiAgICB9XG4gICAgZmllbGRWYWx1ZXMucmVtb3ZlKHRoaXMpO1xuICAgIGZpZWxkVmFsdWVzLnJlbW92ZShXRUVLX0JBU0VEX1lFQVIpO1xuICAgIGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH07XG4gIF9wcm90bzQuZGlzcGxheU5hbWUgPSBmdW5jdGlvbiBkaXNwbGF5TmFtZSgpIHtcbiAgICByZXR1cm4gJ1dlZWsnO1xuICB9O1xuICByZXR1cm4gV0VFS19PRl9XRUVLX0JBU0VEX1lFQVJfRklFTEQ7XG59KEZpZWxkKTtcbnZhciBXRUVLX0JBU0VEX1lFQVJfRklFTEQgPSBmdW5jdGlvbiAoX0ZpZWxkNCkge1xuICBfaW5oZXJpdHNMb29zZShXRUVLX0JBU0VEX1lFQVJfRklFTEQsIF9GaWVsZDQpO1xuICBmdW5jdGlvbiBXRUVLX0JBU0VEX1lFQVJfRklFTEQoKSB7XG4gICAgcmV0dXJuIF9GaWVsZDQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfcHJvdG81ID0gV0VFS19CQVNFRF9ZRUFSX0ZJRUxELnByb3RvdHlwZTtcbiAgX3Byb3RvNS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnV2Vla0Jhc2VkWWVhcic7XG4gIH07XG4gIF9wcm90bzUuYmFzZVVuaXQgPSBmdW5jdGlvbiBiYXNlVW5pdCgpIHtcbiAgICByZXR1cm4gV0VFS19CQVNFRF9ZRUFSUztcbiAgfTtcbiAgX3Byb3RvNS5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIENocm9ub1VuaXQuRk9SRVZFUjtcbiAgfTtcbiAgX3Byb3RvNS5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIHJldHVybiBDaHJvbm9GaWVsZC5ZRUFSLnJhbmdlKCk7XG4gIH07XG4gIF9wcm90bzUuaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSAmJiB0aGlzLl9pc0lzbyh0ZW1wb3JhbCk7XG4gIH07XG4gIF9wcm90bzUucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBDaHJvbm9GaWVsZC5ZRUFSLnJhbmdlKCk7XG4gIH07XG4gIF9wcm90bzUuZ2V0RnJvbSA9IGZ1bmN0aW9uIGdldEZyb20odGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwuaXNTdXBwb3J0ZWQodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGZpZWxkOiBXZWVrQmFzZWRZZWFyJyk7XG4gICAgfVxuICAgIHJldHVybiBGaWVsZC5fZ2V0V2Vla0Jhc2VkWWVhcihMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCkpO1xuICB9O1xuICBfcHJvdG81LmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsLCBuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQnkodGVtcG9yYWwpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogV2Vla0Jhc2VkWWVhcicpO1xuICAgIH1cbiAgICB2YXIgbmV3V2J5ID0gdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSwgV0VFS19CQVNFRF9ZRUFSKTtcbiAgICB2YXIgZGF0ZSA9IExvY2FsRGF0ZS5mcm9tKHRlbXBvcmFsKTtcbiAgICB2YXIgZG93ID0gZGF0ZS5nZXQoQ2hyb25vRmllbGQuREFZX09GX1dFRUspO1xuICAgIHZhciB3ZWVrID0gRmllbGQuX2dldFdlZWsoZGF0ZSk7XG4gICAgaWYgKHdlZWsgPT09IDUzICYmIEZpZWxkLl9nZXRXZWVrUmFuZ2VCeVllYXIobmV3V2J5KSA9PT0gNTIpIHtcbiAgICAgIHdlZWsgPSA1MjtcbiAgICB9XG4gICAgdmFyIHJlc29sdmVkID0gTG9jYWxEYXRlLm9mKG5ld1dieSwgMSwgNCk7XG4gICAgdmFyIGRheXMgPSBkb3cgLSByZXNvbHZlZC5nZXQoQ2hyb25vRmllbGQuREFZX09GX1dFRUspICsgKHdlZWsgLSAxKSAqIDc7XG4gICAgcmVzb2x2ZWQgPSByZXNvbHZlZC5wbHVzRGF5cyhkYXlzKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChyZXNvbHZlZCk7XG4gIH07XG4gIHJldHVybiBXRUVLX0JBU0VEX1lFQVJfRklFTEQ7XG59KEZpZWxkKTtcbnZhciBVbml0ID0gZnVuY3Rpb24gKF9UZW1wb3JhbFVuaXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVW5pdCwgX1RlbXBvcmFsVW5pdCk7XG4gIGZ1bmN0aW9uIFVuaXQobmFtZSwgZXN0aW1hdGVkRHVyYXRpb24pIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfVGVtcG9yYWxVbml0LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgX3RoaXMuX2R1cmF0aW9uID0gZXN0aW1hdGVkRHVyYXRpb247XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG82ID0gVW5pdC5wcm90b3R5cGU7XG4gIF9wcm90bzYuZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gIH07XG4gIF9wcm90bzYuaXNEdXJhdGlvbkVzdGltYXRlZCA9IGZ1bmN0aW9uIGlzRHVyYXRpb25Fc3RpbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90bzYuaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvNi5pc1RpbWVCYXNlZCA9IGZ1bmN0aW9uIGlzVGltZUJhc2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvNi5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5FUE9DSF9EQVkpO1xuICB9O1xuICBfcHJvdG82LmFkZFRvID0gZnVuY3Rpb24gYWRkVG8odGVtcG9yYWwsIHBlcmlvZFRvQWRkKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFdFRUtfQkFTRURfWUVBUlM6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYWRkZWQgPSBNYXRoVXRpbC5zYWZlQWRkKHRlbXBvcmFsLmdldChXRUVLX0JBU0VEX1lFQVIpLCBwZXJpb2RUb0FkZCk7XG4gICAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoV0VFS19CQVNFRF9ZRUFSLCBhZGRlZCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUVVBUlRFUl9ZRUFSUzpcbiAgICAgICAgcmV0dXJuIHRlbXBvcmFsLnBsdXMoTWF0aFV0aWwuaW50RGl2KHBlcmlvZFRvQWRkLCAyNTYpLCBDaHJvbm9Vbml0LllFQVJTKS5wbHVzKE1hdGhVdGlsLmludE1vZChwZXJpb2RUb0FkZCwgMjU2KSAqIDMsIENocm9ub1VuaXQuTU9OVEhTKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ1VucmVhY2hhYmxlJyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG82LmJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHRlbXBvcmFsMSwgdGVtcG9yYWwyKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFdFRUtfQkFTRURfWUVBUlM6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlU3VidHJhY3QodGVtcG9yYWwyLmdldExvbmcoV0VFS19CQVNFRF9ZRUFSKSwgdGVtcG9yYWwxLmdldExvbmcoV0VFS19CQVNFRF9ZRUFSKSk7XG4gICAgICBjYXNlIFFVQVJURVJfWUVBUlM6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGVtcG9yYWwxLnVudGlsKHRlbXBvcmFsMiwgQ2hyb25vVW5pdC5NT05USFMpLCAzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oJ1VucmVhY2hhYmxlJyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG82LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG4gIHJldHVybiBVbml0O1xufShUZW1wb3JhbFVuaXQpO1xudmFyIERBWV9PRl9RVUFSVEVSID0gbnVsbDtcbnZhciBRVUFSVEVSX09GX1lFQVIgPSBudWxsO1xudmFyIFdFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSID0gbnVsbDtcbnZhciBXRUVLX0JBU0VEX1lFQVIgPSBudWxsO1xudmFyIFdFRUtfQkFTRURfWUVBUlMgPSBudWxsO1xudmFyIFFVQVJURVJfWUVBUlMgPSBudWxsO1xuZnVuY3Rpb24gX2luaXQkZigpIHtcbiAgREFZX09GX1FVQVJURVIgPSBuZXcgREFZX09GX1FVQVJURVJfRklFTEQoKTtcbiAgUVVBUlRFUl9PRl9ZRUFSID0gbmV3IFFVQVJURVJfT0ZfWUVBUl9GSUVMRCgpO1xuICBXRUVLX09GX1dFRUtfQkFTRURfWUVBUiA9IG5ldyBXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRCgpO1xuICBXRUVLX0JBU0VEX1lFQVIgPSBuZXcgV0VFS19CQVNFRF9ZRUFSX0ZJRUxEKCk7XG4gIFdFRUtfQkFTRURfWUVBUlMgPSBuZXcgVW5pdCgnV2Vla0Jhc2VkWWVhcnMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIpKTtcbiAgUVVBUlRFUl9ZRUFSUyA9IG5ldyBVbml0KCdRdWFydGVyWWVhcnMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIgLyA0KSk7XG4gIElzb0ZpZWxkcy5EQVlfT0ZfUVVBUlRFUiA9IERBWV9PRl9RVUFSVEVSO1xuICBJc29GaWVsZHMuUVVBUlRFUl9PRl9ZRUFSID0gUVVBUlRFUl9PRl9ZRUFSO1xuICBJc29GaWVsZHMuV0VFS19PRl9XRUVLX0JBU0VEX1lFQVIgPSBXRUVLX09GX1dFRUtfQkFTRURfWUVBUjtcbiAgSXNvRmllbGRzLldFRUtfQkFTRURfWUVBUiA9IFdFRUtfQkFTRURfWUVBUjtcbiAgSXNvRmllbGRzLldFRUtfQkFTRURfWUVBUlMgPSBXRUVLX0JBU0VEX1lFQVJTO1xuICBJc29GaWVsZHMuUVVBUlRFUl9ZRUFSUyA9IFFVQVJURVJfWUVBUlM7XG4gIExvY2FsRGF0ZS5wcm90b3R5cGUuaXNvV2Vla09mV2Vla3llYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KElzb0ZpZWxkcy5XRUVLX09GX1dFRUtfQkFTRURfWUVBUik7XG4gIH07XG4gIExvY2FsRGF0ZS5wcm90b3R5cGUuaXNvV2Vla3llYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KElzb0ZpZWxkcy5XRUVLX0JBU0VEX1lFQVIpO1xuICB9O1xufVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBEZWNpbWFsU3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlY2ltYWxTdHlsZSh6ZXJvQ2hhciwgcG9zaXRpdmVTaWduQ2hhciwgbmVnYXRpdmVTaWduQ2hhciwgZGVjaW1hbFBvaW50Q2hhcikge1xuICAgIHRoaXMuX3plcm9EaWdpdCA9IHplcm9DaGFyO1xuICAgIHRoaXMuX3plcm9EaWdpdENoYXJDb2RlID0gemVyb0NoYXIuY2hhckNvZGVBdCgwKTtcbiAgICB0aGlzLl9wb3NpdGl2ZVNpZ24gPSBwb3NpdGl2ZVNpZ25DaGFyO1xuICAgIHRoaXMuX25lZ2F0aXZlU2lnbiA9IG5lZ2F0aXZlU2lnbkNoYXI7XG4gICAgdGhpcy5fZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxQb2ludENoYXI7XG4gIH1cbiAgdmFyIF9wcm90byA9IERlY2ltYWxTdHlsZS5wcm90b3R5cGU7XG4gIF9wcm90by5wb3NpdGl2ZVNpZ24gPSBmdW5jdGlvbiBwb3NpdGl2ZVNpZ24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aXZlU2lnbjtcbiAgfTtcbiAgX3Byb3RvLndpdGhQb3NpdGl2ZVNpZ24gPSBmdW5jdGlvbiB3aXRoUG9zaXRpdmVTaWduKHBvc2l0aXZlU2lnbikge1xuICAgIGlmIChwb3NpdGl2ZVNpZ24gPT09IHRoaXMuX3Bvc2l0aXZlU2lnbikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGVjaW1hbFN0eWxlKHRoaXMuX3plcm9EaWdpdCwgcG9zaXRpdmVTaWduLCB0aGlzLl9uZWdhdGl2ZVNpZ24sIHRoaXMuX2RlY2ltYWxTZXBhcmF0b3IpO1xuICB9O1xuICBfcHJvdG8ubmVnYXRpdmVTaWduID0gZnVuY3Rpb24gbmVnYXRpdmVTaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9uZWdhdGl2ZVNpZ247XG4gIH07XG4gIF9wcm90by53aXRoTmVnYXRpdmVTaWduID0gZnVuY3Rpb24gd2l0aE5lZ2F0aXZlU2lnbihuZWdhdGl2ZVNpZ24pIHtcbiAgICBpZiAobmVnYXRpdmVTaWduID09PSB0aGlzLl9uZWdhdGl2ZVNpZ24pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERlY2ltYWxTdHlsZSh0aGlzLl96ZXJvRGlnaXQsIHRoaXMuX3Bvc2l0aXZlU2lnbiwgbmVnYXRpdmVTaWduLCB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yKTtcbiAgfTtcbiAgX3Byb3RvLnplcm9EaWdpdCA9IGZ1bmN0aW9uIHplcm9EaWdpdCgpIHtcbiAgICByZXR1cm4gdGhpcy5femVyb0RpZ2l0O1xuICB9O1xuICBfcHJvdG8ud2l0aFplcm9EaWdpdCA9IGZ1bmN0aW9uIHdpdGhaZXJvRGlnaXQoemVyb0RpZ2l0KSB7XG4gICAgaWYgKHplcm9EaWdpdCA9PT0gdGhpcy5femVyb0RpZ2l0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNpbWFsU3R5bGUoemVyb0RpZ2l0LCB0aGlzLl9wb3NpdGl2ZVNpZ24sIHRoaXMuX25lZ2F0aXZlU2lnbiwgdGhpcy5fZGVjaW1hbFNlcGFyYXRvcik7XG4gIH07XG4gIF9wcm90by5kZWNpbWFsU2VwYXJhdG9yID0gZnVuY3Rpb24gZGVjaW1hbFNlcGFyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjaW1hbFNlcGFyYXRvcjtcbiAgfTtcbiAgX3Byb3RvLndpdGhEZWNpbWFsU2VwYXJhdG9yID0gZnVuY3Rpb24gd2l0aERlY2ltYWxTZXBhcmF0b3IoZGVjaW1hbFNlcGFyYXRvcikge1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yID09PSB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEZWNpbWFsU3R5bGUodGhpcy5femVyb0RpZ2l0LCB0aGlzLl9wb3NpdGl2ZVNpZ24sIHRoaXMuX25lZ2F0aXZlU2lnbiwgZGVjaW1hbFNlcGFyYXRvcik7XG4gIH07XG4gIF9wcm90by5jb252ZXJ0VG9EaWdpdCA9IGZ1bmN0aW9uIGNvbnZlcnRUb0RpZ2l0KGNoYXIpIHtcbiAgICB2YXIgdmFsID0gY2hhci5jaGFyQ29kZUF0KDApIC0gdGhpcy5femVyb0RpZ2l0Q2hhckNvZGU7XG4gICAgcmV0dXJuIHZhbCA+PSAwICYmIHZhbCA8PSA5ID8gdmFsIDogLTE7XG4gIH07XG4gIF9wcm90by5jb252ZXJ0TnVtYmVyVG9JMThOID0gZnVuY3Rpb24gY29udmVydE51bWJlclRvSTE4TihudW1lcmljVGV4dCkge1xuICAgIGlmICh0aGlzLl96ZXJvRGlnaXQgPT09ICcwJykge1xuICAgICAgcmV0dXJuIG51bWVyaWNUZXh0O1xuICAgIH1cbiAgICB2YXIgZGlmZiA9IHRoaXMuX3plcm9EaWdpdENoYXJDb2RlIC0gJzAnLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGNvbnZlcnRlZFRleHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWVyaWNUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb252ZXJ0ZWRUZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobnVtZXJpY1RleHQuY2hhckNvZGVBdChpKSArIGRpZmYpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkVGV4dDtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIERlY2ltYWxTdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3plcm9EaWdpdCA9PT0gb3RoZXIuX3plcm9EaWdpdCAmJiB0aGlzLl9wb3NpdGl2ZVNpZ24gPT09IG90aGVyLl9wb3NpdGl2ZVNpZ24gJiYgdGhpcy5fbmVnYXRpdmVTaWduID09PSBvdGhlci5fbmVnYXRpdmVTaWduICYmIHRoaXMuX2RlY2ltYWxTZXBhcmF0b3IgPT09IG90aGVyLl9kZWNpbWFsU2VwYXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl96ZXJvRGlnaXQgKyB0aGlzLl9wb3NpdGl2ZVNpZ24gKyB0aGlzLl9uZWdhdGl2ZVNpZ24gKyB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJEZWNpbWFsU3R5bGVbXCIgKyB0aGlzLl96ZXJvRGlnaXQgKyB0aGlzLl9wb3NpdGl2ZVNpZ24gKyB0aGlzLl9uZWdhdGl2ZVNpZ24gKyB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yICsgXCJdXCI7XG4gIH07XG4gIERlY2ltYWxTdHlsZS5vZiA9IGZ1bmN0aW9uIG9mKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgfTtcbiAgRGVjaW1hbFN0eWxlLmF2YWlsYWJsZUxvY2FsZXMgPSBmdW5jdGlvbiBhdmFpbGFibGVMb2NhbGVzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgfTtcbiAgcmV0dXJuIERlY2ltYWxTdHlsZTtcbn0oKTtcbkRlY2ltYWxTdHlsZS5TVEFOREFSRCA9IG5ldyBEZWNpbWFsU3R5bGUoJzAnLCAnKycsICctJywgJy4nKTtcblxudmFyIFNpZ25TdHlsZSA9IGZ1bmN0aW9uIChfRW51bSkge1xuICBfaW5oZXJpdHNMb29zZShTaWduU3R5bGUsIF9FbnVtKTtcbiAgZnVuY3Rpb24gU2lnblN0eWxlKCkge1xuICAgIHJldHVybiBfRW51bS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IFNpZ25TdHlsZS5wcm90b3R5cGU7XG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHBvc2l0aXZlLCBzdHJpY3QsIGZpeGVkV2lkdGgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgU2lnblN0eWxlLk5PUk1BTDpcbiAgICAgICAgcmV0dXJuICFwb3NpdGl2ZSB8fCAhc3RyaWN0O1xuICAgICAgY2FzZSBTaWduU3R5bGUuQUxXQVlTOlxuICAgICAgY2FzZSBTaWduU3R5bGUuRVhDRUVEU19QQUQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICFzdHJpY3QgJiYgIWZpeGVkV2lkdGg7XG4gICAgfVxuICB9O1xuICByZXR1cm4gU2lnblN0eWxlO1xufShFbnVtKTtcblNpZ25TdHlsZS5OT1JNQUwgPSBuZXcgU2lnblN0eWxlKCdOT1JNQUwnKTtcblNpZ25TdHlsZS5ORVZFUiA9IG5ldyBTaWduU3R5bGUoJ05FVkVSJyk7XG5TaWduU3R5bGUuQUxXQVlTID0gbmV3IFNpZ25TdHlsZSgnQUxXQVlTJyk7XG5TaWduU3R5bGUuRVhDRUVEU19QQUQgPSBuZXcgU2lnblN0eWxlKCdFWENFRURTX1BBRCcpO1xuU2lnblN0eWxlLk5PVF9ORUdBVElWRSA9IG5ldyBTaWduU3R5bGUoJ05PVF9ORUdBVElWRScpO1xuXG52YXIgVGV4dFN0eWxlID0gZnVuY3Rpb24gKF9FbnVtKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRleHRTdHlsZSwgX0VudW0pO1xuICBmdW5jdGlvbiBUZXh0U3R5bGUoKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gVGV4dFN0eWxlLnByb3RvdHlwZTtcbiAgX3Byb3RvLmlzU3RhbmRhbG9uZSA9IGZ1bmN0aW9uIGlzU3RhbmRhbG9uZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORTpcbiAgICAgIGNhc2UgVGV4dFN0eWxlLlNIT1JUX1NUQU5EQUxPTkU6XG4gICAgICBjYXNlIFRleHRTdHlsZS5OQVJST1dfU1RBTkRBTE9ORTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uYXNTdGFuZGFsb25lID0gZnVuY3Rpb24gYXNTdGFuZGFsb25lKCkge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBUZXh0U3R5bGUuRlVMTDpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5GVUxMX1NUQU5EQUxPTkU7XG4gICAgICBjYXNlIFRleHRTdHlsZS5TSE9SVDpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5TSE9SVF9TVEFOREFMT05FO1xuICAgICAgY2FzZSBUZXh0U3R5bGUuTkFSUk9XOlxuICAgICAgICByZXR1cm4gVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uYXNOb3JtYWwgPSBmdW5jdGlvbiBhc05vcm1hbCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORTpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5GVUxMO1xuICAgICAgY2FzZSBUZXh0U3R5bGUuU0hPUlRfU1RBTkRBTE9ORTpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5TSE9SVDtcbiAgICAgIGNhc2UgVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FOlxuICAgICAgICByZXR1cm4gVGV4dFN0eWxlLk5BUlJPVztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRleHRTdHlsZTtcbn0oRW51bSk7XG5UZXh0U3R5bGUuRlVMTCA9IG5ldyBUZXh0U3R5bGUoJ0ZVTEwnKTtcblRleHRTdHlsZS5GVUxMX1NUQU5EQUxPTkUgPSBuZXcgVGV4dFN0eWxlKCdGVUxMX1NUQU5EQUxPTkUnKTtcblRleHRTdHlsZS5TSE9SVCA9IG5ldyBUZXh0U3R5bGUoJ1NIT1JUJyk7XG5UZXh0U3R5bGUuU0hPUlRfU1RBTkRBTE9ORSA9IG5ldyBUZXh0U3R5bGUoJ1NIT1JUX1NUQU5EQUxPTkUnKTtcblRleHRTdHlsZS5OQVJST1cgPSBuZXcgVGV4dFN0eWxlKCdOQVJST1cnKTtcblRleHRTdHlsZS5OQVJST1dfU1RBTkRBTE9ORSA9IG5ldyBUZXh0U3R5bGUoJ05BUlJPV19TVEFOREFMT05FJyk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxudmFyIENoYXJMaXRlcmFsUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyKGxpdGVyYWwpIHtcbiAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiaW52YWxpZCBsaXRlcmFsLCB0b28gbG9uZzogXFxcIlwiICsgbGl0ZXJhbCArIFwiXFxcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5fbGl0ZXJhbCA9IGxpdGVyYWw7XG4gIH1cbiAgdmFyIF9wcm90byA9IENoYXJMaXRlcmFsUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIGJ1Zi5hcHBlbmQodGhpcy5fbGl0ZXJhbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cbiAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChwb3NpdGlvbik7XG4gICAgaWYgKGNvbnRleHQuY2hhckVxdWFscyh0aGlzLl9saXRlcmFsLCBjaCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb24gKyB0aGlzLl9saXRlcmFsLmxlbmd0aDtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2xpdGVyYWwgPT09ICdcXCcnKSB7XG4gICAgICByZXR1cm4gXCInJ1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCInXCIgKyB0aGlzLl9saXRlcmFsICsgXCInXCI7XG4gIH07XG4gIHJldHVybiBDaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXI7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi92YXIgQ29tcG9zaXRlUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tcG9zaXRlUHJpbnRlclBhcnNlcihwcmludGVyUGFyc2Vycywgb3B0aW9uYWwpIHtcbiAgICB0aGlzLl9wcmludGVyUGFyc2VycyA9IHByaW50ZXJQYXJzZXJzO1xuICAgIHRoaXMuX29wdGlvbmFsID0gb3B0aW9uYWw7XG4gIH1cbiAgdmFyIF9wcm90byA9IENvbXBvc2l0ZVByaW50ZXJQYXJzZXIucHJvdG90eXBlO1xuICBfcHJvdG8ud2l0aE9wdGlvbmFsID0gZnVuY3Rpb24gd2l0aE9wdGlvbmFsKG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsID09PSB0aGlzLl9vcHRpb25hbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcG9zaXRlUHJpbnRlclBhcnNlcih0aGlzLl9wcmludGVyUGFyc2Vycywgb3B0aW9uYWwpO1xuICB9O1xuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgbGVuZ3RoID0gYnVmLmxlbmd0aCgpO1xuICAgIGlmICh0aGlzLl9vcHRpb25hbCkge1xuICAgICAgY29udGV4dC5zdGFydE9wdGlvbmFsKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcCA9IHRoaXMuX3ByaW50ZXJQYXJzZXJzW2ldO1xuICAgICAgICBpZiAocHAucHJpbnQoY29udGV4dCwgYnVmKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBidWYuc2V0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbmFsKSB7XG4gICAgICAgIGNvbnRleHQuZW5kT3B0aW9uYWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbmFsKSB7XG4gICAgICBjb250ZXh0LnN0YXJ0T3B0aW9uYWwoKTtcbiAgICAgIHZhciBwb3MgPSBwb3NpdGlvbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcHJpbnRlclBhcnNlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBwID0gdGhpcy5fcHJpbnRlclBhcnNlcnNbaV07XG4gICAgICAgIHBvcyA9IHBwLnBhcnNlKGNvbnRleHQsIHRleHQsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgY29udGV4dC5lbmRPcHRpb25hbChmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250ZXh0LmVuZE9wdGlvbmFsKHRydWUpO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3BwID0gdGhpcy5fcHJpbnRlclBhcnNlcnNbX2ldO1xuICAgICAgICBwb3NpdGlvbiA9IF9wcC5wYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbik7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIGlmICh0aGlzLl9wcmludGVyUGFyc2VycyAhPSBudWxsKSB7XG4gICAgICBidWYgKz0gdGhpcy5fb3B0aW9uYWwgPyAnWycgOiAnKCc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcCA9IHRoaXMuX3ByaW50ZXJQYXJzZXJzW2ldO1xuICAgICAgICBidWYgKz0gcHAudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGJ1ZiArPSB0aGlzLl9vcHRpb25hbCA/ICddJyA6ICcpJztcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfTtcbiAgcmV0dXJuIENvbXBvc2l0ZVByaW50ZXJQYXJzZXI7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxudmFyIEZyYWN0aW9uUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhY3Rpb25QcmludGVyUGFyc2VyKGZpZWxkLCBtaW5XaWR0aCwgbWF4V2lkdGgsIGRlY2ltYWxQb2ludCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICBpZiAoZmllbGQucmFuZ2UoKS5pc0ZpeGVkKCkgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiRmllbGQgbXVzdCBoYXZlIGEgZml4ZWQgc2V0IG9mIHZhbHVlczogXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIGlmIChtaW5XaWR0aCA8IDAgfHwgbWluV2lkdGggPiA5KSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiTWluaW11bSB3aWR0aCBtdXN0IGJlIGZyb20gMCB0byA5IGluY2x1c2l2ZSBidXQgd2FzIFwiICsgbWluV2lkdGgpO1xuICAgIH1cbiAgICBpZiAobWF4V2lkdGggPCAxIHx8IG1heFdpZHRoID4gOSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIk1heGltdW0gd2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gOSBpbmNsdXNpdmUgYnV0IHdhcyBcIiArIG1heFdpZHRoKTtcbiAgICB9XG4gICAgaWYgKG1heFdpZHRoIDwgbWluV2lkdGgpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJNYXhpbXVtIHdpZHRoIG11c3QgZXhjZWVkIG9yIGVxdWFsIHRoZSBtaW5pbXVtIHdpZHRoIGJ1dCBcIiArIG1heFdpZHRoICsgXCIgPCBcIiArIG1pbldpZHRoKTtcbiAgICB9XG4gICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgIHRoaXMubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5kZWNpbWFsUG9pbnQgPSBkZWNpbWFsUG9pbnQ7XG4gIH1cbiAgdmFyIF9wcm90byA9IEZyYWN0aW9uUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQuZ2V0VmFsdWUodGhpcy5maWVsZCk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBzeW1ib2xzID0gY29udGV4dC5zeW1ib2xzKCk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVjaW1hbFBvaW50KSB7XG4gICAgICAgICAgYnVmLmFwcGVuZChzeW1ib2xzLmRlY2ltYWxTZXBhcmF0b3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1pbldpZHRoOyBpKyspIHtcbiAgICAgICAgICBidWYuYXBwZW5kKHN5bWJvbHMuemVyb0RpZ2l0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmcmFjdGlvbiA9IHRoaXMuY29udmVydFRvRnJhY3Rpb24odmFsdWUsIHN5bWJvbHMuemVyb0RpZ2l0KCkpO1xuICAgICAgdmFyIG91dHB1dFNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgoZnJhY3Rpb24ubGVuZ3RoLCB0aGlzLm1pbldpZHRoKSwgdGhpcy5tYXhXaWR0aCk7XG4gICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnN1YnN0cigwLCBvdXRwdXRTY2FsZSk7XG4gICAgICBpZiAoZnJhY3Rpb24gKiAxID4gMCkge1xuICAgICAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoID4gdGhpcy5taW5XaWR0aCAmJiBmcmFjdGlvbltmcmFjdGlvbi5sZW5ndGggLSAxXSA9PT0gJzAnKSB7XG4gICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHIoMCwgZnJhY3Rpb24ubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdHIgPSBmcmFjdGlvbjtcbiAgICAgIHN0ciA9IHN5bWJvbHMuY29udmVydE51bWJlclRvSTE4TihzdHIpO1xuICAgICAgaWYgKHRoaXMuZGVjaW1hbFBvaW50KSB7XG4gICAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy5kZWNpbWFsU2VwYXJhdG9yKCkpO1xuICAgICAgfVxuICAgICAgYnVmLmFwcGVuZChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWZmZWN0aXZlTWluID0gY29udGV4dC5pc1N0cmljdCgpID8gdGhpcy5taW5XaWR0aCA6IDA7XG4gICAgdmFyIGVmZmVjdGl2ZU1heCA9IGNvbnRleHQuaXNTdHJpY3QoKSA/IHRoaXMubWF4V2lkdGggOiA5O1xuICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAocG9zaXRpb24gPT09IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGVmZmVjdGl2ZU1pbiA+IDAgPyB+cG9zaXRpb24gOiBwb3NpdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVjaW1hbFBvaW50KSB7XG4gICAgICBpZiAodGV4dFtwb3NpdGlvbl0gIT09IGNvbnRleHQuc3ltYm9scygpLmRlY2ltYWxTZXBhcmF0b3IoKSkge1xuICAgICAgICByZXR1cm4gZWZmZWN0aXZlTWluID4gMCA/IH5wb3NpdGlvbiA6IHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgcG9zaXRpb24rKztcbiAgICB9XG4gICAgdmFyIG1pbkVuZFBvcyA9IHBvc2l0aW9uICsgZWZmZWN0aXZlTWluO1xuICAgIGlmIChtaW5FbmRQb3MgPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuICAgIHZhciBtYXhFbmRQb3MgPSBNYXRoLm1pbihwb3NpdGlvbiArIGVmZmVjdGl2ZU1heCwgbGVuZ3RoKTtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbjtcbiAgICB3aGlsZSAocG9zIDwgbWF4RW5kUG9zKSB7XG4gICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChwb3MrKyk7XG4gICAgICB2YXIgZGlnaXQgPSBjb250ZXh0LnN5bWJvbHMoKS5jb252ZXJ0VG9EaWdpdChjaCk7XG4gICAgICBpZiAoZGlnaXQgPCAwKSB7XG4gICAgICAgIGlmIChwb3MgPCBtaW5FbmRQb3MpIHtcbiAgICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHBvcy0tO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRvdGFsID0gdG90YWwgKiAxMCArIGRpZ2l0O1xuICAgIH1cbiAgICB2YXIgbW92ZUxlZnQgPSBwb3MgLSBwb3NpdGlvbjtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygxMCwgbW92ZUxlZnQpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuY29udmVydEZyb21GcmFjdGlvbih0b3RhbCwgc2NhbGUpO1xuICAgIHJldHVybiBjb250ZXh0LnNldFBhcnNlZEZpZWxkKHRoaXMuZmllbGQsIHZhbHVlLCBwb3NpdGlvbiwgcG9zKTtcbiAgfTtcbiAgX3Byb3RvLmNvbnZlcnRUb0ZyYWN0aW9uID0gZnVuY3Rpb24gY29udmVydFRvRnJhY3Rpb24odmFsdWUsIHplcm9EaWdpdCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuZmllbGQucmFuZ2UoKTtcbiAgICByYW5nZS5jaGVja1ZhbGlkVmFsdWUodmFsdWUsIHRoaXMuZmllbGQpO1xuICAgIHZhciBfbWluID0gcmFuZ2UubWluaW11bSgpO1xuICAgIHZhciBfcmFuZ2UgPSByYW5nZS5tYXhpbXVtKCkgLSBfbWluICsgMTtcbiAgICB2YXIgX3ZhbHVlID0gdmFsdWUgLSBfbWluO1xuICAgIHZhciBfc2NhbGVkID0gTWF0aFV0aWwuaW50RGl2KF92YWx1ZSAqIDEwMDAwMDAwMDAsIF9yYW5nZSk7XG4gICAgdmFyIGZyYWN0aW9uID0gXCJcIiArIF9zY2FsZWQ7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDkpIHtcbiAgICAgIGZyYWN0aW9uID0gemVyb0RpZ2l0ICsgZnJhY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBmcmFjdGlvbjtcbiAgfTtcbiAgX3Byb3RvLmNvbnZlcnRGcm9tRnJhY3Rpb24gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbUZyYWN0aW9uKHRvdGFsLCBzY2FsZSkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuZmllbGQucmFuZ2UoKTtcbiAgICB2YXIgX21pbiA9IHJhbmdlLm1pbmltdW0oKTtcbiAgICB2YXIgX3JhbmdlID0gcmFuZ2UubWF4aW11bSgpIC0gX21pbiArIDE7XG4gICAgdmFyIF92YWx1ZSA9IE1hdGhVdGlsLmludERpdih0b3RhbCAqIF9yYW5nZSwgc2NhbGUpO1xuICAgIHJldHVybiBfdmFsdWU7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBkZWNpbWFsID0gdGhpcy5kZWNpbWFsUG9pbnQgPyAnLERlY2ltYWxQb2ludCcgOiAnJztcbiAgICByZXR1cm4gXCJGcmFjdGlvbihcIiArIHRoaXMuZmllbGQgKyBcIixcIiArIHRoaXMubWluV2lkdGggKyBcIixcIiArIHRoaXMubWF4V2lkdGggKyBkZWNpbWFsICsgXCIpXCI7XG4gIH07XG4gIHJldHVybiBGcmFjdGlvblByaW50ZXJQYXJzZXI7XG59KCk7XG5cbnZhciBNQVhfV0lEVEgkMSA9IDE1O1xudmFyIEVYQ0VFRF9QT0lOVFMgPSBbMCwgMTAsIDEwMCwgMTAwMCwgMTAwMDAsIDEwMDAwMCwgMTAwMDAwMCwgMTAwMDAwMDAsIDEwMDAwMDAwMCwgMTAwMDAwMDAwMF07XG52YXIgTnVtYmVyUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTnVtYmVyUHJpbnRlclBhcnNlcihmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBzaWduU3R5bGUsIHN1YnNlcXVlbnRXaWR0aCkge1xuICAgIGlmIChzdWJzZXF1ZW50V2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgc3Vic2VxdWVudFdpZHRoID0gMDtcbiAgICB9XG4gICAgdGhpcy5fZmllbGQgPSBmaWVsZDtcbiAgICB0aGlzLl9taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgIHRoaXMuX21heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5fc2lnblN0eWxlID0gc2lnblN0eWxlO1xuICAgIHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA9IHN1YnNlcXVlbnRXaWR0aDtcbiAgfVxuICB2YXIgX3Byb3RvID0gTnVtYmVyUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90by5maWVsZCA9IGZ1bmN0aW9uIGZpZWxkKCkge1xuICAgIHJldHVybiB0aGlzLl9maWVsZDtcbiAgfTtcbiAgX3Byb3RvLm1pbldpZHRoID0gZnVuY3Rpb24gbWluV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbldpZHRoO1xuICB9O1xuICBfcHJvdG8ubWF4V2lkdGggPSBmdW5jdGlvbiBtYXhXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4V2lkdGg7XG4gIH07XG4gIF9wcm90by5zaWduU3R5bGUgPSBmdW5jdGlvbiBzaWduU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25TdHlsZTtcbiAgfTtcbiAgX3Byb3RvLndpdGhGaXhlZFdpZHRoID0gZnVuY3Rpb24gd2l0aEZpeGVkV2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE51bWJlclByaW50ZXJQYXJzZXIodGhpcy5fZmllbGQsIHRoaXMuX21pbldpZHRoLCB0aGlzLl9tYXhXaWR0aCwgdGhpcy5fc2lnblN0eWxlLCAtMSk7XG4gIH07XG4gIF9wcm90by53aXRoU3Vic2VxdWVudFdpZHRoID0gZnVuY3Rpb24gd2l0aFN1YnNlcXVlbnRXaWR0aChzdWJzZXF1ZW50V2lkdGgpIHtcbiAgICByZXR1cm4gbmV3IE51bWJlclByaW50ZXJQYXJzZXIodGhpcy5fZmllbGQsIHRoaXMuX21pbldpZHRoLCB0aGlzLl9tYXhXaWR0aCwgdGhpcy5fc2lnblN0eWxlLCB0aGlzLl9zdWJzZXF1ZW50V2lkdGggKyBzdWJzZXF1ZW50V2lkdGgpO1xuICB9O1xuICBfcHJvdG8uX2lzRml4ZWRXaWR0aCA9IGZ1bmN0aW9uIF9pc0ZpeGVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA9PT0gLTEgfHwgdGhpcy5fc3Vic2VxdWVudFdpZHRoID4gMCAmJiB0aGlzLl9taW5XaWR0aCA9PT0gdGhpcy5fbWF4V2lkdGggJiYgdGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuTk9UX05FR0FUSVZFO1xuICB9O1xuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgY29udGV4dFZhbHVlID0gY29udGV4dC5nZXRWYWx1ZSh0aGlzLl9maWVsZCk7XG4gICAgaWYgKGNvbnRleHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKGNvbnRleHQsIGNvbnRleHRWYWx1ZSk7XG4gICAgdmFyIHN5bWJvbHMgPSBjb250ZXh0LnN5bWJvbHMoKTtcbiAgICB2YXIgc3RyID0gXCJcIiArIE1hdGguYWJzKHZhbHVlKTtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IHRoaXMuX21heFdpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJGaWVsZCBcIiArIHRoaXMuX2ZpZWxkICsgXCIgY2Fubm90IGJlIHByaW50ZWQgYXMgdGhlIHZhbHVlIFwiICsgdmFsdWUgKyBcIiBleGNlZWRzIHRoZSBtYXhpbXVtIHByaW50IHdpZHRoIG9mIFwiICsgdGhpcy5fbWF4V2lkdGgpO1xuICAgIH1cbiAgICBzdHIgPSBzeW1ib2xzLmNvbnZlcnROdW1iZXJUb0kxOE4oc3RyKTtcbiAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgc3dpdGNoICh0aGlzLl9zaWduU3R5bGUpIHtcbiAgICAgICAgY2FzZSBTaWduU3R5bGUuRVhDRUVEU19QQUQ6XG4gICAgICAgICAgaWYgKHRoaXMuX21pbldpZHRoIDwgTUFYX1dJRFRIJDEgJiYgdmFsdWUgPj0gRVhDRUVEX1BPSU5UU1t0aGlzLl9taW5XaWR0aF0pIHtcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy5wb3NpdGl2ZVNpZ24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNpZ25TdHlsZS5BTFdBWVM6XG4gICAgICAgICAgYnVmLmFwcGVuZChzeW1ib2xzLnBvc2l0aXZlU2lnbigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLl9zaWduU3R5bGUpIHtcbiAgICAgICAgY2FzZSBTaWduU3R5bGUuTk9STUFMOlxuICAgICAgICBjYXNlIFNpZ25TdHlsZS5FWENFRURTX1BBRDpcbiAgICAgICAgY2FzZSBTaWduU3R5bGUuQUxXQVlTOlxuICAgICAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy5uZWdhdGl2ZVNpZ24oKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2lnblN0eWxlLk5PVF9ORUdBVElWRTpcbiAgICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJGaWVsZCBcIiArIHRoaXMuX2ZpZWxkICsgXCIgY2Fubm90IGJlIHByaW50ZWQgYXMgdGhlIHZhbHVlIFwiICsgdmFsdWUgKyBcIiBjYW5ub3QgYmUgbmVnYXRpdmUgYWNjb3JkaW5nIHRvIHRoZSBTaWduU3R5bGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbWluV2lkdGggLSBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy56ZXJvRGlnaXQoKSk7XG4gICAgfVxuICAgIGJ1Zi5hcHBlbmQoc3RyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuICAgIGFzc2VydChwb3NpdGlvbiA+PSAwICYmIHBvc2l0aW9uIDwgbGVuZ3RoKTtcbiAgICB2YXIgc2lnbiA9IHRleHQuY2hhckF0KHBvc2l0aW9uKTtcbiAgICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcbiAgICBpZiAoc2lnbiA9PT0gY29udGV4dC5zeW1ib2xzKCkucG9zaXRpdmVTaWduKCkpIHtcbiAgICAgIGlmICh0aGlzLl9zaWduU3R5bGUucGFyc2UodHJ1ZSwgY29udGV4dC5pc1N0cmljdCgpLCB0aGlzLl9taW5XaWR0aCA9PT0gdGhpcy5fbWF4V2lkdGgpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgcG9zaXRpdmUgPSB0cnVlO1xuICAgICAgcG9zaXRpb24rKztcbiAgICB9IGVsc2UgaWYgKHNpZ24gPT09IGNvbnRleHQuc3ltYm9scygpLm5lZ2F0aXZlU2lnbigpKSB7XG4gICAgICBpZiAodGhpcy5fc2lnblN0eWxlLnBhcnNlKGZhbHNlLCBjb250ZXh0LmlzU3RyaWN0KCksIHRoaXMuX21pbldpZHRoID09PSB0aGlzLl9tYXhXaWR0aCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICB9XG4gICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICBwb3NpdGlvbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuQUxXQVlTICYmIGNvbnRleHQuaXNTdHJpY3QoKSkge1xuICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZWZmTWluV2lkdGggPSBjb250ZXh0LmlzU3RyaWN0KCkgfHwgdGhpcy5faXNGaXhlZFdpZHRoKCkgPyB0aGlzLl9taW5XaWR0aCA6IDE7XG4gICAgdmFyIG1pbkVuZFBvcyA9IHBvc2l0aW9uICsgZWZmTWluV2lkdGg7XG4gICAgaWYgKG1pbkVuZFBvcyA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG4gICAgdmFyIGVmZk1heFdpZHRoID0gKGNvbnRleHQuaXNTdHJpY3QoKSB8fCB0aGlzLl9pc0ZpeGVkV2lkdGgoKSA/IHRoaXMuX21heFdpZHRoIDogOSkgKyBNYXRoLm1heCh0aGlzLl9zdWJzZXF1ZW50V2lkdGgsIDApO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uO1xuICAgIGZvciAodmFyIHBhc3MgPSAwOyBwYXNzIDwgMjsgcGFzcysrKSB7XG4gICAgICB2YXIgbWF4RW5kUG9zID0gTWF0aC5taW4ocG9zICsgZWZmTWF4V2lkdGgsIGxlbmd0aCk7XG4gICAgICB3aGlsZSAocG9zIDwgbWF4RW5kUG9zKSB7XG4gICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KHBvcysrKTtcbiAgICAgICAgdmFyIGRpZ2l0ID0gY29udGV4dC5zeW1ib2xzKCkuY29udmVydFRvRGlnaXQoY2gpO1xuICAgICAgICBpZiAoZGlnaXQgPCAwKSB7XG4gICAgICAgICAgcG9zLS07XG4gICAgICAgICAgaWYgKHBvcyA8IG1pbkVuZFBvcykge1xuICAgICAgICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyAtIHBvc2l0aW9uID4gTUFYX1dJRFRIJDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignbnVtYmVyIHRleHQgZXhjZWVkcyBsZW5ndGgnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbCA9IHRvdGFsICogMTAgKyBkaWdpdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA+IDAgJiYgcGFzcyA9PT0gMCkge1xuICAgICAgICB2YXIgcGFyc2VMZW4gPSBwb3MgLSBwb3NpdGlvbjtcbiAgICAgICAgZWZmTWF4V2lkdGggPSBNYXRoLm1heChlZmZNaW5XaWR0aCwgcGFyc2VMZW4gLSB0aGlzLl9zdWJzZXF1ZW50V2lkdGgpO1xuICAgICAgICBwb3MgPSBwb3NpdGlvbjtcbiAgICAgICAgdG90YWwgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgaWYgKHRvdGFsID09PSAwICYmIGNvbnRleHQuaXNTdHJpY3QoKSkge1xuICAgICAgICByZXR1cm4gfihwb3NpdGlvbiAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRvdGFsICE9PSAwKSB7XG4gICAgICAgIHRvdGFsID0gLXRvdGFsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuRVhDRUVEU19QQUQgJiYgY29udGV4dC5pc1N0cmljdCgpKSB7XG4gICAgICB2YXIgX3BhcnNlTGVuID0gcG9zIC0gcG9zaXRpb247XG4gICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgaWYgKF9wYXJzZUxlbiA8PSB0aGlzLl9taW5XaWR0aCkge1xuICAgICAgICAgIHJldHVybiB+KHBvc2l0aW9uIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfcGFyc2VMZW4gPiB0aGlzLl9taW5XaWR0aCkge1xuICAgICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldFZhbHVlKGNvbnRleHQsIHRvdGFsLCBwb3NpdGlvbiwgcG9zKTtcbiAgfTtcbiAgX3Byb3RvLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uIF9nZXRWYWx1ZShjb250ZXh0LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgX3Byb3RvLl9zZXRWYWx1ZSA9IGZ1bmN0aW9uIF9zZXRWYWx1ZShjb250ZXh0LCB2YWx1ZSwgZXJyb3JQb3MsIHN1Y2Nlc3NQb3MpIHtcbiAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZCh0aGlzLl9maWVsZCwgdmFsdWUsIGVycm9yUG9zLCBzdWNjZXNzUG9zKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuX21pbldpZHRoID09PSAxICYmIHRoaXMuX21heFdpZHRoID09PSBNQVhfV0lEVEgkMSAmJiB0aGlzLl9zaWduU3R5bGUgPT09IFNpZ25TdHlsZS5OT1JNQUwpIHtcbiAgICAgIHJldHVybiBcIlZhbHVlKFwiICsgdGhpcy5fZmllbGQgKyBcIilcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX21pbldpZHRoID09PSB0aGlzLl9tYXhXaWR0aCAmJiB0aGlzLl9zaWduU3R5bGUgPT09IFNpZ25TdHlsZS5OT1RfTkVHQVRJVkUpIHtcbiAgICAgIHJldHVybiBcIlZhbHVlKFwiICsgdGhpcy5fZmllbGQgKyBcIixcIiArIHRoaXMuX21pbldpZHRoICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlZhbHVlKFwiICsgdGhpcy5fZmllbGQgKyBcIixcIiArIHRoaXMuX21pbldpZHRoICsgXCIsXCIgKyB0aGlzLl9tYXhXaWR0aCArIFwiLFwiICsgdGhpcy5fc2lnblN0eWxlICsgXCIpXCI7XG4gIH07XG4gIHJldHVybiBOdW1iZXJQcmludGVyUGFyc2VyO1xufSgpO1xudmFyIFJlZHVjZWRQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gKF9OdW1iZXJQcmludGVyUGFyc2VyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlZHVjZWRQcmludGVyUGFyc2VyLCBfTnVtYmVyUHJpbnRlclBhcnNlcik7XG4gIGZ1bmN0aW9uIFJlZHVjZWRQcmludGVyUGFyc2VyKGZpZWxkLCB3aWR0aCwgbWF4V2lkdGgsIGJhc2VWYWx1ZSwgYmFzZURhdGUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfTnVtYmVyUHJpbnRlclBhcnNlci5jYWxsKHRoaXMsIGZpZWxkLCB3aWR0aCwgbWF4V2lkdGgsIFNpZ25TdHlsZS5OT1RfTkVHQVRJVkUpIHx8IHRoaXM7XG4gICAgaWYgKHdpZHRoIDwgMSB8fCB3aWR0aCA+IDEwKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVGhlIHdpZHRoIG11c3QgYmUgZnJvbSAxIHRvIDEwIGluY2x1c2l2ZSBidXQgd2FzIFwiICsgd2lkdGgpO1xuICAgIH1cbiAgICBpZiAobWF4V2lkdGggPCAxIHx8IG1heFdpZHRoID4gMTApIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgbWF4V2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gMTAgaW5jbHVzaXZlIGJ1dCB3YXMgXCIgKyBtYXhXaWR0aCk7XG4gICAgfVxuICAgIGlmIChtYXhXaWR0aCA8IHdpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUaGUgbWF4V2lkdGggbXVzdCBiZSBncmVhdGVyIHRoYW4gdGhlIHdpZHRoJyk7XG4gICAgfVxuICAgIGlmIChiYXNlRGF0ZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGZpZWxkLnJhbmdlKCkuaXNWYWxpZFZhbHVlKGJhc2VWYWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RoZSBiYXNlIHZhbHVlIG11c3QgYmUgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgZmllbGQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlVmFsdWUgKyBFWENFRURfUE9JTlRTW3dpZHRoXSA+IE1hdGhVdGlsLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbmFibGUgdG8gYWRkIHByaW50ZXItcGFyc2VyIGFzIHRoZSByYW5nZSBleGNlZWRzIHRoZSBjYXBhY2l0eSBvZiBhbiBpbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMuX2Jhc2VWYWx1ZSA9IGJhc2VWYWx1ZTtcbiAgICBfdGhpcy5fYmFzZURhdGUgPSBiYXNlRGF0ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90bzIgPSBSZWR1Y2VkUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90bzIuX2dldFZhbHVlID0gZnVuY3Rpb24gX2dldFZhbHVlKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgdmFyIGFic1ZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuICAgIHZhciBiYXNlVmFsdWUgPSB0aGlzLl9iYXNlVmFsdWU7XG4gICAgaWYgKHRoaXMuX2Jhc2VEYXRlICE9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnRlbXBvcmFsKCk7XG4gICAgICB2YXIgY2hyb25vID0gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICAgIGJhc2VWYWx1ZSA9IGNocm9uby5kYXRlKHRoaXMuX2Jhc2VEYXRlKS5nZXQodGhpcy5fZmllbGQpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gYmFzZVZhbHVlICYmIHZhbHVlIDwgYmFzZVZhbHVlICsgRVhDRUVEX1BPSU5UU1t0aGlzLl9taW5XaWR0aF0pIHtcbiAgICAgIHJldHVybiBhYnNWYWx1ZSAlIEVYQ0VFRF9QT0lOVFNbdGhpcy5fbWluV2lkdGhdO1xuICAgIH1cbiAgICByZXR1cm4gYWJzVmFsdWUgJSBFWENFRURfUE9JTlRTW3RoaXMuX21heFdpZHRoXTtcbiAgfTtcbiAgX3Byb3RvMi5fc2V0VmFsdWUgPSBmdW5jdGlvbiBfc2V0VmFsdWUoY29udGV4dCwgdmFsdWUsIGVycm9yUG9zLCBzdWNjZXNzUG9zKSB7XG4gICAgdmFyIGJhc2VWYWx1ZSA9IHRoaXMuX2Jhc2VWYWx1ZTtcbiAgICBpZiAodGhpcy5fYmFzZURhdGUgIT0gbnVsbCkge1xuICAgICAgdmFyIGNocm9ubyA9IGNvbnRleHQuZ2V0RWZmZWN0aXZlQ2hyb25vbG9neSgpO1xuICAgICAgYmFzZVZhbHVlID0gY2hyb25vLmRhdGUodGhpcy5fYmFzZURhdGUpLmdldCh0aGlzLl9maWVsZCk7XG4gICAgfVxuICAgIHZhciBwYXJzZUxlbiA9IHN1Y2Nlc3NQb3MgLSBlcnJvclBvcztcbiAgICBpZiAocGFyc2VMZW4gPT09IHRoaXMuX21pbldpZHRoICYmIHZhbHVlID49IDApIHtcbiAgICAgIHZhciByYW5nZSA9IEVYQ0VFRF9QT0lOVFNbdGhpcy5fbWluV2lkdGhdO1xuICAgICAgdmFyIGxhc3RQYXJ0ID0gYmFzZVZhbHVlICUgcmFuZ2U7XG4gICAgICB2YXIgYmFzZVBhcnQgPSBiYXNlVmFsdWUgLSBsYXN0UGFydDtcbiAgICAgIGlmIChiYXNlVmFsdWUgPiAwKSB7XG4gICAgICAgIHZhbHVlID0gYmFzZVBhcnQgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gYmFzZVBhcnQgLSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IGJhc2VWYWx1ZSkge1xuICAgICAgICB2YWx1ZSArPSByYW5nZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQodGhpcy5fZmllbGQsIHZhbHVlLCBlcnJvclBvcywgc3VjY2Vzc1Bvcyk7XG4gIH07XG4gIF9wcm90bzIud2l0aEZpeGVkV2lkdGggPSBmdW5jdGlvbiB3aXRoRml4ZWRXaWR0aCgpIHtcbiAgICBpZiAodGhpcy5fc3Vic2VxdWVudFdpZHRoID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkdWNlZFByaW50ZXJQYXJzZXIodGhpcy5fZmllbGQsIHRoaXMuX21pbldpZHRoLCB0aGlzLl9tYXhXaWR0aCwgdGhpcy5fYmFzZVZhbHVlLCB0aGlzLl9iYXNlRGF0ZSk7XG4gIH07XG4gIF9wcm90bzIud2l0aFN1YnNlcXVlbnRXaWR0aCA9IGZ1bmN0aW9uIHdpdGhTdWJzZXF1ZW50V2lkdGgoc3Vic2VxdWVudFdpZHRoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWR1Y2VkUHJpbnRlclBhcnNlcih0aGlzLl9maWVsZCwgdGhpcy5fbWluV2lkdGgsIHRoaXMuX21heFdpZHRoLCB0aGlzLl9iYXNlVmFsdWUsIHRoaXMuX2Jhc2VEYXRlLCB0aGlzLl9zdWJzZXF1ZW50V2lkdGggKyBzdWJzZXF1ZW50V2lkdGgpO1xuICB9O1xuICBfcHJvdG8yLmlzRml4ZWRXaWR0aCA9IGZ1bmN0aW9uIGlzRml4ZWRXaWR0aChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaXNTdHJpY3QoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9OdW1iZXJQcmludGVyUGFyc2VyLnByb3RvdHlwZS5pc0ZpeGVkV2lkdGguY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgfTtcbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlJlZHVjZWRWYWx1ZShcIiArIHRoaXMuX2ZpZWxkICsgXCIsXCIgKyB0aGlzLl9taW5XaWR0aCArIFwiLFwiICsgdGhpcy5fbWF4V2lkdGggKyBcIixcIiArICh0aGlzLl9iYXNlRGF0ZSAhPSBudWxsID8gdGhpcy5fYmFzZURhdGUgOiB0aGlzLl9iYXNlVmFsdWUpICsgXCIpXCI7XG4gIH07XG4gIHJldHVybiBSZWR1Y2VkUHJpbnRlclBhcnNlcjtcbn0oTnVtYmVyUHJpbnRlclBhcnNlcik7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxudmFyIFBBVFRFUk5TID0gWycrSEgnLCAnK0hIbW0nLCAnK0hIOm1tJywgJytISE1NJywgJytISDpNTScsICcrSEhNTXNzJywgJytISDpNTTpzcycsICcrSEhNTVNTJywgJytISDpNTTpTUyddO1xudmFyIE9mZnNldElkUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2Zmc2V0SWRQcmludGVyUGFyc2VyKG5vT2Zmc2V0VGV4dCwgcGF0dGVybikge1xuICAgIHJlcXVpcmVOb25OdWxsKG5vT2Zmc2V0VGV4dCwgJ25vT2Zmc2V0VGV4dCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHBhdHRlcm4sICdwYXR0ZXJuJyk7XG4gICAgdGhpcy5ub09mZnNldFRleHQgPSBub09mZnNldFRleHQ7XG4gICAgdGhpcy50eXBlID0gdGhpcy5fY2hlY2tQYXR0ZXJuKHBhdHRlcm4pO1xuICB9XG4gIHZhciBfcHJvdG8gPSBPZmZzZXRJZFByaW50ZXJQYXJzZXIucHJvdG90eXBlO1xuICBfcHJvdG8uX2NoZWNrUGF0dGVybiA9IGZ1bmN0aW9uIF9jaGVja1BhdHRlcm4ocGF0dGVybikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUEFUVEVSTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChQQVRURVJOU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkludmFsaWQgem9uZSBvZmZzZXQgcGF0dGVybjogXCIgKyBwYXR0ZXJuKTtcbiAgfTtcbiAgX3Byb3RvLnByaW50ID0gZnVuY3Rpb24gcHJpbnQoY29udGV4dCwgYnVmKSB7XG4gICAgdmFyIG9mZnNldFNlY3MgPSBjb250ZXh0LmdldFZhbHVlKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKTtcbiAgICBpZiAob2Zmc2V0U2VjcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0b3RhbFNlY3MgPSBNYXRoVXRpbC5zYWZlVG9JbnQob2Zmc2V0U2Vjcyk7XG4gICAgaWYgKHRvdGFsU2VjcyA9PT0gMCkge1xuICAgICAgYnVmLmFwcGVuZCh0aGlzLm5vT2Zmc2V0VGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhYnNIb3VycyA9IE1hdGguYWJzKE1hdGhVdGlsLmludE1vZChNYXRoVXRpbC5pbnREaXYodG90YWxTZWNzLCAzNjAwKSwgMTAwKSk7XG4gICAgICB2YXIgYWJzTWludXRlcyA9IE1hdGguYWJzKE1hdGhVdGlsLmludE1vZChNYXRoVXRpbC5pbnREaXYodG90YWxTZWNzLCA2MCksIDYwKSk7XG4gICAgICB2YXIgYWJzU2Vjb25kcyA9IE1hdGguYWJzKE1hdGhVdGlsLmludE1vZCh0b3RhbFNlY3MsIDYwKSk7XG4gICAgICB2YXIgYnVmUG9zID0gYnVmLmxlbmd0aCgpO1xuICAgICAgdmFyIG91dHB1dCA9IGFic0hvdXJzO1xuICAgICAgYnVmLmFwcGVuZCh0b3RhbFNlY3MgPCAwID8gJy0nIDogJysnKS5hcHBlbmRDaGFyKE1hdGhVdGlsLmludERpdihhYnNIb3VycywgMTApICsgXCIwXCIpLmFwcGVuZENoYXIoTWF0aFV0aWwuaW50TW9kKGFic0hvdXJzLCAxMCkgKyBcIjBcIik7XG4gICAgICBpZiAodGhpcy50eXBlID49IDMgfHwgdGhpcy50eXBlID49IDEgJiYgYWJzTWludXRlcyA+IDApIHtcbiAgICAgICAgYnVmLmFwcGVuZCh0aGlzLnR5cGUgJSAyID09PSAwID8gJzonIDogJycpLmFwcGVuZENoYXIoTWF0aFV0aWwuaW50RGl2KGFic01pbnV0ZXMsIDEwKSArIFwiMFwiKS5hcHBlbmRDaGFyKGFic01pbnV0ZXMgJSAxMCArIFwiMFwiKTtcbiAgICAgICAgb3V0cHV0ICs9IGFic01pbnV0ZXM7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPj0gNyB8fCB0aGlzLnR5cGUgPj0gNSAmJiBhYnNTZWNvbmRzID4gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQodGhpcy50eXBlICUgMiA9PT0gMCA/ICc6JyA6ICcnKS5hcHBlbmRDaGFyKE1hdGhVdGlsLmludERpdihhYnNTZWNvbmRzLCAxMCkgKyBcIjBcIikuYXBwZW5kQ2hhcihhYnNTZWNvbmRzICUgMTAgKyBcIjBcIik7XG4gICAgICAgICAgb3V0cHV0ICs9IGFic1NlY29uZHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXQgPT09IDApIHtcbiAgICAgICAgYnVmLnNldExlbmd0aChidWZQb3MpO1xuICAgICAgICBidWYuYXBwZW5kKHRoaXMubm9PZmZzZXRUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIHZhciBub09mZnNldExlbiA9IHRoaXMubm9PZmZzZXRUZXh0Lmxlbmd0aDtcbiAgICBpZiAobm9PZmZzZXRMZW4gPT09IDApIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnNldFBhcnNlZEZpZWxkKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTLCAwLCBwb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuc3ViU2VxdWVuY2VFcXVhbHModGV4dCwgcG9zaXRpb24sIHRoaXMubm9PZmZzZXRUZXh0LCAwLCBub09mZnNldExlbikpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMsIDAsIHBvc2l0aW9uLCBwb3NpdGlvbiArIG5vT2Zmc2V0TGVuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNpZ24gPSB0ZXh0W3Bvc2l0aW9uXTtcbiAgICBpZiAoc2lnbiA9PT0gJysnIHx8IHNpZ24gPT09ICctJykge1xuICAgICAgdmFyIG5lZ2F0aXZlID0gc2lnbiA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgdmFyIGFycmF5ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgYXJyYXlbMF0gPSBwb3NpdGlvbiArIDE7XG4gICAgICBpZiAoKHRoaXMuX3BhcnNlTnVtYmVyKGFycmF5LCAxLCB0ZXh0LCB0cnVlKSB8fCB0aGlzLl9wYXJzZU51bWJlcihhcnJheSwgMiwgdGV4dCwgdGhpcy50eXBlID49IDMpIHx8IHRoaXMuX3BhcnNlTnVtYmVyKGFycmF5LCAzLCB0ZXh0LCBmYWxzZSkpID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgb2Zmc2V0U2VjcyA9IE1hdGhVdGlsLnNhZmVaZXJvKG5lZ2F0aXZlICogKGFycmF5WzFdICogMzYwMCArIGFycmF5WzJdICogNjAgKyBhcnJheVszXSkpO1xuICAgICAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgb2Zmc2V0U2VjcywgcG9zaXRpb24sIGFycmF5WzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vT2Zmc2V0TGVuID09PSAwKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgMCwgcG9zaXRpb24sIHBvc2l0aW9uICsgbm9PZmZzZXRMZW4pO1xuICAgIH1cbiAgICByZXR1cm4gfnBvc2l0aW9uO1xuICB9O1xuICBfcHJvdG8uX3BhcnNlTnVtYmVyID0gZnVuY3Rpb24gX3BhcnNlTnVtYmVyKGFycmF5LCBhcnJheUluZGV4LCBwYXJzZVRleHQsIHJlcXVpcmVkKSB7XG4gICAgaWYgKCh0aGlzLnR5cGUgKyAzKSAvIDIgPCBhcnJheUluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwb3MgPSBhcnJheVswXTtcbiAgICBpZiAodGhpcy50eXBlICUgMiA9PT0gMCAmJiBhcnJheUluZGV4ID4gMSkge1xuICAgICAgaWYgKHBvcyArIDEgPiBwYXJzZVRleHQubGVuZ3RoIHx8IHBhcnNlVGV4dFtwb3NdICE9PSAnOicpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVkO1xuICAgICAgfVxuICAgICAgcG9zKys7XG4gICAgfVxuICAgIGlmIChwb3MgKyAyID4gcGFyc2VUZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkO1xuICAgIH1cbiAgICB2YXIgY2gxID0gcGFyc2VUZXh0W3BvcysrXTtcbiAgICB2YXIgY2gyID0gcGFyc2VUZXh0W3BvcysrXTtcbiAgICBpZiAoY2gxIDwgJzAnIHx8IGNoMSA+ICc5JyB8fCBjaDIgPCAnMCcgfHwgY2gyID4gJzknKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWQ7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IChjaDEuY2hhckNvZGVBdCgwKSAtIDQ4KSAqIDEwICsgKGNoMi5jaGFyQ29kZUF0KDApIC0gNDgpO1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiA1OSkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkO1xuICAgIH1cbiAgICBhcnJheVthcnJheUluZGV4XSA9IHZhbHVlO1xuICAgIGFycmF5WzBdID0gcG9zO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IHRoaXMubm9PZmZzZXRUZXh0LnJlcGxhY2UoJ1xcJycsICdcXCdcXCcnKTtcbiAgICByZXR1cm4gXCJPZmZzZXQoXCIgKyBQQVRURVJOU1t0aGlzLnR5cGVdICsgXCIsJ1wiICsgY29udmVydGVkICsgXCInKVwiO1xuICB9O1xuICByZXR1cm4gT2Zmc2V0SWRQcmludGVyUGFyc2VyO1xufSgpO1xuT2Zmc2V0SWRQcmludGVyUGFyc2VyLklOU1RBTkNFX0lEID0gbmV3IE9mZnNldElkUHJpbnRlclBhcnNlcignWicsICcrSEg6TU06c3MnKTtcbk9mZnNldElkUHJpbnRlclBhcnNlci5QQVRURVJOUyA9IFBBVFRFUk5TO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yKHByaW50ZXJQYXJzZXIsIHBhZFdpZHRoLCBwYWRDaGFyKSB7XG4gICAgdGhpcy5fcHJpbnRlclBhcnNlciA9IHByaW50ZXJQYXJzZXI7XG4gICAgdGhpcy5fcGFkV2lkdGggPSBwYWRXaWR0aDtcbiAgICB0aGlzLl9wYWRDaGFyID0gcGFkQ2hhcjtcbiAgfVxuICB2YXIgX3Byb3RvID0gUGFkUHJpbnRlclBhcnNlckRlY29yYXRvci5wcm90b3R5cGU7XG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIHZhciBwcmVMZW4gPSBidWYubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuX3ByaW50ZXJQYXJzZXIucHJpbnQoY29udGV4dCwgYnVmKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGgoKSAtIHByZUxlbjtcbiAgICBpZiAobGVuID4gdGhpcy5fcGFkV2lkdGgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkNhbm5vdCBwcmludCBhcyBvdXRwdXQgb2YgXCIgKyBsZW4gKyBcIiBjaGFyYWN0ZXJzIGV4Y2VlZHMgcGFkIHdpZHRoIG9mIFwiICsgdGhpcy5fcGFkV2lkdGgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BhZFdpZHRoIC0gbGVuOyBpKyspIHtcbiAgICAgIGJ1Zi5pbnNlcnQocHJlTGVuLCB0aGlzLl9wYWRDaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHN0cmljdCA9IGNvbnRleHQuaXNTdHJpY3QoKTtcbiAgICB2YXIgY2FzZVNlbnNpdGl2ZSA9IGNvbnRleHQuaXNDYXNlU2Vuc2l0aXZlKCk7XG4gICAgYXNzZXJ0KCEocG9zaXRpb24gPiB0ZXh0Lmxlbmd0aCkpO1xuICAgIGFzc2VydChwb3NpdGlvbiA+PSAwKTtcbiAgICBpZiAocG9zaXRpb24gPT09IHRleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cbiAgICB2YXIgZW5kUG9zID0gcG9zaXRpb24gKyB0aGlzLl9wYWRXaWR0aDtcbiAgICBpZiAoZW5kUG9zID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGVuZFBvcyA9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcG9zID0gcG9zaXRpb247XG4gICAgd2hpbGUgKHBvcyA8IGVuZFBvcyAmJiAoY2FzZVNlbnNpdGl2ZSA/IHRleHRbcG9zXSA9PT0gdGhpcy5fcGFkQ2hhciA6IGNvbnRleHQuY2hhckVxdWFscyh0ZXh0W3Bvc10sIHRoaXMuX3BhZENoYXIpKSkge1xuICAgICAgcG9zKys7XG4gICAgfVxuICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBlbmRQb3MpO1xuICAgIHZhciByZXN1bHRQb3MgPSB0aGlzLl9wcmludGVyUGFyc2VyLnBhcnNlKGNvbnRleHQsIHRleHQsIHBvcyk7XG4gICAgaWYgKHJlc3VsdFBvcyAhPT0gZW5kUG9zICYmIHN0cmljdCkge1xuICAgICAgcmV0dXJuIH4ocG9zaXRpb24gKyBwb3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0UG9zO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJQYWQoXCIgKyB0aGlzLl9wcmludGVyUGFyc2VyICsgXCIsXCIgKyB0aGlzLl9wYWRXaWR0aCArICh0aGlzLl9wYWRDaGFyID09PSAnICcgPyAnKScgOiBcIiwnXCIgKyB0aGlzLl9wYWRDaGFyICsgXCInKVwiKTtcbiAgfTtcbiAgcmV0dXJuIFBhZFByaW50ZXJQYXJzZXJEZWNvcmF0b3I7XG59KCk7XG5cbnZhciBTZXR0aW5nc1BhcnNlciA9IGZ1bmN0aW9uIChfRW51bSkge1xuICBfaW5oZXJpdHNMb29zZShTZXR0aW5nc1BhcnNlciwgX0VudW0pO1xuICBmdW5jdGlvbiBTZXR0aW5nc1BhcnNlcigpIHtcbiAgICByZXR1cm4gX0VudW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBTZXR0aW5nc1BhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5TRU5TSVRJVkU6XG4gICAgICAgIGNvbnRleHQuc2V0Q2FzZVNlbnNpdGl2ZSh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLklOU0VOU0lUSVZFOlxuICAgICAgICBjb250ZXh0LnNldENhc2VTZW5zaXRpdmUoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2V0dGluZ3NQYXJzZXIuU1RSSUNUOlxuICAgICAgICBjb250ZXh0LnNldFN0cmljdCh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLkxFTklFTlQ6XG4gICAgICAgIGNvbnRleHQuc2V0U3RyaWN0KGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLlNFTlNJVElWRTpcbiAgICAgICAgcmV0dXJuICdQYXJzZUNhc2VTZW5zaXRpdmUodHJ1ZSknO1xuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5JTlNFTlNJVElWRTpcbiAgICAgICAgcmV0dXJuICdQYXJzZUNhc2VTZW5zaXRpdmUoZmFsc2UpJztcbiAgICAgIGNhc2UgU2V0dGluZ3NQYXJzZXIuU1RSSUNUOlxuICAgICAgICByZXR1cm4gJ1BhcnNlU3RyaWN0KHRydWUpJztcbiAgICAgIGNhc2UgU2V0dGluZ3NQYXJzZXIuTEVOSUVOVDpcbiAgICAgICAgcmV0dXJuICdQYXJzZVN0cmljdChmYWxzZSknO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFNldHRpbmdzUGFyc2VyO1xufShFbnVtKTtcblNldHRpbmdzUGFyc2VyLlNFTlNJVElWRSA9IG5ldyBTZXR0aW5nc1BhcnNlcignU0VOU0lUSVZFJyk7XG5TZXR0aW5nc1BhcnNlci5JTlNFTlNJVElWRSA9IG5ldyBTZXR0aW5nc1BhcnNlcignSU5TRU5TSVRJVkUnKTtcblNldHRpbmdzUGFyc2VyLlNUUklDVCA9IG5ldyBTZXR0aW5nc1BhcnNlcignU1RSSUNUJyk7XG5TZXR0aW5nc1BhcnNlci5MRU5JRU5UID0gbmV3IFNldHRpbmdzUGFyc2VyKCdMRU5JRU5UJyk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxudmFyIFN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlcihsaXRlcmFsKSB7XG4gICAgdGhpcy5fbGl0ZXJhbCA9IGxpdGVyYWw7XG4gIH1cbiAgdmFyIF9wcm90byA9IFN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnByaW50ID0gZnVuY3Rpb24gcHJpbnQoY29udGV4dCwgYnVmKSB7XG4gICAgYnVmLmFwcGVuZCh0aGlzLl9saXRlcmFsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgYXNzZXJ0KCEocG9zaXRpb24gPiBsZW5ndGggfHwgcG9zaXRpb24gPCAwKSk7XG4gICAgaWYgKGNvbnRleHQuc3ViU2VxdWVuY2VFcXVhbHModGV4dCwgcG9zaXRpb24sIHRoaXMuX2xpdGVyYWwsIDAsIHRoaXMuX2xpdGVyYWwubGVuZ3RoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbiArIHRoaXMuX2xpdGVyYWwubGVuZ3RoO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgY29udmVydGVkID0gdGhpcy5fbGl0ZXJhbC5yZXBsYWNlKFwiJ1wiLCBcIicnXCIpO1xuICAgIHJldHVybiBcIidcIiArIGNvbnZlcnRlZCArIFwiJ1wiO1xuICB9O1xuICByZXR1cm4gU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXI7XG59KCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIsIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBab25lUnVsZXNQcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZVJ1bGVzUHJvdmlkZXIoKSB7fVxuICBab25lUnVsZXNQcm92aWRlci5nZXRSdWxlcyA9IGZ1bmN0aW9uIGdldFJ1bGVzKHpvbmVJZCkge1xuICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcInVuc3VwcG9ydGVkIFpvbmVJZDpcIiArIHpvbmVJZCk7XG4gIH07XG4gIFpvbmVSdWxlc1Byb3ZpZGVyLmdldEF2YWlsYWJsZVpvbmVJZHMgPSBmdW5jdGlvbiBnZXRBdmFpbGFibGVab25lSWRzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfTtcbiAgcmV0dXJuIFpvbmVSdWxlc1Byb3ZpZGVyO1xufSgpO1xuXG52YXIgWm9uZVJlZ2lvbiA9IGZ1bmN0aW9uIChfWm9uZUlkKSB7XG4gIF9pbmhlcml0c0xvb3NlKFpvbmVSZWdpb24sIF9ab25lSWQpO1xuICBab25lUmVnaW9uLm9mSWQgPSBmdW5jdGlvbiBvZklkKHpvbmVJZCkge1xuICAgIHZhciBydWxlcyA9IFpvbmVSdWxlc1Byb3ZpZGVyLmdldFJ1bGVzKHpvbmVJZCk7XG4gICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHpvbmVJZCwgcnVsZXMpO1xuICB9O1xuICBmdW5jdGlvbiBab25lUmVnaW9uKGlkLCBydWxlcykge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9ab25lSWQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9pZCA9IGlkO1xuICAgIF90aGlzLl9ydWxlcyA9IHJ1bGVzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gWm9uZVJlZ2lvbi5wcm90b3R5cGU7XG4gIF9wcm90by5pZCA9IGZ1bmN0aW9uIGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfTtcbiAgX3Byb3RvLnJ1bGVzID0gZnVuY3Rpb24gcnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVzO1xuICB9O1xuICByZXR1cm4gWm9uZVJlZ2lvbjtcbn0oWm9uZUlkKTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG52YXIgWm9uZUlkUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZUlkUHJpbnRlclBhcnNlcihxdWVyeSwgZGVzY3JpcHRpb24pIHtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9XG4gIHZhciBfcHJvdG8gPSBab25lSWRQcmludGVyUGFyc2VyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnByaW50ID0gZnVuY3Rpb24gcHJpbnQoY29udGV4dCwgYnVmKSB7XG4gICAgdmFyIHpvbmUgPSBjb250ZXh0LmdldFZhbHVlUXVlcnkodGhpcy5xdWVyeSk7XG4gICAgaWYgKHpvbmUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBidWYuYXBwZW5kKHpvbmUuaWQoKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIGlmIChwb3NpdGlvbiA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuICAgIHZhciBuZXh0Q2hhciA9IHRleHQuY2hhckF0KHBvc2l0aW9uKTtcbiAgICBpZiAobmV4dENoYXIgPT09ICcrJyB8fCBuZXh0Q2hhciA9PT0gJy0nKSB7XG4gICAgICB2YXIgbmV3Q29udGV4dCA9IGNvbnRleHQuY29weSgpO1xuICAgICAgdmFyIGVuZFBvcyA9IE9mZnNldElkUHJpbnRlclBhcnNlci5JTlNUQU5DRV9JRC5wYXJzZShuZXdDb250ZXh0LCB0ZXh0LCBwb3NpdGlvbik7XG4gICAgICBpZiAoZW5kUG9zIDwgMCkge1xuICAgICAgICByZXR1cm4gZW5kUG9zO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKTtcbiAgICAgIHZhciB6b25lID0gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhvZmZzZXQpO1xuICAgICAgY29udGV4dC5zZXRQYXJzZWRab25lKHpvbmUpO1xuICAgICAgcmV0dXJuIGVuZFBvcztcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA+PSBwb3NpdGlvbiArIDIpIHtcbiAgICAgIHZhciBuZXh0TmV4dENoYXIgPSB0ZXh0LmNoYXJBdChwb3NpdGlvbiArIDEpO1xuICAgICAgaWYgKGNvbnRleHQuY2hhckVxdWFscyhuZXh0Q2hhciwgJ1UnKSAmJiBjb250ZXh0LmNoYXJFcXVhbHMobmV4dE5leHRDaGFyLCAnVCcpKSB7XG4gICAgICAgIGlmIChsZW5ndGggPj0gcG9zaXRpb24gKyAzICYmIGNvbnRleHQuY2hhckVxdWFscyh0ZXh0LmNoYXJBdChwb3NpdGlvbiArIDIpLCAnQycpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlUHJlZml4ZWRPZmZzZXQoY29udGV4dCwgdGV4dCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlUHJlZml4ZWRPZmZzZXQoY29udGV4dCwgdGV4dCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMik7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQuY2hhckVxdWFscyhuZXh0Q2hhciwgJ0cnKSAmJiBsZW5ndGggPj0gcG9zaXRpb24gKyAzICYmIGNvbnRleHQuY2hhckVxdWFscyhuZXh0TmV4dENoYXIsICdNJykgJiYgY29udGV4dC5jaGFyRXF1YWxzKHRleHQuY2hhckF0KHBvc2l0aW9uICsgMiksICdUJykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlUHJlZml4ZWRPZmZzZXQoY29udGV4dCwgdGV4dCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0LnN1YnN0cihwb3NpdGlvbiwgNikgPT09ICdTWVNURU0nKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZUlkLnN5c3RlbURlZmF1bHQoKSk7XG4gICAgICByZXR1cm4gcG9zaXRpb24gKyA2O1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5jaGFyRXF1YWxzKG5leHRDaGFyLCAnWicpKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZU9mZnNldC5VVEMpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uICsgMTtcbiAgICB9XG4gICAgdmFyIGF2YWlsYWJsZVpvbmVJZHMgPSBab25lUnVsZXNQcm92aWRlci5nZXRBdmFpbGFibGVab25lSWRzKCk7XG4gICAgaWYgKHpvbmVJZFRyZWUuc2l6ZSAhPT0gYXZhaWxhYmxlWm9uZUlkcy5sZW5ndGgpIHtcbiAgICAgIHpvbmVJZFRyZWUgPSBab25lSWRUcmVlLmNyZWF0ZVRyZWVNYXAoYXZhaWxhYmxlWm9uZUlkcyk7XG4gICAgfVxuICAgIHZhciBtYXhQYXJzZUxlbmd0aCA9IGxlbmd0aCAtIHBvc2l0aW9uO1xuICAgIHZhciB0cmVlTWFwID0gem9uZUlkVHJlZS50cmVlTWFwO1xuICAgIHZhciBwYXJzZWRab25lSWQgPSBudWxsO1xuICAgIHZhciBwYXJzZUxlbmd0aCA9IDA7XG4gICAgd2hpbGUgKHRyZWVNYXAgIT0gbnVsbCkge1xuICAgICAgdmFyIHBhcnNlZFN1YlpvbmVJZCA9IHRleHQuc3Vic3RyKHBvc2l0aW9uLCBNYXRoLm1pbih0cmVlTWFwLmxlbmd0aCwgbWF4UGFyc2VMZW5ndGgpKTtcbiAgICAgIHRyZWVNYXAgPSB0cmVlTWFwLmdldChwYXJzZWRTdWJab25lSWQpO1xuICAgICAgaWYgKHRyZWVNYXAgIT0gbnVsbCAmJiB0cmVlTWFwLmlzTGVhZikge1xuICAgICAgICBwYXJzZWRab25lSWQgPSBwYXJzZWRTdWJab25lSWQ7XG4gICAgICAgIHBhcnNlTGVuZ3RoID0gdHJlZU1hcC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWRab25lSWQgIT0gbnVsbCkge1xuICAgICAgY29udGV4dC5zZXRQYXJzZWRab25lKFpvbmVSZWdpb24ub2ZJZChwYXJzZWRab25lSWQpKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbiArIHBhcnNlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gfnBvc2l0aW9uO1xuICB9O1xuICBfcHJvdG8uX3BhcnNlUHJlZml4ZWRPZmZzZXQgPSBmdW5jdGlvbiBfcGFyc2VQcmVmaXhlZE9mZnNldChjb250ZXh0LCB0ZXh0LCBwcmVmaXhQb3MsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHByZWZpeCA9IHRleHQuc3Vic3RyaW5nKHByZWZpeFBvcywgcG9zaXRpb24pLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIG5ld0NvbnRleHQgPSBjb250ZXh0LmNvcHkoKTtcbiAgICBpZiAocG9zaXRpb24gPCB0ZXh0Lmxlbmd0aCAmJiBjb250ZXh0LmNoYXJFcXVhbHModGV4dC5jaGFyQXQocG9zaXRpb24pLCAnWicpKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZUlkLm9mT2Zmc2V0KHByZWZpeCwgWm9uZU9mZnNldC5VVEMpKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG4gICAgdmFyIGVuZFBvcyA9IE9mZnNldElkUHJpbnRlclBhcnNlci5JTlNUQU5DRV9JRC5wYXJzZShuZXdDb250ZXh0LCB0ZXh0LCBwb3NpdGlvbik7XG4gICAgaWYgKGVuZFBvcyA8IDApIHtcbiAgICAgIGNvbnRleHQuc2V0UGFyc2VkWm9uZShab25lSWQub2ZPZmZzZXQocHJlZml4LCBab25lT2Zmc2V0LlVUQykpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0U2VjcyA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKTtcbiAgICB2YXIgb2Zmc2V0ID0gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhvZmZzZXRTZWNzKTtcbiAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZUlkLm9mT2Zmc2V0KHByZWZpeCwgb2Zmc2V0KSk7XG4gICAgcmV0dXJuIGVuZFBvcztcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb247XG4gIH07XG4gIHJldHVybiBab25lSWRQcmludGVyUGFyc2VyO1xufSgpO1xudmFyIFpvbmVJZFRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gIFpvbmVJZFRyZWUuY3JlYXRlVHJlZU1hcCA9IGZ1bmN0aW9uIGNyZWF0ZVRyZWVNYXAoYXZhaWxhYmxlWm9uZUlkcykge1xuICAgIHZhciBzb3J0ZWRab25lSWRzID0gYXZhaWxhYmxlWm9uZUlkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB9KTtcbiAgICB2YXIgdHJlZU1hcCA9IG5ldyBab25lSWRUcmVlTWFwKHNvcnRlZFpvbmVJZHNbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3J0ZWRab25lSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmVlTWFwLmFkZChzb3J0ZWRab25lSWRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab25lSWRUcmVlKHNvcnRlZFpvbmVJZHMubGVuZ3RoLCB0cmVlTWFwKTtcbiAgfTtcbiAgZnVuY3Rpb24gWm9uZUlkVHJlZShzaXplLCB0cmVlTWFwKSB7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLnRyZWVNYXAgPSB0cmVlTWFwO1xuICB9XG4gIHJldHVybiBab25lSWRUcmVlO1xufSgpO1xudmFyIFpvbmVJZFRyZWVNYXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFpvbmVJZFRyZWVNYXAobGVuZ3RoLCBpc0xlYWYpIHtcbiAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGlmIChpc0xlYWYgPT09IHZvaWQgMCkge1xuICAgICAgaXNMZWFmID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaXNMZWFmID0gaXNMZWFmO1xuICAgIHRoaXMuX3RyZWVNYXAgPSB7fTtcbiAgfVxuICB2YXIgX3Byb3RvMiA9IFpvbmVJZFRyZWVNYXAucHJvdG90eXBlO1xuICBfcHJvdG8yLmFkZCA9IGZ1bmN0aW9uIGFkZCh6b25lSWQpIHtcbiAgICB2YXIgaWRMZW5ndGggPSB6b25lSWQubGVuZ3RoO1xuICAgIGlmIChpZExlbmd0aCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyZWVNYXBbem9uZUlkXSA9IG5ldyBab25lSWRUcmVlTWFwKGlkTGVuZ3RoLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlkTGVuZ3RoID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHZhciBzdWJab25lSWQgPSB6b25lSWQuc3Vic3RyKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHZhciBzdWJUcmVlTWFwID0gdGhpcy5fdHJlZU1hcFtzdWJab25lSWRdO1xuICAgICAgaWYgKHN1YlRyZWVNYXAgPT0gbnVsbCkge1xuICAgICAgICBzdWJUcmVlTWFwID0gbmV3IFpvbmVJZFRyZWVNYXAoaWRMZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fdHJlZU1hcFtzdWJab25lSWRdID0gc3ViVHJlZU1hcDtcbiAgICAgIH1cbiAgICAgIHN1YlRyZWVNYXAuYWRkKHpvbmVJZCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8yLmdldCA9IGZ1bmN0aW9uIGdldCh6b25lSWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJlZU1hcFt6b25lSWRdO1xuICB9O1xuICByZXR1cm4gWm9uZUlkVHJlZU1hcDtcbn0oKTtcbnZhciB6b25lSWRUcmVlID0gbmV3IFpvbmVJZFRyZWUoW10pO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBNQVhfV0lEVEggPSAxNTtcbnZhciBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpIHtcbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzO1xuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fcHJpbnRlclBhcnNlcnMgPSBbXTtcbiAgICB0aGlzLl9vcHRpb25hbCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhZE5leHRXaWR0aCA9IDA7XG4gICAgdGhpcy5fcGFkTmV4dENoYXIgPSBudWxsO1xuICAgIHRoaXMuX3ZhbHVlUGFyc2VySW5kZXggPSAtMTtcbiAgfVxuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuX29mID0gZnVuY3Rpb24gX29mKHBhcmVudCwgb3B0aW9uYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbChwYXJlbnQsICdwYXJlbnQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvcHRpb25hbCwgJ29wdGlvbmFsJyk7XG4gICAgdmFyIGR0Rm9ybWF0dGVyQnVpbGRlciA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKTtcbiAgICBkdEZvcm1hdHRlckJ1aWxkZXIuX3BhcmVudCA9IHBhcmVudDtcbiAgICBkdEZvcm1hdHRlckJ1aWxkZXIuX29wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgcmV0dXJuIGR0Rm9ybWF0dGVyQnVpbGRlcjtcbiAgfTtcbiAgdmFyIF9wcm90byA9IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5wcm90b3R5cGU7XG4gIF9wcm90by5wYXJzZUNhc2VTZW5zaXRpdmUgPSBmdW5jdGlvbiBwYXJzZUNhc2VTZW5zaXRpdmUoKSB7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWxQcmludGVyUGFyc2VyKFNldHRpbmdzUGFyc2VyLlNFTlNJVElWRSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5wYXJzZUNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIHBhcnNlQ2FzZUluc2Vuc2l0aXZlKCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihTZXR0aW5nc1BhcnNlci5JTlNFTlNJVElWRSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5wYXJzZVN0cmljdCA9IGZ1bmN0aW9uIHBhcnNlU3RyaWN0KCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihTZXR0aW5nc1BhcnNlci5TVFJJQ1QpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8ucGFyc2VMZW5pZW50ID0gZnVuY3Rpb24gcGFyc2VMZW5pZW50KCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihTZXR0aW5nc1BhcnNlci5MRU5JRU5UKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLnBhcnNlRGVmYXVsdGluZyA9IGZ1bmN0aW9uIHBhcnNlRGVmYXVsdGluZyhmaWVsZCwgdmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCk7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWwobmV3IERlZmF1bHRpbmdQYXJzZXIoZmllbGQsIHZhbHVlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5hcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uIGFwcGVuZFZhbHVlKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWUxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRWYWx1ZTQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5fYXBwZW5kVmFsdWUxID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlMShmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkKTtcbiAgICB0aGlzLl9hcHBlbmRWYWx1ZVByaW50ZXJQYXJzZXIobmV3IE51bWJlclByaW50ZXJQYXJzZXIoZmllbGQsIDEsIE1BWF9XSURUSCwgU2lnblN0eWxlLk5PUk1BTCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uX2FwcGVuZFZhbHVlMiA9IGZ1bmN0aW9uIF9hcHBlbmRWYWx1ZTIoZmllbGQsIHdpZHRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQpO1xuICAgIGlmICh3aWR0aCA8IDEgfHwgd2lkdGggPiBNQVhfV0lEVEgpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgd2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gXCIgKyBNQVhfV0lEVEggKyBcIiBpbmNsdXNpdmUgYnV0IHdhcyBcIiArIHdpZHRoKTtcbiAgICB9XG4gICAgdmFyIHBwID0gbmV3IE51bWJlclByaW50ZXJQYXJzZXIoZmllbGQsIHdpZHRoLCB3aWR0aCwgU2lnblN0eWxlLk5PVF9ORUdBVElWRSk7XG4gICAgdGhpcy5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyKHBwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLl9hcHBlbmRWYWx1ZTQgPSBmdW5jdGlvbiBfYXBwZW5kVmFsdWU0KGZpZWxkLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHNpZ25TdHlsZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkKTtcbiAgICByZXF1aXJlTm9uTnVsbChzaWduU3R5bGUpO1xuICAgIGlmIChtaW5XaWR0aCA9PT0gbWF4V2lkdGggJiYgc2lnblN0eWxlID09PSBTaWduU3R5bGUuTk9UX05FR0FUSVZFKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWUyKGZpZWxkLCBtYXhXaWR0aCk7XG4gICAgfVxuICAgIGlmIChtaW5XaWR0aCA8IDEgfHwgbWluV2lkdGggPiBNQVhfV0lEVEgpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgbWluaW11bSB3aWR0aCBtdXN0IGJlIGZyb20gMSB0byBcIiArIE1BWF9XSURUSCArIFwiIGluY2x1c2l2ZSBidXQgd2FzIFwiICsgbWluV2lkdGgpO1xuICAgIH1cbiAgICBpZiAobWF4V2lkdGggPCAxIHx8IG1heFdpZHRoID4gTUFYX1dJRFRIKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVGhlIG1pbmltdW0gd2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gXCIgKyBNQVhfV0lEVEggKyBcIiBpbmNsdXNpdmUgYnV0IHdhcyBcIiArIG1heFdpZHRoKTtcbiAgICB9XG4gICAgaWYgKG1heFdpZHRoIDwgbWluV2lkdGgpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgbWF4aW11bSB3aWR0aCBtdXN0IGV4Y2VlZCBvciBlcXVhbCB0aGUgbWluaW11bSB3aWR0aCBidXQgXCIgKyBtYXhXaWR0aCArIFwiIDwgXCIgKyBtaW5XaWR0aCk7XG4gICAgfVxuICAgIHZhciBwcCA9IG5ldyBOdW1iZXJQcmludGVyUGFyc2VyKGZpZWxkLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHNpZ25TdHlsZSk7XG4gICAgdGhpcy5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyKHBwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLmFwcGVuZFZhbHVlUmVkdWNlZCA9IGZ1bmN0aW9uIGFwcGVuZFZhbHVlUmVkdWNlZCgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiBhcmd1bWVudHNbM10gaW5zdGFuY2VvZiBDaHJvbm9Mb2NhbERhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRWYWx1ZVJlZHVjZWRGaWVsZFdpZHRoTWF4V2lkdGhCYXNlRGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWVSZWR1Y2VkRmllbGRXaWR0aE1heFdpZHRoQmFzZVZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VWYWx1ZSA9IGZ1bmN0aW9uIF9hcHBlbmRWYWx1ZVJlZHVjZWRGaWVsZFdpZHRoTWF4V2lkdGhCYXNlVmFsdWUoZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgYmFzZVZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHZhciBwcCA9IG5ldyBSZWR1Y2VkUHJpbnRlclBhcnNlcihmaWVsZCwgd2lkdGgsIG1heFdpZHRoLCBiYXNlVmFsdWUsIG51bGwpO1xuICAgIHRoaXMuX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihwcCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5fYXBwZW5kVmFsdWVSZWR1Y2VkRmllbGRXaWR0aE1heFdpZHRoQmFzZURhdGUgPSBmdW5jdGlvbiBfYXBwZW5kVmFsdWVSZWR1Y2VkRmllbGRXaWR0aE1heFdpZHRoQmFzZURhdGUoZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgYmFzZURhdGUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgcmVxdWlyZU5vbk51bGwoYmFzZURhdGUsICdiYXNlRGF0ZScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShiYXNlRGF0ZSwgQ2hyb25vTG9jYWxEYXRlLCAnYmFzZURhdGUnKTtcbiAgICB2YXIgcHAgPSBuZXcgUmVkdWNlZFByaW50ZXJQYXJzZXIoZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgMCwgYmFzZURhdGUpO1xuICAgIHRoaXMuX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihwcCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihwcCkge1xuICAgIGFzc2VydChwcCAhPSBudWxsKTtcbiAgICBpZiAodGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4ID49IDAgJiYgdGhpcy5fYWN0aXZlLl9wcmludGVyUGFyc2Vyc1t0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXhdIGluc3RhbmNlb2YgTnVtYmVyUHJpbnRlclBhcnNlcikge1xuICAgICAgdmFyIGFjdGl2ZVZhbHVlUGFyc2VyID0gdGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4O1xuICAgICAgdmFyIGJhc2VQUCA9IHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnNbYWN0aXZlVmFsdWVQYXJzZXJdO1xuICAgICAgaWYgKHBwLm1pbldpZHRoKCkgPT09IHBwLm1heFdpZHRoKCkgJiYgcHAuc2lnblN0eWxlKCkgPT09IFNpZ25TdHlsZS5OT1RfTkVHQVRJVkUpIHtcbiAgICAgICAgYmFzZVBQID0gYmFzZVBQLndpdGhTdWJzZXF1ZW50V2lkdGgocHAubWF4V2lkdGgoKSk7XG4gICAgICAgIHRoaXMuX2FwcGVuZEludGVybmFsKHBwLndpdGhGaXhlZFdpZHRoKCkpO1xuICAgICAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSBhY3RpdmVWYWx1ZVBhcnNlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VQUCA9IGJhc2VQUC53aXRoRml4ZWRXaWR0aCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSB0aGlzLl9hcHBlbmRJbnRlcm5hbChwcCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzW2FjdGl2ZVZhbHVlUGFyc2VyXSA9IGJhc2VQUDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4ID0gdGhpcy5fYXBwZW5kSW50ZXJuYWwocHApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLmFwcGVuZEZyYWN0aW9uID0gZnVuY3Rpb24gYXBwZW5kRnJhY3Rpb24oZmllbGQsIG1pbldpZHRoLCBtYXhXaWR0aCwgZGVjaW1hbFBvaW50KSB7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWwobmV3IEZyYWN0aW9uUHJpbnRlclBhcnNlcihmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBkZWNpbWFsUG9pbnQpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLmFwcGVuZEluc3RhbnQgPSBmdW5jdGlvbiBhcHBlbmRJbnN0YW50KGZyYWN0aW9uYWxEaWdpdHMpIHtcbiAgICBpZiAoZnJhY3Rpb25hbERpZ2l0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBmcmFjdGlvbmFsRGlnaXRzID0gLTI7XG4gICAgfVxuICAgIGlmIChmcmFjdGlvbmFsRGlnaXRzIDwgLTIgfHwgZnJhY3Rpb25hbERpZ2l0cyA+IDkpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJJbnZhbGlkIGZyYWN0aW9uYWwgZGlnaXRzOiBcIiArIGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChuZXcgSW5zdGFudFByaW50ZXJQYXJzZXIoZnJhY3Rpb25hbERpZ2l0cykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kT2Zmc2V0SWQgPSBmdW5jdGlvbiBhcHBlbmRPZmZzZXRJZCgpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChPZmZzZXRJZFByaW50ZXJQYXJzZXIuSU5TVEFOQ0VfSUQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kT2Zmc2V0ID0gZnVuY3Rpb24gYXBwZW5kT2Zmc2V0KHBhdHRlcm4sIG5vT2Zmc2V0VGV4dCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihuZXcgT2Zmc2V0SWRQcmludGVyUGFyc2VyKG5vT2Zmc2V0VGV4dCwgcGF0dGVybikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kWm9uZUlkID0gZnVuY3Rpb24gYXBwZW5kWm9uZUlkKCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsKG5ldyBab25lSWRQcmludGVyUGFyc2VyKFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSwgJ1pvbmVJZCgpJykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kUGF0dGVybiA9IGZ1bmN0aW9uIGFwcGVuZFBhdHRlcm4ocGF0dGVybikge1xuICAgIHJlcXVpcmVOb25OdWxsKHBhdHRlcm4sICdwYXR0ZXJuJyk7XG4gICAgdGhpcy5fcGFyc2VQYXR0ZXJuKHBhdHRlcm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kWm9uZVRleHQgPSBmdW5jdGlvbiBhcHBlbmRab25lVGV4dCgpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkLCB1c2UgQGpzLWpvZGEvbG9jYWxlIHBsdWdpbiEnKTtcbiAgfTtcbiAgX3Byb3RvLmFwcGVuZFRleHQgPSBmdW5jdGlvbiBhcHBlbmRUZXh0KCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gdXNpbmcgKGxvY2FsaXplZCkgdGV4dCBub3QgaW1wbGVtZW50ZWQsIHVzZSBAanMtam9kYS9sb2NhbGUgcGx1Z2luIScpO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kTG9jYWxpemVkT2Zmc2V0ID0gZnVuY3Rpb24gYXBwZW5kTG9jYWxpemVkT2Zmc2V0KCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gdXNpbmcgKGxvY2FsaXplZCkgdGV4dCBub3QgaW1wbGVtZW50ZWQsIHVzZSBAanMtam9kYS9sb2NhbGUgcGx1Z2luIScpO1xuICB9O1xuICBfcHJvdG8uYXBwZW5kV2Vla0ZpZWxkID0gZnVuY3Rpb24gYXBwZW5kV2Vla0ZpZWxkKCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gdXNpbmcgKGxvY2FsaXplZCkgdGV4dCBub3QgaW1wbGVtZW50ZWQsIHVzZSBAanMtam9kYS9sb2NhbGUgcGx1Z2luIScpO1xuICB9O1xuICBfcHJvdG8uX3BhcnNlUGF0dGVybiA9IGZ1bmN0aW9uIF9wYXJzZVBhdHRlcm4ocGF0dGVybikge1xuICAgIHZhciBGSUVMRF9NQVAgPSB7XG4gICAgICAnRyc6IENocm9ub0ZpZWxkLkVSQSxcbiAgICAgICd5JzogQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEsXG4gICAgICAndSc6IENocm9ub0ZpZWxkLllFQVIsXG4gICAgICAnUSc6IElzb0ZpZWxkcy5RVUFSVEVSX09GX1lFQVIsXG4gICAgICAncSc6IElzb0ZpZWxkcy5RVUFSVEVSX09GX1lFQVIsXG4gICAgICAnTSc6IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsXG4gICAgICAnTCc6IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsXG4gICAgICAnRCc6IENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSLFxuICAgICAgJ2QnOiBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsXG4gICAgICAnRic6IENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fTU9OVEgsXG4gICAgICAnRSc6IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLLFxuICAgICAgJ2MnOiBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyxcbiAgICAgICdlJzogQ2hyb25vRmllbGQuREFZX09GX1dFRUssXG4gICAgICAnYSc6IENocm9ub0ZpZWxkLkFNUE1fT0ZfREFZLFxuICAgICAgJ0gnOiBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSxcbiAgICAgICdrJzogQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9EQVksXG4gICAgICAnSyc6IENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSxcbiAgICAgICdoJzogQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNLFxuICAgICAgJ20nOiBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUixcbiAgICAgICdzJzogQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSxcbiAgICAgICdTJzogQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsXG4gICAgICAnQSc6IENocm9ub0ZpZWxkLk1JTExJX09GX0RBWSxcbiAgICAgICduJzogQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsXG4gICAgICAnTic6IENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZXG4gICAgfTtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBwYXR0ZXJuLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgIHZhciBjdXIgPSBwYXR0ZXJuLmNoYXJBdChwb3MpO1xuICAgICAgaWYgKGN1ciA+PSAnQScgJiYgY3VyIDw9ICdaJyB8fCBjdXIgPj0gJ2EnICYmIGN1ciA8PSAneicpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zKys7XG4gICAgICAgIGZvciAoOyBwb3MgPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuLmNoYXJBdChwb3MpID09PSBjdXI7IHBvcysrKTtcbiAgICAgICAgdmFyIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG4gICAgICAgIGlmIChjdXIgPT09ICdwJykge1xuICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgIGlmIChwb3MgPCBwYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VyID0gcGF0dGVybi5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChjdXIgPj0gJ0EnICYmIGN1ciA8PSAnWicgfHwgY3VyID49ICdhJyAmJiBjdXIgPD0gJ3onKSB7XG4gICAgICAgICAgICAgIHBhZCA9IGNvdW50O1xuICAgICAgICAgICAgICBzdGFydCA9IHBvcysrO1xuICAgICAgICAgICAgICBmb3IgKDsgcG9zIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQocG9zKSA9PT0gY3VyOyBwb3MrKyk7XG4gICAgICAgICAgICAgIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYWQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJQYWQgbGV0dGVyICdwJyBtdXN0IGJlIGZvbGxvd2VkIGJ5IHZhbGlkIHBhZCBwYXR0ZXJuOiBcIiArIHBhdHRlcm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBhZE5leHQocGFkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmllbGQgPSBGSUVMRF9NQVBbY3VyXTtcbiAgICAgICAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9wYXJzZUZpZWxkKGN1ciwgY291bnQsIGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICd6Jykge1xuICAgICAgICAgIGlmIChjb3VudCA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6IFwiICsgY3VyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFpvbmVUZXh0KFRleHRTdHlsZS5GVUxMKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRab25lVGV4dChUZXh0U3R5bGUuU0hPUlQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdWJykge1xuICAgICAgICAgIGlmIChjb3VudCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlBhdHRlcm4gbGV0dGVyIGNvdW50IG11c3QgYmUgMjogXCIgKyBjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGVuZFpvbmVJZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1onKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgNCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRPZmZzZXQoJytISE1NJywgJyswMDAwJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRMb2NhbGl6ZWRPZmZzZXQoVGV4dFN0eWxlLkZVTEwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kT2Zmc2V0KCcrSEg6TU06c3MnLCAnWicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ08nKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZExvY2FsaXplZE9mZnNldChUZXh0U3R5bGUuU0hPUlQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTG9jYWxpemVkT2Zmc2V0KFRleHRTdHlsZS5GVUxMKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlBhdHRlcm4gbGV0dGVyIGNvdW50IG11c3QgYmUgMSBvciA0OiBcIiArIGN1cik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1gnKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGVuZE9mZnNldChPZmZzZXRJZFByaW50ZXJQYXJzZXIuUEFUVEVSTlNbY291bnQgKyAoY291bnQgPT09IDEgPyAwIDogMSldLCAnWicpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ3gnKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgemVybyA9IGNvdW50ID09PSAxID8gJyswMCcgOiBjb3VudCAlIDIgPT09IDAgPyAnKzAwMDAnIDogJyswMDowMCc7XG4gICAgICAgICAgdGhpcy5hcHBlbmRPZmZzZXQoT2Zmc2V0SWRQcmludGVyUGFyc2VyLlBBVFRFUk5TW2NvdW50ICsgKGNvdW50ID09PSAxID8gMCA6IDEpXSwgemVybyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnVycpIHtcbiAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCdXJywgY291bnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ3cnKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGVuZFdlZWtGaWVsZCgndycsIGNvdW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdZJykge1xuICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCdZJywgY291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJVbmtub3duIHBhdHRlcm4gbGV0dGVyOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgcG9zLS07XG4gICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1xcJycpIHtcbiAgICAgICAgdmFyIF9zdGFydCA9IHBvcysrO1xuICAgICAgICBmb3IgKDsgcG9zIDwgcGF0dGVybi5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4uY2hhckF0KHBvcykgPT09ICdcXCcnKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgMSA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm4uY2hhckF0KHBvcyArIDEpID09PSAnXFwnJykge1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlBhdHRlcm4gZW5kcyB3aXRoIGFuIGluY29tcGxldGUgc3RyaW5nIGxpdGVyYWw6IFwiICsgcGF0dGVybik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IHBhdHRlcm4uc3Vic3RyaW5nKF9zdGFydCArIDEsIHBvcyk7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRMaXRlcmFsKCdcXCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZExpdGVyYWwoc3RyLnJlcGxhY2UoJ1xcJ1xcJycsICdcXCcnKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnWycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25hbFN0YXJ0KCk7XG4gICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ10nKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gaW52YWxpZCBhcyBpdCBjb250YWlucyBdIHdpdGhvdXQgcHJldmlvdXMgWycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uYWxFbmQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAneycgfHwgY3VyID09PSAnfScgfHwgY3VyID09PSAnIycpIHtcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlBhdHRlcm4gaW5jbHVkZXMgcmVzZXJ2ZWQgY2hhcmFjdGVyOiAnXCIgKyBjdXIgKyBcIidcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZExpdGVyYWwoY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9wcm90by5fcGFyc2VGaWVsZCA9IGZ1bmN0aW9uIF9wYXJzZUZpZWxkKGN1ciwgY291bnQsIGZpZWxkKSB7XG4gICAgc3dpdGNoIChjdXIpIHtcbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgY2FzZSAneSc6XG4gICAgICAgIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWVSZWR1Y2VkKGZpZWxkLCAyLCAyLCBSZWR1Y2VkUHJpbnRlclBhcnNlci5CQVNFX0RBVEUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDwgNCkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQsIGNvdW50LCBNQVhfV0lEVEgsIFNpZ25TdHlsZS5OT1JNQUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQsIGNvdW50LCBNQVhfV0lEVEgsIFNpZ25TdHlsZS5FWENFRURTX1BBRCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNJzpcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLkZVTEwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuTkFSUk9XKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMJzpcbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUX1NUQU5EQUxPTkUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuRlVMTF9TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlJzpcbiAgICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFdlZWtGaWVsZCgnZScsIGNvdW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLkZVTEwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuTkFSUk9XKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCdjJywgY291bnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkludmFsaWQgbnVtYmVyIG9mIHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUX1NUQU5EQUxPTkUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuRlVMTF9TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuU0hPUlQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6IFwiICsgY3VyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgY2FzZSAnRyc6XG4gICAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLkZVTEwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuTkFSUk9XKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdTJzpcbiAgICAgICAgdGhpcy5hcHBlbmRGcmFjdGlvbihDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCwgY291bnQsIGNvdW50LCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRic6XG4gICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6IFwiICsgY3VyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2QnOlxuICAgICAgY2FzZSAnaCc6XG4gICAgICBjYXNlICdIJzpcbiAgICAgIGNhc2UgJ2snOlxuICAgICAgY2FzZSAnSyc6XG4gICAgICBjYXNlICdtJzpcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQsIGNvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMykge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQsIGNvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCBjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ucGFkTmV4dCA9IGZ1bmN0aW9uIHBhZE5leHQoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWROZXh0MS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFkTmV4dDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5fcGFkTmV4dDEgPSBmdW5jdGlvbiBfcGFkTmV4dDEocGFkV2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkTmV4dDIocGFkV2lkdGgsICcgJyk7XG4gIH07XG4gIF9wcm90by5fcGFkTmV4dDIgPSBmdW5jdGlvbiBfcGFkTmV4dDIocGFkV2lkdGgsIHBhZENoYXIpIHtcbiAgICBpZiAocGFkV2lkdGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVGhlIHBhZCB3aWR0aCBtdXN0IGJlIGF0IGxlYXN0IG9uZSBidXQgd2FzIFwiICsgcGFkV2lkdGgpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUuX3BhZE5leHRXaWR0aCA9IHBhZFdpZHRoO1xuICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dENoYXIgPSBwYWRDaGFyO1xuICAgIHRoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleCA9IC0xO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8ub3B0aW9uYWxTdGFydCA9IGZ1bmN0aW9uIG9wdGlvbmFsU3RhcnQoKSB7XG4gICAgdGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4ID0gLTE7XG4gICAgdGhpcy5fYWN0aXZlID0gRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLl9vZih0aGlzLl9hY3RpdmUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8ub3B0aW9uYWxFbmQgPSBmdW5jdGlvbiBvcHRpb25hbEVuZCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlLl9wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignQ2Fubm90IGNhbGwgb3B0aW9uYWxFbmQoKSBhcyB0aGVyZSB3YXMgbm8gcHJldmlvdXMgY2FsbCB0byBvcHRpb25hbFN0YXJ0KCknKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGNwcCA9IG5ldyBDb21wb3NpdGVQcmludGVyUGFyc2VyKHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMsIHRoaXMuX2FjdGl2ZS5fb3B0aW9uYWwpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fYWN0aXZlLl9wYXJlbnQ7XG4gICAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChjcHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9hY3RpdmUuX3BhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5fYXBwZW5kSW50ZXJuYWwgPSBmdW5jdGlvbiBfYXBwZW5kSW50ZXJuYWwocHApIHtcbiAgICBhc3NlcnQocHAgIT0gbnVsbCk7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZS5fcGFkTmV4dFdpZHRoID4gMCkge1xuICAgICAgaWYgKHBwICE9IG51bGwpIHtcbiAgICAgICAgcHAgPSBuZXcgUGFkUHJpbnRlclBhcnNlckRlY29yYXRvcihwcCwgdGhpcy5fYWN0aXZlLl9wYWROZXh0V2lkdGgsIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dENoYXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlLl9wYWROZXh0V2lkdGggPSAwO1xuICAgICAgdGhpcy5fYWN0aXZlLl9wYWROZXh0Q2hhciA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMucHVzaChwcCk7XG4gICAgdGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4ID0gLTE7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMubGVuZ3RoIC0gMTtcbiAgfTtcbiAgX3Byb3RvLmFwcGVuZExpdGVyYWwgPSBmdW5jdGlvbiBhcHBlbmRMaXRlcmFsKGxpdGVyYWwpIHtcbiAgICBhc3NlcnQobGl0ZXJhbCAhPSBudWxsKTtcbiAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kSW50ZXJuYWxQcmludGVyUGFyc2VyKG5ldyBDaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXIobGl0ZXJhbC5jaGFyQXQoMCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihuZXcgU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXIobGl0ZXJhbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLl9hcHBlbmRJbnRlcm5hbFByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiBfYXBwZW5kSW50ZXJuYWxQcmludGVyUGFyc2VyKHBwKSB7XG4gICAgYXNzZXJ0KHBwICE9IG51bGwpO1xuICAgIGlmICh0aGlzLl9hY3RpdmUuX3BhZE5leHRXaWR0aCA+IDApIHtcbiAgICAgIGlmIChwcCAhPSBudWxsKSB7XG4gICAgICAgIHBwID0gbmV3IFBhZFByaW50ZXJQYXJzZXJEZWNvcmF0b3IocHAsIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dFdpZHRoLCB0aGlzLl9hY3RpdmUuX3BhZE5leHRDaGFyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dFdpZHRoID0gMDtcbiAgICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dENoYXIgPSAwO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzLnB1c2gocHApO1xuICAgIHRoaXMuX2FjdGl2ZS5fdmFsdWVQYXJzZXJJbmRleCA9IC0xO1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aCAtIDE7XG4gIH07XG4gIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWwoZm9ybWF0dGVyLl90b1ByaW50ZXJQYXJzZXIoZmFsc2UpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLnRvRm9ybWF0dGVyID0gZnVuY3Rpb24gdG9Gb3JtYXR0ZXIocmVzb2x2ZXJTdHlsZSkge1xuICAgIGlmIChyZXNvbHZlclN0eWxlID09PSB2b2lkIDApIHtcbiAgICAgIHJlc29sdmVyU3R5bGUgPSBSZXNvbHZlclN0eWxlLlNNQVJUO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy5fYWN0aXZlLl9wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25hbEVuZCgpO1xuICAgIH1cbiAgICB2YXIgcHAgPSBuZXcgQ29tcG9zaXRlUHJpbnRlclBhcnNlcih0aGlzLl9wcmludGVyUGFyc2VycywgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXIocHAsIG51bGwsIERlY2ltYWxTdHlsZS5TVEFOREFSRCwgcmVzb2x2ZXJTdHlsZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH07XG4gIHJldHVybiBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXI7XG59KCk7XG52YXIgU0VDT05EU19QRVJfMTAwMDBfWUVBUlMgPSAxNDYwOTcgKiAyNSAqIDg2NDAwO1xudmFyIFNFQ09ORFNfMDAwMF9UT18xOTcwID0gKDE0NjA5NyAqIDUgLSAoMzAgKiAzNjUgKyA3KSkgKiA4NjQwMDtcbnZhciBJbnN0YW50UHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5zdGFudFByaW50ZXJQYXJzZXIoZnJhY3Rpb25hbERpZ2l0cykge1xuICAgIHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA9IGZyYWN0aW9uYWxEaWdpdHM7XG4gIH1cbiAgdmFyIF9wcm90bzIgPSBJbnN0YW50UHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90bzIucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgaW5TZWNzID0gY29udGV4dC5nZXRWYWx1ZShDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMpO1xuICAgIHZhciBpbk5hbm9zID0gMDtcbiAgICBpZiAoY29udGV4dC50ZW1wb3JhbCgpLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKSkge1xuICAgICAgaW5OYW5vcyA9IGNvbnRleHQudGVtcG9yYWwoKS5nZXRMb25nKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICB9XG4gICAgaWYgKGluU2VjcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpblNlYyA9IGluU2VjcztcbiAgICB2YXIgaW5OYW5vID0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZEludFZhbHVlKGluTmFub3MpO1xuICAgIGlmIChpblNlYyA+PSAtU0VDT05EU18wMDAwX1RPXzE5NzApIHtcbiAgICAgIHZhciB6ZXJvU2VjcyA9IGluU2VjIC0gU0VDT05EU19QRVJfMTAwMDBfWUVBUlMgKyBTRUNPTkRTXzAwMDBfVE9fMTk3MDtcbiAgICAgIHZhciBoaSA9IE1hdGhVdGlsLmZsb29yRGl2KHplcm9TZWNzLCBTRUNPTkRTX1BFUl8xMDAwMF9ZRUFSUykgKyAxO1xuICAgICAgdmFyIGxvID0gTWF0aFV0aWwuZmxvb3JNb2QoemVyb1NlY3MsIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKTtcbiAgICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLm9mRXBvY2hTZWNvbmQobG8gLSBTRUNPTkRTXzAwMDBfVE9fMTk3MCwgMCwgWm9uZU9mZnNldC5VVEMpO1xuICAgICAgaWYgKGhpID4gMCkge1xuICAgICAgICBidWYuYXBwZW5kKCcrJykuYXBwZW5kKGhpKTtcbiAgICAgIH1cbiAgICAgIGJ1Zi5hcHBlbmQobGR0LnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKGxkdC5zZWNvbmQoKSA9PT0gMCkge1xuICAgICAgICBidWYuYXBwZW5kKCc6MDAnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF96ZXJvU2VjcyA9IGluU2VjICsgU0VDT05EU18wMDAwX1RPXzE5NzA7XG4gICAgICB2YXIgX2hpID0gTWF0aFV0aWwuaW50RGl2KF96ZXJvU2VjcywgU0VDT05EU19QRVJfMTAwMDBfWUVBUlMpO1xuICAgICAgdmFyIF9sbyA9IE1hdGhVdGlsLmludE1vZChfemVyb1NlY3MsIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKTtcbiAgICAgIHZhciBfbGR0ID0gTG9jYWxEYXRlVGltZS5vZkVwb2NoU2Vjb25kKF9sbyAtIFNFQ09ORFNfMDAwMF9UT18xOTcwLCAwLCBab25lT2Zmc2V0LlVUQyk7XG4gICAgICB2YXIgcG9zID0gYnVmLmxlbmd0aCgpO1xuICAgICAgYnVmLmFwcGVuZChfbGR0LnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKF9sZHQuc2Vjb25kKCkgPT09IDApIHtcbiAgICAgICAgYnVmLmFwcGVuZCgnOjAwJyk7XG4gICAgICB9XG4gICAgICBpZiAoX2hpIDwgMCkge1xuICAgICAgICBpZiAoX2xkdC55ZWFyKCkgPT09IC0xMDAwMCkge1xuICAgICAgICAgIGJ1Zi5yZXBsYWNlKHBvcywgcG9zICsgMiwgXCJcIiArIChfaGkgLSAxKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2xvID09PSAwKSB7XG4gICAgICAgICAgYnVmLmluc2VydChwb3MsIF9oaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmLmluc2VydChwb3MgKyAxLCBNYXRoLmFicyhfaGkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mcmFjdGlvbmFsRGlnaXRzID09PSAtMikge1xuICAgICAgaWYgKGluTmFubyAhPT0gMCkge1xuICAgICAgICBidWYuYXBwZW5kKCcuJyk7XG4gICAgICAgIGlmIChNYXRoVXRpbC5pbnRNb2QoaW5OYW5vLCAxMDAwMDAwKSA9PT0gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQoKFwiXCIgKyAoTWF0aFV0aWwuaW50RGl2KGluTmFubywgMTAwMDAwMCkgKyAxMDAwKSkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoVXRpbC5pbnRNb2QoaW5OYW5vLCAxMDAwKSA9PT0gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQoKFwiXCIgKyAoTWF0aFV0aWwuaW50RGl2KGluTmFubywgMTAwMCkgKyAxMDAwMDAwKSkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYuYXBwZW5kKChcIlwiICsgKGluTmFubyArIDEwMDAwMDAwMDApKS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmZyYWN0aW9uYWxEaWdpdHMgPiAwIHx8IHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA9PT0gLTEgJiYgaW5OYW5vID4gMCkge1xuICAgICAgYnVmLmFwcGVuZCgnLicpO1xuICAgICAgdmFyIGRpdiA9IDEwMDAwMDAwMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLmZyYWN0aW9uYWxEaWdpdHMgPT09IC0xICYmIGluTmFubyA+IDAgfHwgaSA8IHRoaXMuZnJhY3Rpb25hbERpZ2l0czsgaSsrKSB7XG4gICAgICAgIHZhciBkaWdpdCA9IE1hdGhVdGlsLmludERpdihpbk5hbm8sIGRpdik7XG4gICAgICAgIGJ1Zi5hcHBlbmQoZGlnaXQpO1xuICAgICAgICBpbk5hbm8gPSBpbk5hbm8gLSBkaWdpdCAqIGRpdjtcbiAgICAgICAgZGl2ID0gTWF0aFV0aWwuaW50RGl2KGRpdiwgMTApO1xuICAgICAgfVxuICAgIH1cbiAgICBidWYuYXBwZW5kKCdaJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9wcm90bzIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBuZXdDb250ZXh0ID0gY29udGV4dC5jb3B5KCk7XG4gICAgdmFyIG1pbkRpZ2l0cyA9IHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA8IDAgPyAwIDogdGhpcy5mcmFjdGlvbmFsRGlnaXRzO1xuICAgIHZhciBtYXhEaWdpdHMgPSB0aGlzLmZyYWN0aW9uYWxEaWdpdHMgPCAwID8gOSA6IHRoaXMuZnJhY3Rpb25hbERpZ2l0cztcbiAgICB2YXIgcGFyc2VyID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfREFURSkuYXBwZW5kTGl0ZXJhbCgnVCcpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLCAyKS5hcHBlbmRMaXRlcmFsKCc6JykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIsIDIpLmFwcGVuZExpdGVyYWwoJzonKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFLCAyKS5hcHBlbmRGcmFjdGlvbihDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCwgbWluRGlnaXRzLCBtYXhEaWdpdHMsIHRydWUpLmFwcGVuZExpdGVyYWwoJ1onKS50b0Zvcm1hdHRlcigpLl90b1ByaW50ZXJQYXJzZXIoZmFsc2UpO1xuICAgIHZhciBwb3MgPSBwYXJzZXIucGFyc2UobmV3Q29udGV4dCwgdGV4dCwgcG9zaXRpb24pO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICB2YXIgeWVhclBhcnNlZCA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLllFQVIpO1xuICAgIHZhciBtb250aCA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpO1xuICAgIHZhciBkYXkgPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpO1xuICAgIHZhciBob3VyID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVkpO1xuICAgIHZhciBtaW4gPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUik7XG4gICAgdmFyIHNlY1ZhbCA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUpO1xuICAgIHZhciBuYW5vVmFsID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuICAgIHZhciBzZWMgPSBzZWNWYWwgIT0gbnVsbCA/IHNlY1ZhbCA6IDA7XG4gICAgdmFyIG5hbm8gPSBuYW5vVmFsICE9IG51bGwgPyBuYW5vVmFsIDogMDtcbiAgICB2YXIgeWVhciA9IE1hdGhVdGlsLmludE1vZCh5ZWFyUGFyc2VkLCAxMDAwMCk7XG4gICAgdmFyIGRheXMgPSAwO1xuICAgIGlmIChob3VyID09PSAyNCAmJiBtaW4gPT09IDAgJiYgc2VjID09PSAwICYmIG5hbm8gPT09IDApIHtcbiAgICAgIGhvdXIgPSAwO1xuICAgICAgZGF5cyA9IDE7XG4gICAgfSBlbHNlIGlmIChob3VyID09PSAyMyAmJiBtaW4gPT09IDU5ICYmIHNlYyA9PT0gNjApIHtcbiAgICAgIGNvbnRleHQuc2V0UGFyc2VkTGVhcFNlY29uZCgpO1xuICAgICAgc2VjID0gNTk7XG4gICAgfVxuICAgIHZhciBpbnN0YW50U2VjcztcbiAgICB0cnkge1xuICAgICAgdmFyIGxkdCA9IExvY2FsRGF0ZVRpbWUub2YoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMsIDApLnBsdXNEYXlzKGRheXMpO1xuICAgICAgaW5zdGFudFNlY3MgPSBsZHQudG9FcG9jaFNlY29uZChab25lT2Zmc2V0LlVUQyk7XG4gICAgICBpbnN0YW50U2VjcyArPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoTWF0aFV0aWwuaW50RGl2KHllYXJQYXJzZWQsIDEwMDAwKSwgU0VDT05EU19QRVJfMTAwMDBfWUVBUlMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cbiAgICB2YXIgc3VjY2Vzc1BvcyA9IHBvcztcbiAgICBzdWNjZXNzUG9zID0gY29udGV4dC5zZXRQYXJzZWRGaWVsZChDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMsIGluc3RhbnRTZWNzLCBwb3NpdGlvbiwgc3VjY2Vzc1Bvcyk7XG4gICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIG5hbm8sIHBvc2l0aW9uLCBzdWNjZXNzUG9zKTtcbiAgfTtcbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnSW5zdGFudCgpJztcbiAgfTtcbiAgcmV0dXJuIEluc3RhbnRQcmludGVyUGFyc2VyO1xufSgpO1xudmFyIERlZmF1bHRpbmdQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlZmF1bHRpbmdQYXJzZXIoZmllbGQsIHZhbHVlKSB7XG4gICAgdGhpcy5fZmllbGQgPSBmaWVsZDtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHZhciBfcHJvdG8zID0gRGVmYXVsdGluZ1BhcnNlci5wcm90b3R5cGU7XG4gIF9wcm90bzMucHJpbnQgPSBmdW5jdGlvbiBwcmludCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX3Byb3RvMy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKGNvbnRleHQuZ2V0UGFyc2VkKHRoaXMuX2ZpZWxkKSA9PSBudWxsKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZEZpZWxkKHRoaXMuX2ZpZWxkLCB0aGlzLl92YWx1ZSwgcG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuICByZXR1cm4gRGVmYXVsdGluZ1BhcnNlcjtcbn0oKTtcbmZ1bmN0aW9uIF9pbml0JGUoKSB7XG4gIFJlZHVjZWRQcmludGVyUGFyc2VyLkJBU0VfREFURSA9IExvY2FsRGF0ZS5vZigyMDAwLCAxLCAxKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLkNvbXBvc2l0ZVByaW50ZXJQYXJzZXIgPSBDb21wb3NpdGVQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuUGFkUHJpbnRlclBhcnNlckRlY29yYXRvciA9IFBhZFByaW50ZXJQYXJzZXJEZWNvcmF0b3I7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5TZXR0aW5nc1BhcnNlciA9IFNldHRpbmdzUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyID0gU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5TdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlciA9IFN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyID0gQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuTnVtYmVyUHJpbnRlclBhcnNlciA9IE51bWJlclByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5SZWR1Y2VkUHJpbnRlclBhcnNlciA9IFJlZHVjZWRQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuRnJhY3Rpb25QcmludGVyUGFyc2VyID0gRnJhY3Rpb25QcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuT2Zmc2V0SWRQcmludGVyUGFyc2VyID0gT2Zmc2V0SWRQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuWm9uZUlkUHJpbnRlclBhcnNlciA9IFpvbmVJZFByaW50ZXJQYXJzZXI7XG59XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi92YXIgU3RyaW5nQnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyaW5nQnVpbGRlcigpIHtcbiAgICB0aGlzLl9zdHIgPSAnJztcbiAgfVxuICB2YXIgX3Byb3RvID0gU3RyaW5nQnVpbGRlci5wcm90b3R5cGU7XG4gIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RyKSB7XG4gICAgdGhpcy5fc3RyICs9IHN0cjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLmFwcGVuZENoYXIgPSBmdW5jdGlvbiBhcHBlbmRDaGFyKHN0cikge1xuICAgIHRoaXMuX3N0ciArPSBzdHJbMF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9wcm90by5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQob2Zmc2V0LCBzdHIpIHtcbiAgICB0aGlzLl9zdHIgPSB0aGlzLl9zdHIuc2xpY2UoMCwgb2Zmc2V0KSArIHN0ciArIHRoaXMuX3N0ci5zbGljZShvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhcnQsIGVuZCwgc3RyKSB7XG4gICAgdGhpcy5fc3RyID0gdGhpcy5fc3RyLnNsaWNlKDAsIHN0YXJ0KSArIHN0ciArIHRoaXMuX3N0ci5zbGljZShlbmQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8ubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHIubGVuZ3RoO1xuICB9O1xuICBfcHJvdG8uc2V0TGVuZ3RoID0gZnVuY3Rpb24gc2V0TGVuZ3RoKGxlbmd0aCkge1xuICAgIHRoaXMuX3N0ciA9IHRoaXMuX3N0ci5zbGljZSgwLCBsZW5ndGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyO1xuICB9O1xuICByZXR1cm4gU3RyaW5nQnVpbGRlcjtcbn0oKTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG52YXIgRGF0ZVRpbWVGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIERhdGVUaW1lRm9ybWF0dGVyLnBhcnNlZEV4Y2Vzc0RheXMgPSBmdW5jdGlvbiBwYXJzZWRFeGNlc3NEYXlzKCkge1xuICAgIHJldHVybiBEYXRlVGltZUZvcm1hdHRlci5QQVJTRURfRVhDRVNTX0RBWVM7XG4gIH07XG4gIERhdGVUaW1lRm9ybWF0dGVyLnBhcnNlZExlYXBTZWNvbmQgPSBmdW5jdGlvbiBwYXJzZWRMZWFwU2Vjb25kKCkge1xuICAgIHJldHVybiBEYXRlVGltZUZvcm1hdHRlci5QQVJTRURfTEVBUF9TRUNPTkQ7XG4gIH07XG4gIERhdGVUaW1lRm9ybWF0dGVyLm9mUGF0dGVybiA9IGZ1bmN0aW9uIG9mUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRQYXR0ZXJuKHBhdHRlcm4pLnRvRm9ybWF0dGVyKCk7XG4gIH07XG4gIGZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0dGVyKHByaW50ZXJQYXJzZXIsIGxvY2FsZSwgZGVjaW1hbFN0eWxlLCByZXNvbHZlclN0eWxlLCByZXNvbHZlckZpZWxkcywgY2hyb25vLCB6b25lKSB7XG4gICAgaWYgKGNocm9ubyA9PT0gdm9pZCAwKSB7XG4gICAgICBjaHJvbm8gPSBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgIH1cbiAgICBhc3NlcnQocHJpbnRlclBhcnNlciAhPSBudWxsKTtcbiAgICBhc3NlcnQoZGVjaW1hbFN0eWxlICE9IG51bGwpO1xuICAgIGFzc2VydChyZXNvbHZlclN0eWxlICE9IG51bGwpO1xuICAgIHRoaXMuX3ByaW50ZXJQYXJzZXIgPSBwcmludGVyUGFyc2VyO1xuICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLl9kZWNpbWFsU3R5bGUgPSBkZWNpbWFsU3R5bGU7XG4gICAgdGhpcy5fcmVzb2x2ZXJTdHlsZSA9IHJlc29sdmVyU3R5bGU7XG4gICAgdGhpcy5fcmVzb2x2ZXJGaWVsZHMgPSByZXNvbHZlckZpZWxkcztcbiAgICB0aGlzLl9jaHJvbm8gPSBjaHJvbm87XG4gICAgdGhpcy5fem9uZSA9IHpvbmU7XG4gIH1cbiAgdmFyIF9wcm90byA9IERhdGVUaW1lRm9ybWF0dGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLmxvY2FsZSA9IGZ1bmN0aW9uIGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICB9O1xuICBfcHJvdG8uZGVjaW1hbFN0eWxlID0gZnVuY3Rpb24gZGVjaW1hbFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWNpbWFsU3R5bGU7XG4gIH07XG4gIF9wcm90by5jaHJvbm9sb2d5ID0gZnVuY3Rpb24gY2hyb25vbG9neSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hyb25vO1xuICB9O1xuICBfcHJvdG8ud2l0aENocm9ub2xvZ3kgPSBmdW5jdGlvbiB3aXRoQ2hyb25vbG9neShjaHJvbm8pIHtcbiAgICBpZiAodGhpcy5fY2hyb25vICE9IG51bGwgJiYgdGhpcy5fY2hyb25vLmVxdWFscyhjaHJvbm8pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdHRlcih0aGlzLl9wcmludGVyUGFyc2VyLCB0aGlzLl9sb2NhbGUsIHRoaXMuX2RlY2ltYWxTdHlsZSwgdGhpcy5fcmVzb2x2ZXJTdHlsZSwgdGhpcy5fcmVzb2x2ZXJGaWVsZHMsIGNocm9ubywgdGhpcy5fem9uZSk7XG4gIH07XG4gIF9wcm90by53aXRoTG9jYWxlID0gZnVuY3Rpb24gd2l0aExvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLndpdGhSZXNvbHZlclN0eWxlID0gZnVuY3Rpb24gd2l0aFJlc29sdmVyU3R5bGUocmVzb2x2ZXJTdHlsZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHJlc29sdmVyU3R5bGUsICdyZXNvbHZlclN0eWxlJyk7XG4gICAgaWYgKHJlc29sdmVyU3R5bGUuZXF1YWxzKHRoaXMuX3Jlc29sdmVyU3R5bGUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZUZvcm1hdHRlcih0aGlzLl9wcmludGVyUGFyc2VyLCB0aGlzLl9sb2NhbGUsIHRoaXMuX2RlY2ltYWxTdHlsZSwgcmVzb2x2ZXJTdHlsZSwgdGhpcy5fcmVzb2x2ZXJGaWVsZHMsIHRoaXMuX2Nocm9ubywgdGhpcy5fem9uZSk7XG4gIH07XG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQodGVtcG9yYWwpIHtcbiAgICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoMzIpO1xuICAgIHRoaXMuX2Zvcm1hdFRvKHRlbXBvcmFsLCBidWYpO1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcbiAgfTtcbiAgX3Byb3RvLl9mb3JtYXRUbyA9IGZ1bmN0aW9uIF9mb3JtYXRUbyh0ZW1wb3JhbCwgYXBwZW5kYWJsZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXF1aXJlTm9uTnVsbChhcHBlbmRhYmxlLCAnYXBwZW5kYWJsZScpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IERhdGVUaW1lUHJpbnRDb250ZXh0KHRlbXBvcmFsLCB0aGlzKTtcbiAgICB0aGlzLl9wcmludGVyUGFyc2VyLnByaW50KGNvbnRleHQsIGFwcGVuZGFibGUpO1xuICB9O1xuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0LCB0eXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlMSh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2UyKHRleHQsIHR5cGUpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnBhcnNlMSA9IGZ1bmN0aW9uIHBhcnNlMSh0ZXh0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVG9CdWlsZGVyKHRleHQsIG51bGwpLnJlc29sdmUodGhpcy5fcmVzb2x2ZXJTdHlsZSwgdGhpcy5fcmVzb2x2ZXJGaWVsZHMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IodGV4dCwgZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnBhcnNlMiA9IGZ1bmN0aW9uIHBhcnNlMih0ZXh0LCB0eXBlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh0eXBlLCAndHlwZScpO1xuICAgIHRyeSB7XG4gICAgICB2YXIgYnVpbGRlciA9IHRoaXMuX3BhcnNlVG9CdWlsZGVyKHRleHQsIG51bGwpLnJlc29sdmUodGhpcy5fcmVzb2x2ZXJTdHlsZSwgdGhpcy5fcmVzb2x2ZXJGaWVsZHMpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXIuYnVpbGQodHlwZSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIERhdGVUaW1lUGFyc2VFeGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcih0ZXh0LCBleCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX2NyZWF0ZUVycm9yID0gZnVuY3Rpb24gX2NyZWF0ZUVycm9yKHRleHQsIGV4KSB7XG4gICAgdmFyIGFiYnIgPSAnJztcbiAgICBpZiAodGV4dC5sZW5ndGggPiA2NCkge1xuICAgICAgYWJiciA9IHRleHQuc3Vic3RyaW5nKDAsIDY0KSArIFwiLi4uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFiYnIgPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oXCJUZXh0ICdcIiArIGFiYnIgKyBcIicgY291bGQgbm90IGJlIHBhcnNlZDogXCIgKyBleC5tZXNzYWdlLCB0ZXh0LCAwLCBleCk7XG4gIH07XG4gIF9wcm90by5fcGFyc2VUb0J1aWxkZXIgPSBmdW5jdGlvbiBfcGFyc2VUb0J1aWxkZXIodGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24gIT0gbnVsbCA/IHBvc2l0aW9uIDogbmV3IFBhcnNlUG9zaXRpb24oMCk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3BhcnNlVW5yZXNvbHZlZDAodGV4dCwgcG9zKTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcG9zLmdldEVycm9ySW5kZXgoKSA+PSAwIHx8IHBvc2l0aW9uID09IG51bGwgJiYgcG9zLmdldEluZGV4KCkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgdmFyIGFiYnIgPSAnJztcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDY0KSB7XG4gICAgICAgIGFiYnIgPSB0ZXh0LnN1YnN0cigwLCA2NCkudG9TdHJpbmcoKSArIFwiLi4uXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhYmJyID0gdGV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MuZ2V0RXJyb3JJbmRleCgpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oXCJUZXh0ICdcIiArIGFiYnIgKyBcIicgY291bGQgbm90IGJlIHBhcnNlZCBhdCBpbmRleCBcIiArIHBvcy5nZXRFcnJvckluZGV4KCksIHRleHQsIHBvcy5nZXRFcnJvckluZGV4KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oXCJUZXh0ICdcIiArIGFiYnIgKyBcIicgY291bGQgbm90IGJlIHBhcnNlZCwgdW5wYXJzZWQgdGV4dCBmb3VuZCBhdCBpbmRleCBcIiArIHBvcy5nZXRJbmRleCgpLCB0ZXh0LCBwb3MuZ2V0SW5kZXgoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudG9CdWlsZGVyKCk7XG4gIH07XG4gIF9wcm90by5wYXJzZVVucmVzb2x2ZWQgPSBmdW5jdGlvbiBwYXJzZVVucmVzb2x2ZWQodGV4dCwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyc2VVbnJlc29sdmVkMCh0ZXh0LCBwb3NpdGlvbik7XG4gIH07XG4gIF9wcm90by5fcGFyc2VVbnJlc29sdmVkMCA9IGZ1bmN0aW9uIF9wYXJzZVVucmVzb2x2ZWQwKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgYXNzZXJ0KHRleHQgIT0gbnVsbCwgJ3RleHQnLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG4gICAgYXNzZXJ0KHBvc2l0aW9uICE9IG51bGwsICdwb3NpdGlvbicsIE51bGxQb2ludGVyRXhjZXB0aW9uKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBEYXRlVGltZVBhcnNlQ29udGV4dCh0aGlzKTtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24uZ2V0SW5kZXgoKTtcbiAgICBwb3MgPSB0aGlzLl9wcmludGVyUGFyc2VyLnBhcnNlKGNvbnRleHQsIHRleHQsIHBvcyk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHBvc2l0aW9uLnNldEVycm9ySW5kZXgofnBvcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcG9zaXRpb24uc2V0SW5kZXgocG9zKTtcbiAgICByZXR1cm4gY29udGV4dC50b1BhcnNlZCgpO1xuICB9O1xuICBfcHJvdG8uX3RvUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uIF90b1ByaW50ZXJQYXJzZXIob3B0aW9uYWwpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpbnRlclBhcnNlci53aXRoT3B0aW9uYWwob3B0aW9uYWwpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgcGF0dGVybiA9IHRoaXMuX3ByaW50ZXJQYXJzZXIudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKCdbJykgPT09IDAgPyBwYXR0ZXJuIDogcGF0dGVybi5zdWJzdHJpbmcoMSwgcGF0dGVybi5sZW5ndGggLSAxKTtcbiAgfTtcbiAgcmV0dXJuIERhdGVUaW1lRm9ybWF0dGVyO1xufSgpO1xuZnVuY3Rpb24gX2luaXQkZCgpIHtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuWUVBUiwgNCwgMTAsIFNpZ25TdHlsZS5FWENFRURTX1BBRCkuYXBwZW5kTGl0ZXJhbCgnLScpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIDIpLmFwcGVuZExpdGVyYWwoJy0nKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDIpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX1RJTUUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIDIpLmFwcGVuZExpdGVyYWwoJzonKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiwgMikub3B0aW9uYWxTdGFydCgpLmFwcGVuZExpdGVyYWwoJzonKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFLCAyKS5vcHRpb25hbFN0YXJ0KCkuYXBwZW5kRnJhY3Rpb24oQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIDAsIDksIHRydWUpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEVfVElNRSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfREFURSkuYXBwZW5kTGl0ZXJhbCgnVCcpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRSkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5JU09fSU5TVEFOVCA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZEluc3RhbnQoKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19PRkZTRVRfREFURV9USU1FID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLnBhcnNlQ2FzZUluc2Vuc2l0aXZlKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFX1RJTUUpLmFwcGVuZE9mZnNldElkKCkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5JU09fWk9ORURfREFURV9USU1FID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fT0ZGU0VUX0RBVEVfVElNRSkub3B0aW9uYWxTdGFydCgpLmFwcGVuZExpdGVyYWwoJ1snKS5wYXJzZUNhc2VTZW5zaXRpdmUoKS5hcHBlbmRab25lSWQoKS5hcHBlbmRMaXRlcmFsKCddJykudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5CQVNJQ19JU09fREFURSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCAyKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDIpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9EQVRFID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLnBhcnNlQ2FzZUluc2Vuc2l0aXZlKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFKS5hcHBlbmRPZmZzZXRJZCgpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9USU1FID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLnBhcnNlQ2FzZUluc2Vuc2l0aXZlKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9USU1FKS5hcHBlbmRPZmZzZXRJZCgpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09SRElOQUxfREFURSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX1dFRUtfREFURSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRMaXRlcmFsKCctVycpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuREFZX09GX1dFRUspLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0RBVEUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkucGFyc2VDYXNlSW5zZW5zaXRpdmUoKS5hcHBlbmQoRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEUpLm9wdGlvbmFsU3RhcnQoKS5hcHBlbmRPZmZzZXRJZCgpLm9wdGlvbmFsRW5kKCkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5JU09fVElNRSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRSkub3B0aW9uYWxTdGFydCgpLmFwcGVuZE9mZnNldElkKCkub3B0aW9uYWxFbmQoKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19EQVRFX1RJTUUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFX1RJTUUpLm9wdGlvbmFsU3RhcnQoKS5hcHBlbmRPZmZzZXRJZCgpLm9wdGlvbmFsRW5kKCkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5QQVJTRURfRVhDRVNTX0RBWVMgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdQQVJTRURfRVhDRVNTX0RBWVMnLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBEYXRlVGltZUJ1aWxkZXIpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbC5leGNlc3NEYXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGVyaW9kLlpFUk87XG4gICAgfVxuICB9KTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuUEFSU0VEX0xFQVBfU0VDT05EID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnUEFSU0VEX0xFQVBfU0VDT05EJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgRGF0ZVRpbWVCdWlsZGVyKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWwubGVhcFNlY29uZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBNb250aERheSA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShNb250aERheSwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuICBNb250aERheS5ub3cgPSBmdW5jdGlvbiBub3coem9uZUlkT3JDbG9jaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkubm93MCgpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB6b25lSWRPckNsb2NrIGluc3RhbmNlb2YgWm9uZUlkKSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkubm93Wm9uZUlkKHpvbmVJZE9yQ2xvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkubm93Q2xvY2soem9uZUlkT3JDbG9jayk7XG4gICAgfVxuICB9O1xuICBNb250aERheS5ub3cwID0gZnVuY3Rpb24gbm93MCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub3dDbG9jayhDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpKTtcbiAgfTtcbiAgTW9udGhEYXkubm93Wm9uZUlkID0gZnVuY3Rpb24gbm93Wm9uZUlkKHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHJldHVybiB0aGlzLm5vd0Nsb2NrKENsb2NrLnN5c3RlbSh6b25lKSk7XG4gIH07XG4gIE1vbnRoRGF5Lm5vd0Nsb2NrID0gZnVuY3Rpb24gbm93Q2xvY2soY2xvY2spIHtcbiAgICByZXF1aXJlTm9uTnVsbChjbG9jaywgJ2Nsb2NrJyk7XG4gICAgdmFyIG5vdyA9IExvY2FsRGF0ZS5ub3coY2xvY2spO1xuICAgIHJldHVybiBNb250aERheS5vZihub3cubW9udGgoKSwgbm93LmRheU9mTW9udGgoKSk7XG4gIH07XG4gIE1vbnRoRGF5Lm9mID0gZnVuY3Rpb24gb2YobW9udGhPck51bWJlciwgbnVtYmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgbW9udGhPck51bWJlciBpbnN0YW5jZW9mIE1vbnRoKSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkub2ZNb250aE51bWJlcihtb250aE9yTnVtYmVyLCBudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkub2ZOdW1iZXJOdW1iZXIobW9udGhPck51bWJlciwgbnVtYmVyKTtcbiAgICB9XG4gIH07XG4gIE1vbnRoRGF5Lm9mTW9udGhOdW1iZXIgPSBmdW5jdGlvbiBvZk1vbnRoTnVtYmVyKG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuICAgIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USC5jaGVja1ZhbGlkVmFsdWUoZGF5T2ZNb250aCk7XG4gICAgaWYgKGRheU9mTW9udGggPiBtb250aC5tYXhMZW5ndGgoKSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSWxsZWdhbCB2YWx1ZSBmb3IgRGF5T2ZNb250aCBmaWVsZCwgdmFsdWUgXCIgKyBkYXlPZk1vbnRoICsgXCIgaXMgbm90IHZhbGlkIGZvciBtb250aCBcIiArIG1vbnRoLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1vbnRoRGF5KG1vbnRoLnZhbHVlKCksIGRheU9mTW9udGgpO1xuICB9O1xuICBNb250aERheS5vZk51bWJlck51bWJlciA9IGZ1bmN0aW9uIG9mTnVtYmVyTnVtYmVyKG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mTW9udGgsICdkYXlPZk1vbnRoJyk7XG4gICAgcmV0dXJuIE1vbnRoRGF5Lm9mKE1vbnRoLm9mKG1vbnRoKSwgZGF5T2ZNb250aCk7XG4gIH07XG4gIE1vbnRoRGF5LmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh0ZW1wb3JhbCwgVGVtcG9yYWxBY2Nlc3NvciwgJ3RlbXBvcmFsJyk7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgTW9udGhEYXkpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBNb250aERheS5vZih0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiksIHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBNb250aERheSBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbCAmJiB0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuICBNb250aERheS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gTW9udGhEYXkucGFyc2VTdHJpbmcodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNb250aERheS5wYXJzZVN0cmluZ0Zvcm1hdHRlcih0ZXh0LCBmb3JtYXR0ZXIpO1xuICAgIH1cbiAgfTtcbiAgTW9udGhEYXkucGFyc2VTdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVN0cmluZyh0ZXh0KSB7XG4gICAgcmV0dXJuIE1vbnRoRGF5LnBhcnNlU3RyaW5nRm9ybWF0dGVyKHRleHQsIFBBUlNFUiQyKTtcbiAgfTtcbiAgTW9udGhEYXkucGFyc2VTdHJpbmdGb3JtYXR0ZXIgPSBmdW5jdGlvbiBwYXJzZVN0cmluZ0Zvcm1hdHRlcih0ZXh0LCBmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmb3JtYXR0ZXIsIERhdGVUaW1lRm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBNb250aERheS5GUk9NKTtcbiAgfTtcbiAgZnVuY3Rpb24gTW9udGhEYXkobW9udGgsIGRheU9mTW9udGgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBY2Nlc3Nvci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX21vbnRoID0gTWF0aFV0aWwuc2FmZVRvSW50KG1vbnRoKTtcbiAgICBfdGhpcy5fZGF5ID0gTWF0aFV0aWwuc2FmZVRvSW50KGRheU9mTW9udGgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gTW9udGhEYXkucHJvdG90eXBlO1xuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuICB9O1xuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gTW9udGgub2YodGhpcy5fbW9udGgpO1xuICB9O1xuICBfcHJvdG8uZGF5T2ZNb250aCA9IGZ1bmN0aW9uIGRheU9mTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RheTtcbiAgfTtcbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkID09PSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSIHx8IGZpZWxkID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZCAhPSBudWxsICYmIGZpZWxkLmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSB7XG4gICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpIHtcbiAgICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIHRoaXMubW9udGgoKS5taW5MZW5ndGgoKSwgdGhpcy5tb250aCgpLm1heExlbmd0aCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9UZW1wb3JhbEFjY2Vzc29yLnByb3RvdHlwZS5yYW5nZS5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RheTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aDtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5pc1ZhbGlkWWVhciA9IGZ1bmN0aW9uIGlzVmFsaWRZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gKHRoaXMuX2RheSA9PT0gMjkgJiYgdGhpcy5fbW9udGggPT09IDIgJiYgWWVhci5pc0xlYXAoeWVhcikgPT09IGZhbHNlKSA9PT0gZmFsc2U7XG4gIH07XG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy53aXRoKE1vbnRoLm9mKG1vbnRoKSk7XG4gIH07XG4gIF9wcm90by53aXRoID0gZnVuY3Rpb24gX3dpdGgobW9udGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgaWYgKG1vbnRoLnZhbHVlKCkgPT09IHRoaXMuX21vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGRheSA9IE1hdGgubWluKHRoaXMuX2RheSwgbW9udGgubWF4TGVuZ3RoKCkpO1xuICAgIHJldHVybiBuZXcgTW9udGhEYXkobW9udGgudmFsdWUoKSwgZGF5KTtcbiAgfTtcbiAgX3Byb3RvLndpdGhEYXlPZk1vbnRoID0gZnVuY3Rpb24gd2l0aERheU9mTW9udGgoZGF5T2ZNb250aCkge1xuICAgIGlmIChkYXlPZk1vbnRoID09PSB0aGlzLl9kYXkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTW9udGhEYXkub2YodGhpcy5fbW9udGgsIGRheU9mTW9udGgpO1xuICB9O1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShfcXVlcnksIFRlbXBvcmFsUXVlcnksICdxdWVyeScpO1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgIH1cbiAgICByZXR1cm4gX1RlbXBvcmFsQWNjZXNzb3IucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHRlbXBvcmFsID0gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCB0aGlzLl9tb250aCk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCBNYXRoLm1pbih0ZW1wb3JhbC5yYW5nZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpLm1heGltdW0oKSwgdGhpcy5fZGF5KSk7XG4gIH07XG4gIF9wcm90by5hdFllYXIgPSBmdW5jdGlvbiBhdFllYXIoeWVhcikge1xuICAgIHJldHVybiBMb2NhbERhdGUub2YoeWVhciwgdGhpcy5fbW9udGgsIHRoaXMuaXNWYWxpZFllYXIoeWVhcikgPyB0aGlzLl9kYXkgOiAyOCk7XG4gIH07XG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBNb250aERheSwgJ290aGVyJyk7XG4gICAgdmFyIGNtcCA9IHRoaXMuX21vbnRoIC0gb3RoZXIubW9udGhWYWx1ZSgpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGNtcCA9IHRoaXMuX2RheSAtIG90aGVyLmRheU9mTW9udGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNtcDtcbiAgfTtcbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgTW9udGhEYXksICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICB9O1xuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE1vbnRoRGF5LCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpIDwgMDtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvYmopIHtcbiAgICBpZiAodGhpcyA9PT0gb2JqKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1vbnRoRGF5KSB7XG4gICAgICB2YXIgb3RoZXIgPSBvYmo7XG4gICAgICByZXR1cm4gdGhpcy5tb250aFZhbHVlKCkgPT09IG90aGVyLm1vbnRoVmFsdWUoKSAmJiB0aGlzLmRheU9mTW9udGgoKSA9PT0gb3RoZXIuZGF5T2ZNb250aCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIi0tXCIgKyAodGhpcy5fbW9udGggPCAxMCA/ICcwJyA6ICcnKSArIHRoaXMuX21vbnRoICsgKHRoaXMuX2RheSA8IDEwID8gJy0wJyA6ICctJykgKyB0aGlzLl9kYXk7XG4gIH07XG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuICByZXR1cm4gTW9udGhEYXk7XG59KFRlbXBvcmFsQWNjZXNzb3IpO1xudmFyIFBBUlNFUiQyO1xuZnVuY3Rpb24gX2luaXQkYygpIHtcbiAgUEFSU0VSJDIgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kTGl0ZXJhbCgnLS0nKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCAyKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCAyKS50b0Zvcm1hdHRlcigpO1xuICBNb250aERheS5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnTW9udGhEYXkuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBNb250aERheS5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBZZWFyTW9udGggPSBmdW5jdGlvbiAoX1RlbXBvcmFsKSB7XG4gIF9pbmhlcml0c0xvb3NlKFllYXJNb250aCwgX1RlbXBvcmFsKTtcbiAgWWVhck1vbnRoLm5vdyA9IGZ1bmN0aW9uIG5vdyh6b25lSWRPckNsb2NrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgubm93MCgpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB6b25lSWRPckNsb2NrIGluc3RhbmNlb2YgWm9uZUlkKSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLm5vd1pvbmVJZCh6b25lSWRPckNsb2NrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFllYXJNb250aC5ub3dDbG9jayh6b25lSWRPckNsb2NrKTtcbiAgICB9XG4gIH07XG4gIFllYXJNb250aC5ub3cwID0gZnVuY3Rpb24gbm93MCgpIHtcbiAgICByZXR1cm4gWWVhck1vbnRoLm5vd0Nsb2NrKENsb2NrLnN5c3RlbURlZmF1bHRab25lKCkpO1xuICB9O1xuICBZZWFyTW9udGgubm93Wm9uZUlkID0gZnVuY3Rpb24gbm93Wm9uZUlkKHpvbmUpIHtcbiAgICByZXR1cm4gWWVhck1vbnRoLm5vd0Nsb2NrKENsb2NrLnN5c3RlbSh6b25lKSk7XG4gIH07XG4gIFllYXJNb250aC5ub3dDbG9jayA9IGZ1bmN0aW9uIG5vd0Nsb2NrKGNsb2NrKSB7XG4gICAgdmFyIG5vdyA9IExvY2FsRGF0ZS5ub3coY2xvY2spO1xuICAgIHJldHVybiBZZWFyTW9udGgub2Yobm93LnllYXIoKSwgbm93Lm1vbnRoKCkpO1xuICB9O1xuICBZZWFyTW9udGgub2YgPSBmdW5jdGlvbiBvZih5ZWFyLCBtb250aE9yTnVtYmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgbW9udGhPck51bWJlciBpbnN0YW5jZW9mIE1vbnRoKSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLm9mTnVtYmVyTW9udGgoeWVhciwgbW9udGhPck51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgub2ZOdW1iZXJOdW1iZXIoeWVhciwgbW9udGhPck51bWJlcik7XG4gICAgfVxuICB9O1xuICBZZWFyTW9udGgub2ZOdW1iZXJNb250aCA9IGZ1bmN0aW9uIG9mTnVtYmVyTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG1vbnRoLCBNb250aCwgJ21vbnRoJyk7XG4gICAgcmV0dXJuIFllYXJNb250aC5vZk51bWJlck51bWJlcih5ZWFyLCBtb250aC52YWx1ZSgpKTtcbiAgfTtcbiAgWWVhck1vbnRoLm9mTnVtYmVyTnVtYmVyID0gZnVuY3Rpb24gb2ZOdW1iZXJOdW1iZXIoeWVhciwgbW9udGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh5ZWFyLCAneWVhcicpO1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoLCAnbW9udGgnKTtcbiAgICBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRWYWx1ZSh5ZWFyKTtcbiAgICBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLmNoZWNrVmFsaWRWYWx1ZShtb250aCk7XG4gICAgcmV0dXJuIG5ldyBZZWFyTW9udGgoeWVhciwgbW9udGgpO1xuICB9O1xuICBZZWFyTW9udGguZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgWWVhck1vbnRoKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLm9mKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5ZRUFSKSwgdGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBZZWFyTW9udGggZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwgJiYgdGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgfTtcbiAgWWVhck1vbnRoLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgucGFyc2VTdHJpbmcodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgucGFyc2VTdHJpbmdGb3JtYXR0ZXIodGV4dCwgZm9ybWF0dGVyKTtcbiAgICB9XG4gIH07XG4gIFllYXJNb250aC5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHRleHQpIHtcbiAgICByZXR1cm4gWWVhck1vbnRoLnBhcnNlU3RyaW5nRm9ybWF0dGVyKHRleHQsIFBBUlNFUiQxKTtcbiAgfTtcbiAgWWVhck1vbnRoLnBhcnNlU3RyaW5nRm9ybWF0dGVyID0gZnVuY3Rpb24gcGFyc2VTdHJpbmdGb3JtYXR0ZXIodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBZZWFyTW9udGguRlJPTSk7XG4gIH07XG4gIGZ1bmN0aW9uIFllYXJNb250aCh5ZWFyLCBtb250aCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9UZW1wb3JhbC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3llYXIgPSBNYXRoVXRpbC5zYWZlVG9JbnQoeWVhcik7XG4gICAgX3RoaXMuX21vbnRoID0gTWF0aFV0aWwuc2FmZVRvSW50KG1vbnRoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IFllYXJNb250aC5wcm90b3R5cGU7XG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgZmllbGRPclVuaXQgaW5zdGFuY2VvZiBUZW1wb3JhbEZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZEZpZWxkKGZpZWxkT3JVbml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWRVbml0KGZpZWxkT3JVbml0KTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5pc1N1cHBvcnRlZEZpZWxkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRGaWVsZChmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLllFQVIgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USCB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLkVSQTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkICE9IG51bGwgJiYgZmllbGQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmlzU3VwcG9ydGVkVW5pdCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkVW5pdCh1bml0KSB7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gdW5pdCA9PT0gQ2hyb25vVW5pdC5NT05USFMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5ZRUFSUyB8fCB1bml0ID09PSBDaHJvbm9Vbml0LkRFQ0FERVMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5DRU5UVVJJRVMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5NSUxMRU5OSUEgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5FUkFTO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdCAhPSBudWxsICYmIHVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBKSB7XG4gICAgICByZXR1cm4gdGhpcy55ZWFyKCkgPD0gMCA/IFZhbHVlUmFuZ2Uub2YoMSwgWWVhci5NQVhfVkFMVUUgKyAxKSA6IFZhbHVlUmFuZ2Uub2YoMSwgWWVhci5NQVhfVkFMVUUpO1xuICAgIH1cbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5yYW5nZS5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZmllbGQsIFRlbXBvcmFsRmllbGQsICdmaWVsZCcpO1xuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZpZWxkLCBUZW1wb3JhbEZpZWxkLCAnZmllbGQnKTtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvbGVwdGljTW9udGgoKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5feWVhciA8IDEgPyAxIC0gdGhpcy5feWVhciA6IHRoaXMuX3llYXI7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5feWVhcjtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPCAxID8gMCA6IDE7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX2dldFByb2xlcHRpY01vbnRoID0gZnVuY3Rpb24gX2dldFByb2xlcHRpY01vbnRoKCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl95ZWFyLCAxMiksIHRoaXMuX21vbnRoIC0gMSk7XG4gIH07XG4gIF9wcm90by55ZWFyID0gZnVuY3Rpb24geWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhcjtcbiAgfTtcbiAgX3Byb3RvLm1vbnRoVmFsdWUgPSBmdW5jdGlvbiBtb250aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb250aDtcbiAgfTtcbiAgX3Byb3RvLm1vbnRoID0gZnVuY3Rpb24gbW9udGgoKSB7XG4gICAgcmV0dXJuIE1vbnRoLm9mKHRoaXMuX21vbnRoKTtcbiAgfTtcbiAgX3Byb3RvLmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKCkge1xuICAgIHJldHVybiBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIodGhpcy5feWVhcik7XG4gIH07XG4gIF9wcm90by5pc1ZhbGlkRGF5ID0gZnVuY3Rpb24gaXNWYWxpZERheShkYXlPZk1vbnRoKSB7XG4gICAgcmV0dXJuIGRheU9mTW9udGggPj0gMSAmJiBkYXlPZk1vbnRoIDw9IHRoaXMubGVuZ3RoT2ZNb250aCgpO1xuICB9O1xuICBfcHJvdG8ubGVuZ3RoT2ZNb250aCA9IGZ1bmN0aW9uIGxlbmd0aE9mTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGgoKS5sZW5ndGgodGhpcy5pc0xlYXBZZWFyKCkpO1xuICB9O1xuICBfcHJvdG8ubGVuZ3RoT2ZZZWFyID0gZnVuY3Rpb24gbGVuZ3RoT2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVhcFllYXIoKSA/IDM2NiA6IDM2NTtcbiAgfTtcbiAgX3Byb3RvLndpdGggPSBmdW5jdGlvbiBfd2l0aChhZGp1c3Rlck9yRmllbGQsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoQWRqdXN0ZXIoYWRqdXN0ZXJPckZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhGaWVsZChhZGp1c3Rlck9yRmllbGQsIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5fd2l0aEZpZWxkID0gZnVuY3Rpb24gX3dpdGhGaWVsZChmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZpZWxkLCBUZW1wb3JhbEZpZWxkLCAnZmllbGQnKTtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgdmFyIGYgPSBmaWVsZDtcbiAgICAgIGYuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1vbnRoKG5ld1ZhbHVlKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01vbnRocyhuZXdWYWx1ZSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEgpKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoWWVhcih0aGlzLl95ZWFyIDwgMSA/IDEgLSBuZXdWYWx1ZSA6IG5ld1ZhbHVlKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhZZWFyKG5ld1ZhbHVlKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpID09PSBuZXdWYWx1ZSA/IHRoaXMgOiB0aGlzLndpdGhZZWFyKDEgLSB0aGlzLl95ZWFyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuICBfcHJvdG8ud2l0aFllYXIgPSBmdW5jdGlvbiB3aXRoWWVhcih5ZWFyKSB7XG4gICAgQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkVmFsdWUoeWVhcik7XG4gICAgcmV0dXJuIG5ldyBZZWFyTW9udGgoeWVhciwgdGhpcy5fbW9udGgpO1xuICB9O1xuICBfcHJvdG8ud2l0aE1vbnRoID0gZnVuY3Rpb24gd2l0aE1vbnRoKG1vbnRoKSB7XG4gICAgQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUi5jaGVja1ZhbGlkVmFsdWUobW9udGgpO1xuICAgIHJldHVybiBuZXcgWWVhck1vbnRoKHRoaXMuX3llYXIsIG1vbnRoKTtcbiAgfTtcbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHVuaXQsIFRlbXBvcmFsVW5pdCwgJ3VuaXQnKTtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTU9OVEhTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMoYW1vdW50VG9BZGQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuWUVBUlM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRFQ0FERVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTApKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkNFTlRVUklFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCAxMDApKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExFTk5JQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCAxMDAwKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5FUkFTOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGgoQ2hyb25vRmllbGQuRVJBLCBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpLCBhbW91bnRUb0FkZCkpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgdW5pdDogXCIgKyB1bml0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuICBfcHJvdG8ucGx1c1llYXJzID0gZnVuY3Rpb24gcGx1c1llYXJzKHllYXJzVG9BZGQpIHtcbiAgICBpZiAoeWVhcnNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdZZWFyID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5feWVhciArIHllYXJzVG9BZGQpO1xuICAgIHJldHVybiB0aGlzLndpdGhZZWFyKG5ld1llYXIpO1xuICB9O1xuICBfcHJvdG8ucGx1c01vbnRocyA9IGZ1bmN0aW9uIHBsdXNNb250aHMobW9udGhzVG9BZGQpIHtcbiAgICBpZiAobW9udGhzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbW9udGhDb3VudCA9IHRoaXMuX3llYXIgKiAxMiArICh0aGlzLl9tb250aCAtIDEpO1xuICAgIHZhciBjYWxjTW9udGhzID0gbW9udGhDb3VudCArIG1vbnRoc1RvQWRkO1xuICAgIHZhciBuZXdZZWFyID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoTWF0aFV0aWwuZmxvb3JEaXYoY2FsY01vbnRocywgMTIpKTtcbiAgICB2YXIgbmV3TW9udGggPSBNYXRoVXRpbC5mbG9vck1vZChjYWxjTW9udGhzLCAxMikgKyAxO1xuICAgIHJldHVybiBuZXcgWWVhck1vbnRoKG5ld1llYXIsIG5ld01vbnRoKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzWWVhcnMgPSBmdW5jdGlvbiBtaW51c1llYXJzKHllYXJzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB5ZWFyc1RvU3VidHJhY3QgPT09IE1hdGhVdGlsLk1JTl9TQUZFX0lOVEVHRVIgPyB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSKS5wbHVzWWVhcnMoMSkgOiB0aGlzLnBsdXNZZWFycygteWVhcnNUb1N1YnRyYWN0KTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTW9udGhzID0gZnVuY3Rpb24gbWludXNNb250aHMobW9udGhzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiBtb250aHNUb1N1YnRyYWN0ID09PSBNYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTW9udGhzKE1hdGguTUFYX1NBRkVfSU5URUdFUikucGx1c01vbnRocygxKSA6IHRoaXMucGx1c01vbnRocygtbW9udGhzVG9TdWJ0cmFjdCk7XG4gIH07XG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKF9xdWVyeSwgVGVtcG9yYWxRdWVyeSwgJ3F1ZXJ5Jyk7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTU9OVEhTO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRlbXBvcmFsLCBUZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRILCB0aGlzLl9nZXRQcm9sZXB0aWNNb250aCgpKTtcbiAgfTtcbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZW5kRXhjbHVzaXZlLCAnZW5kRXhjbHVzaXZlJyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZW5kRXhjbHVzaXZlLCBUZW1wb3JhbCwgJ2VuZEV4Y2x1c2l2ZScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh1bml0LCBUZW1wb3JhbFVuaXQsICd1bml0Jyk7XG4gICAgdmFyIGVuZCA9IFllYXJNb250aC5mcm9tKGVuZEV4Y2x1c2l2ZSk7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICB2YXIgbW9udGhzVW50aWwgPSBlbmQuX2dldFByb2xlcHRpY01vbnRoKCkgLSB0aGlzLl9nZXRQcm9sZXB0aWNNb250aCgpO1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NT05USFM6XG4gICAgICAgICAgcmV0dXJuIG1vbnRoc1VudGlsO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuWUVBUlM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihtb250aHNVbnRpbCwgMTIpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuREVDQURFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG1vbnRoc1VudGlsLCAxMjApO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuQ0VOVFVSSUVTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobW9udGhzVW50aWwsIDEyMDApO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTEVOTklBOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobW9udGhzVW50aWwsIDEyMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkVSQVM6XG4gICAgICAgICAgcmV0dXJuIGVuZC5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcbiAgX3Byb3RvLmF0RGF5ID0gZnVuY3Rpb24gYXREYXkoZGF5T2ZNb250aCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mTW9udGgsICdkYXlPZk1vbnRoJyk7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZih0aGlzLl95ZWFyLCB0aGlzLl9tb250aCwgZGF5T2ZNb250aCk7XG4gIH07XG4gIF9wcm90by5hdEVuZE9mTW9udGggPSBmdW5jdGlvbiBhdEVuZE9mTW9udGgoKSB7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZih0aGlzLl95ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5sZW5ndGhPZk1vbnRoKCkpO1xuICB9O1xuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgWWVhck1vbnRoLCAnb3RoZXInKTtcbiAgICB2YXIgY21wID0gdGhpcy5feWVhciAtIG90aGVyLnllYXIoKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICBjbXAgPSB0aGlzLl9tb250aCAtIG90aGVyLm1vbnRoVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNtcDtcbiAgfTtcbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA+IDA7XG4gIH07XG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA8IDA7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBZZWFyTW9udGgpIHtcbiAgICAgIHZhciBvdGhlciA9IG9iajtcbiAgICAgIHJldHVybiB0aGlzLnllYXIoKSA9PT0gb3RoZXIueWVhcigpICYmIHRoaXMubW9udGhWYWx1ZSgpID09PSBvdGhlci5tb250aFZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFBBUlNFUiQxLmZvcm1hdCh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuICByZXR1cm4gWWVhck1vbnRoO1xufShUZW1wb3JhbCk7XG52YXIgUEFSU0VSJDE7XG5mdW5jdGlvbiBfaW5pdCRiKCkge1xuICBQQVJTRVIkMSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiwgMikudG9Gb3JtYXR0ZXIoKTtcbiAgWWVhck1vbnRoLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdZZWFyTW9udGguRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBZZWFyTW9udGguZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgWWVhciA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoWWVhciwgX1RlbXBvcmFsKTtcbiAgZnVuY3Rpb24gWWVhcih2YWx1ZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfdGhpcyA9IF9UZW1wb3JhbC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3llYXIgPSBNYXRoVXRpbC5zYWZlVG9JbnQodmFsdWUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gWWVhci5wcm90b3R5cGU7XG4gIF9wcm90by52YWx1ZSA9IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl95ZWFyO1xuICB9O1xuICBZZWFyLm5vdyA9IGZ1bmN0aW9uIG5vdyh6b25lSWRPckNsb2NrKSB7XG4gICAgaWYgKHpvbmVJZE9yQ2xvY2sgPT09IHZvaWQgMCkge1xuICAgICAgem9uZUlkT3JDbG9jayA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHpvbmVJZE9yQ2xvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFllYXIubm93MCgpO1xuICAgIH0gZWxzZSBpZiAoem9uZUlkT3JDbG9jayBpbnN0YW5jZW9mIFpvbmVJZCkge1xuICAgICAgcmV0dXJuIFllYXIubm93Wm9uZUlkKHpvbmVJZE9yQ2xvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWWVhci5ub3dDbG9jayh6b25lSWRPckNsb2NrKTtcbiAgICB9XG4gIH07XG4gIFllYXIubm93MCA9IGZ1bmN0aW9uIG5vdzAoKSB7XG4gICAgcmV0dXJuIFllYXIubm93Q2xvY2soQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gIH07XG4gIFllYXIubm93Wm9uZUlkID0gZnVuY3Rpb24gbm93Wm9uZUlkKHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh6b25lLCBab25lSWQsICd6b25lJyk7XG4gICAgcmV0dXJuIFllYXIubm93Q2xvY2soQ2xvY2suc3lzdGVtKHpvbmUpKTtcbiAgfTtcbiAgWWVhci5ub3dDbG9jayA9IGZ1bmN0aW9uIG5vd0Nsb2NrKGNsb2NrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoY2xvY2ssICdjbG9jaycpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShjbG9jaywgQ2xvY2ssICdjbG9jaycpO1xuICAgIHZhciBub3cgPSBMb2NhbERhdGUubm93KGNsb2NrKTtcbiAgICByZXR1cm4gWWVhci5vZihub3cueWVhcigpKTtcbiAgfTtcbiAgWWVhci5vZiA9IGZ1bmN0aW9uIG9mKGlzb1llYXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChpc29ZZWFyLCAnaXNvWWVhcicpO1xuICAgIENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZFZhbHVlKGlzb1llYXIpO1xuICAgIHJldHVybiBuZXcgWWVhcihpc29ZZWFyKTtcbiAgfTtcbiAgWWVhci5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodGVtcG9yYWwsIFRlbXBvcmFsQWNjZXNzb3IsICd0ZW1wb3JhbCcpO1xuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFllYXIpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBZZWFyLm9mKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5ZRUFSKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gWWVhciBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbCAmJiB0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuICBZZWFyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIFllYXIucGFyc2VUZXh0KHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWWVhci5wYXJzZVRleHRGb3JtYXR0ZXIodGV4dCwgZm9ybWF0dGVyKTtcbiAgICB9XG4gIH07XG4gIFllYXIucGFyc2VUZXh0ID0gZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuICAgIHJldHVybiBZZWFyLnBhcnNlKHRleHQsIFBBUlNFUik7XG4gIH07XG4gIFllYXIucGFyc2VUZXh0Rm9ybWF0dGVyID0gZnVuY3Rpb24gcGFyc2VUZXh0Rm9ybWF0dGVyKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gUEFSU0VSO1xuICAgIH1cbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmb3JtYXR0ZXIsIERhdGVUaW1lRm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBZZWFyLkZST00pO1xuICB9O1xuICBZZWFyLmlzTGVhcCA9IGZ1bmN0aW9uIGlzTGVhcCh5ZWFyKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmludE1vZCh5ZWFyLCA0KSA9PT0gMCAmJiAoTWF0aFV0aWwuaW50TW9kKHllYXIsIDEwMCkgIT09IDAgfHwgTWF0aFV0aWwuaW50TW9kKHllYXIsIDQwMCkgPT09IDApO1xuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZE9yVW5pdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGZpZWxkT3JVbml0IGluc3RhbmNlb2YgVGVtcG9yYWxGaWVsZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWRGaWVsZChmaWVsZE9yVW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkVW5pdChmaWVsZE9yVW5pdCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWRGaWVsZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkRmllbGQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkID09PSBDaHJvbm9GaWVsZC5ZRUFSIHx8IGZpZWxkID09PSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQSB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuRVJBO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQgIT0gbnVsbCAmJiBmaWVsZC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWRVbml0ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRVbml0KHVuaXQpIHtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiB1bml0ID09PSBDaHJvbm9Vbml0LllFQVJTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuREVDQURFUyB8fCB1bml0ID09PSBDaHJvbm9Vbml0LkNFTlRVUklFUyB8fCB1bml0ID09PSBDaHJvbm9Vbml0Lk1JTExFTk5JQSB8fCB1bml0ID09PSBDaHJvbm9Vbml0LkVSQVM7XG4gICAgfVxuICAgIHJldHVybiB1bml0ICE9IG51bGwgJiYgdW5pdC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKGZpZWxkKSkge1xuICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnJhbmdlLmNhbGwodGhpcywgZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoZmllbGQpLmNoZWNrVmFsaWRJbnRWYWx1ZSh0aGlzLmdldExvbmcoZmllbGQpLCBmaWVsZCk7XG4gIH07XG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBOlxuICAgICAgICAgIHJldHVybiB0aGlzLl95ZWFyIDwgMSA/IDEgLSB0aGlzLl95ZWFyIDogdGhpcy5feWVhcjtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLl95ZWFyO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5feWVhciA8IDEgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5pc0xlYXAgPSBmdW5jdGlvbiBpc0xlYXAoKSB7XG4gICAgcmV0dXJuIFllYXIuaXNMZWFwKHRoaXMuX3llYXIpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmaWVsZCwgVGVtcG9yYWxGaWVsZCwgJ2ZpZWxkJyk7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGZpZWxkLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIFllYXIub2YodGhpcy5feWVhciA8IDEgPyAxIC0gbmV3VmFsdWUgOiBuZXdWYWx1ZSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUjpcbiAgICAgICAgICByZXR1cm4gWWVhci5vZihuZXdWYWx1ZSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuRVJBOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSA9PT0gbmV3VmFsdWUgPyB0aGlzIDogWWVhci5vZigxIC0gdGhpcy5feWVhcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvQWRkLCAnYW1vdW50VG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh1bml0LCBUZW1wb3JhbFVuaXQsICd1bml0Jyk7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LllFQVJTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhhbW91bnRUb0FkZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ERUNBREVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5DRU5UVVJJRVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTAwKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTAwMCkpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuRVJBUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoKENocm9ub0ZpZWxkLkVSQSwgTWF0aFV0aWwuc2FmZUFkZCh0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSwgYW1vdW50VG9BZGQpKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFyc1RvQWRkKSB7XG4gICAgaWYgKHllYXJzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gWWVhci5vZihDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX3llYXIsIHllYXJzVG9BZGQpKSk7XG4gIH07XG4gIF9wcm90by5taW51c1llYXJzID0gZnVuY3Rpb24gbWludXNZZWFycyh5ZWFyc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4geWVhcnNUb1N1YnRyYWN0ID09PSBNYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuTUFYX1NBRkVfSU5URUdFUikucGx1c1llYXJzKDEpIDogdGhpcy5wbHVzWWVhcnMoLXllYXJzVG9TdWJ0cmFjdCk7XG4gIH07XG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5ZRUFSLCB0aGlzLl95ZWFyKTtcbiAgfTtcbiAgX3Byb3RvLmlzVmFsaWRNb250aERheSA9IGZ1bmN0aW9uIGlzVmFsaWRNb250aERheShtb250aERheSkge1xuICAgIHJldHVybiBtb250aERheSAhPSBudWxsICYmIG1vbnRoRGF5LmlzVmFsaWRZZWFyKHRoaXMuX3llYXIpO1xuICB9O1xuICBfcHJvdG8ubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVhcCgpID8gMzY2IDogMzY1O1xuICB9O1xuICBfcHJvdG8uYXREYXkgPSBmdW5jdGlvbiBhdERheShkYXlPZlllYXIpIHtcbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mWWVhckRheSh0aGlzLl95ZWFyLCBkYXlPZlllYXIpO1xuICB9O1xuICBfcHJvdG8uYXRNb250aCA9IGZ1bmN0aW9uIGF0TW9udGgobW9udGhPck51bWJlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIG1vbnRoT3JOdW1iZXIgaW5zdGFuY2VvZiBNb250aCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXRNb250aE1vbnRoKG1vbnRoT3JOdW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5hdE1vbnRoTnVtYmVyKG1vbnRoT3JOdW1iZXIpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmF0TW9udGhNb250aCA9IGZ1bmN0aW9uIGF0TW9udGhNb250aChtb250aCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoLCAnbW9udGgnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UobW9udGgsIE1vbnRoLCAnbW9udGgnKTtcbiAgICByZXR1cm4gWWVhck1vbnRoLm9mKHRoaXMuX3llYXIsIG1vbnRoKTtcbiAgfTtcbiAgX3Byb3RvLmF0TW9udGhOdW1iZXIgPSBmdW5jdGlvbiBhdE1vbnRoTnVtYmVyKG1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuICAgIHJldHVybiBZZWFyTW9udGgub2YodGhpcy5feWVhciwgbW9udGgpO1xuICB9O1xuICBfcHJvdG8uYXRNb250aERheSA9IGZ1bmN0aW9uIGF0TW9udGhEYXkobW9udGhEYXkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aERheSwgJ21vbnRoRGF5Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG1vbnRoRGF5LCBNb250aERheSwgJ21vbnRoRGF5Jyk7XG4gICAgcmV0dXJuIG1vbnRoRGF5LmF0WWVhcih0aGlzLl95ZWFyKTtcbiAgfTtcbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnkoKScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShfcXVlcnksIFRlbXBvcmFsUXVlcnksICdxdWVyeSgpJyk7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuWUVBUlM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIF9xdWVyeSk7XG4gIH07XG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBZZWFyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5feWVhciAtIG90aGVyLl95ZWFyO1xuICB9O1xuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBZZWFyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5feWVhciA+IG90aGVyLl95ZWFyO1xuICB9O1xuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIFllYXIsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl95ZWFyIDwgb3RoZXIuX3llYXI7XG4gIH07XG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZvcm1hdHRlciwgRGF0ZVRpbWVGb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFllYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlKCkgPT09IG90aGVyLnZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiXCIgKyB0aGlzLl95ZWFyO1xuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHZhciBlbmQgPSBZZWFyLmZyb20oZW5kRXhjbHVzaXZlKTtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHZhciB5ZWFyc1VudGlsID0gZW5kLnZhbHVlKCkgLSB0aGlzLnZhbHVlKCk7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LllFQVJTOlxuICAgICAgICAgIHJldHVybiB5ZWFyc1VudGlsO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuREVDQURFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHllYXJzVW50aWwsIDEwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkNFTlRVUklFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHllYXJzVW50aWwsIDEwMCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih5ZWFyc1VudGlsLCAxMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkVSQVM6XG4gICAgICAgICAgcmV0dXJuIGVuZC5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcbiAgcmV0dXJuIFllYXI7XG59KFRlbXBvcmFsKTtcbnZhciBQQVJTRVI7XG5mdW5jdGlvbiBfaW5pdCRhKCkge1xuICBZZWFyLk1JTl9WQUxVRSA9IFllYXJDb25zdGFudHMuTUlOX1ZBTFVFO1xuICBZZWFyLk1BWF9WQUxVRSA9IFllYXJDb25zdGFudHMuTUFYX1ZBTFVFO1xuICBQQVJTRVIgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuWUVBUiwgNCwgMTAsIFNpZ25TdHlsZS5FWENFRURTX1BBRCkudG9Gb3JtYXR0ZXIoKTtcbiAgWWVhci5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnWWVhci5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIFllYXIuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxudmFyIFRlbXBvcmFsQWRqdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRlbXBvcmFsQWRqdXN0ZXIoKSB7fVxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxBZGp1c3Rlci5wcm90b3R5cGU7XG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnYWRqdXN0SW50bycpO1xuICB9O1xuICByZXR1cm4gVGVtcG9yYWxBZGp1c3Rlcjtcbn0oKTtcblxudmFyIFRlbXBvcmFsQWRqdXN0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEFkanVzdGVycygpIHt9XG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmZpcnN0RGF5T2ZNb250aCA9IGZ1bmN0aW9uIGZpcnN0RGF5T2ZNb250aCgpIHtcbiAgICByZXR1cm4gSW1wbC5GSVJTVF9EQVlfT0ZfTU9OVEg7XG4gIH07XG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmxhc3REYXlPZk1vbnRoID0gZnVuY3Rpb24gbGFzdERheU9mTW9udGgoKSB7XG4gICAgcmV0dXJuIEltcGwuTEFTVF9EQVlfT0ZfTU9OVEg7XG4gIH07XG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmZpcnN0RGF5T2ZOZXh0TW9udGggPSBmdW5jdGlvbiBmaXJzdERheU9mTmV4dE1vbnRoKCkge1xuICAgIHJldHVybiBJbXBsLkZJUlNUX0RBWV9PRl9ORVhUX01PTlRIO1xuICB9O1xuICBUZW1wb3JhbEFkanVzdGVycy5maXJzdERheU9mWWVhciA9IGZ1bmN0aW9uIGZpcnN0RGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiBJbXBsLkZJUlNUX0RBWV9PRl9ZRUFSO1xuICB9O1xuICBUZW1wb3JhbEFkanVzdGVycy5sYXN0RGF5T2ZZZWFyID0gZnVuY3Rpb24gbGFzdERheU9mWWVhcigpIHtcbiAgICByZXR1cm4gSW1wbC5MQVNUX0RBWV9PRl9ZRUFSO1xuICB9O1xuICBUZW1wb3JhbEFkanVzdGVycy5maXJzdERheU9mTmV4dFllYXIgPSBmdW5jdGlvbiBmaXJzdERheU9mTmV4dFllYXIoKSB7XG4gICAgcmV0dXJuIEltcGwuRklSU1RfREFZX09GX05FWFRfWUVBUjtcbiAgfTtcbiAgVGVtcG9yYWxBZGp1c3RlcnMuZmlyc3RJbk1vbnRoID0gZnVuY3Rpb24gZmlyc3RJbk1vbnRoKGRheU9mV2Vlaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mV2VlaywgJ2RheU9mV2VlaycpO1xuICAgIHJldHVybiBuZXcgRGF5T2ZXZWVrSW5Nb250aCgxLCBkYXlPZldlZWspO1xuICB9O1xuICBUZW1wb3JhbEFkanVzdGVycy5sYXN0SW5Nb250aCA9IGZ1bmN0aW9uIGxhc3RJbk1vbnRoKGRheU9mV2Vlaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mV2VlaywgJ2RheU9mV2VlaycpO1xuICAgIHJldHVybiBuZXcgRGF5T2ZXZWVrSW5Nb250aCgtMSwgZGF5T2ZXZWVrKTtcbiAgfTtcbiAgVGVtcG9yYWxBZGp1c3RlcnMuZGF5T2ZXZWVrSW5Nb250aCA9IGZ1bmN0aW9uIGRheU9mV2Vla0luTW9udGgob3JkaW5hbCwgZGF5T2ZXZWVrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZXZWVrLCAnZGF5T2ZXZWVrJyk7XG4gICAgcmV0dXJuIG5ldyBEYXlPZldlZWtJbk1vbnRoKG9yZGluYWwsIGRheU9mV2Vlayk7XG4gIH07XG4gIFRlbXBvcmFsQWRqdXN0ZXJzLm5leHQgPSBmdW5jdGlvbiBuZXh0KGRheU9mV2Vlaykge1xuICAgIHJldHVybiBuZXcgUmVsYXRpdmVEYXlPZldlZWsoMiwgZGF5T2ZXZWVrKTtcbiAgfTtcbiAgVGVtcG9yYWxBZGp1c3RlcnMubmV4dE9yU2FtZSA9IGZ1bmN0aW9uIG5leHRPclNhbWUoZGF5T2ZXZWVrKSB7XG4gICAgcmV0dXJuIG5ldyBSZWxhdGl2ZURheU9mV2VlaygwLCBkYXlPZldlZWspO1xuICB9O1xuICBUZW1wb3JhbEFkanVzdGVycy5wcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKGRheU9mV2Vlaykge1xuICAgIHJldHVybiBuZXcgUmVsYXRpdmVEYXlPZldlZWsoMywgZGF5T2ZXZWVrKTtcbiAgfTtcbiAgVGVtcG9yYWxBZGp1c3RlcnMucHJldmlvdXNPclNhbWUgPSBmdW5jdGlvbiBwcmV2aW91c09yU2FtZShkYXlPZldlZWspIHtcbiAgICByZXR1cm4gbmV3IFJlbGF0aXZlRGF5T2ZXZWVrKDEsIGRheU9mV2Vlayk7XG4gIH07XG4gIHJldHVybiBUZW1wb3JhbEFkanVzdGVycztcbn0oKTtcbnZhciBJbXBsID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFkanVzdGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEltcGwsIF9UZW1wb3JhbEFkanVzdGVyKTtcbiAgZnVuY3Rpb24gSW1wbChvcmRpbmFsKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX1RlbXBvcmFsQWRqdXN0ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9vcmRpbmFsID0gb3JkaW5hbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IEltcGwucHJvdG90eXBlO1xuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29yZGluYWwpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCAxKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCB0ZW1wb3JhbC5yYW5nZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpLm1heGltdW0oKSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCwgMSkucGx1cygxLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSLCAxKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1lFQVIsIHRlbXBvcmFsLnJhbmdlKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKS5tYXhpbXVtKCkpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiwgMSkucGx1cygxLCBDaHJvbm9Vbml0LllFQVJTKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignVW5yZWFjaGFibGUnKTtcbiAgfTtcbiAgcmV0dXJuIEltcGw7XG59KFRlbXBvcmFsQWRqdXN0ZXIpO1xuSW1wbC5GSVJTVF9EQVlfT0ZfTU9OVEggPSBuZXcgSW1wbCgwKTtcbkltcGwuTEFTVF9EQVlfT0ZfTU9OVEggPSBuZXcgSW1wbCgxKTtcbkltcGwuRklSU1RfREFZX09GX05FWFRfTU9OVEggPSBuZXcgSW1wbCgyKTtcbkltcGwuRklSU1RfREFZX09GX1lFQVIgPSBuZXcgSW1wbCgzKTtcbkltcGwuTEFTVF9EQVlfT0ZfWUVBUiA9IG5ldyBJbXBsKDQpO1xuSW1wbC5GSVJTVF9EQVlfT0ZfTkVYVF9ZRUFSID0gbmV3IEltcGwoNSk7XG52YXIgRGF5T2ZXZWVrSW5Nb250aCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBZGp1c3RlcjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRGF5T2ZXZWVrSW5Nb250aCwgX1RlbXBvcmFsQWRqdXN0ZXIyKTtcbiAgZnVuY3Rpb24gRGF5T2ZXZWVrSW5Nb250aChvcmRpbmFsLCBkb3cpIHtcbiAgICB2YXIgX3RoaXMyO1xuICAgIF90aGlzMiA9IF9UZW1wb3JhbEFkanVzdGVyMi5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMyLl9vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBfdGhpczIuX2Rvd1ZhbHVlID0gZG93LnZhbHVlKCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICB2YXIgX3Byb3RvMiA9IERheU9mV2Vla0luTW9udGgucHJvdG90eXBlO1xuICBfcHJvdG8yLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRoaXMuX29yZGluYWwgPj0gMCkge1xuICAgICAgdmFyIHRlbXAgPSB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCwgMSk7XG4gICAgICB2YXIgY3VyRG93ID0gdGVtcC5nZXQoQ2hyb25vRmllbGQuREFZX09GX1dFRUspO1xuICAgICAgdmFyIGRvd0RpZmYgPSBNYXRoVXRpbC5pbnRNb2QodGhpcy5fZG93VmFsdWUgLSBjdXJEb3cgKyA3LCA3KTtcbiAgICAgIGRvd0RpZmYgKz0gKHRoaXMuX29yZGluYWwgLSAxKSAqIDc7XG4gICAgICByZXR1cm4gdGVtcC5wbHVzKGRvd0RpZmYsIENocm9ub1VuaXQuREFZUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfdGVtcCA9IHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCB0ZW1wb3JhbC5yYW5nZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpLm1heGltdW0oKSk7XG4gICAgICB2YXIgX2N1ckRvdyA9IF90ZW1wLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG4gICAgICB2YXIgZGF5c0RpZmYgPSB0aGlzLl9kb3dWYWx1ZSAtIF9jdXJEb3c7XG4gICAgICBkYXlzRGlmZiA9IGRheXNEaWZmID09PSAwID8gMCA6IGRheXNEaWZmID4gMCA/IGRheXNEaWZmIC0gNyA6IGRheXNEaWZmO1xuICAgICAgZGF5c0RpZmYgLT0gKC10aGlzLl9vcmRpbmFsIC0gMSkgKiA3O1xuICAgICAgcmV0dXJuIF90ZW1wLnBsdXMoZGF5c0RpZmYsIENocm9ub1VuaXQuREFZUyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gRGF5T2ZXZWVrSW5Nb250aDtcbn0oVGVtcG9yYWxBZGp1c3Rlcik7XG52YXIgUmVsYXRpdmVEYXlPZldlZWsgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQWRqdXN0ZXIzKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlbGF0aXZlRGF5T2ZXZWVrLCBfVGVtcG9yYWxBZGp1c3RlcjMpO1xuICBmdW5jdGlvbiBSZWxhdGl2ZURheU9mV2VlayhyZWxhdGl2ZSwgZGF5T2ZXZWVrKSB7XG4gICAgdmFyIF90aGlzMztcbiAgICBfdGhpczMgPSBfVGVtcG9yYWxBZGp1c3RlcjMuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mV2VlaywgJ2RheU9mV2VlaycpO1xuICAgIF90aGlzMy5fcmVsYXRpdmUgPSByZWxhdGl2ZTtcbiAgICBfdGhpczMuX2Rvd1ZhbHVlID0gZGF5T2ZXZWVrLnZhbHVlKCk7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuICB2YXIgX3Byb3RvMyA9IFJlbGF0aXZlRGF5T2ZXZWVrLnByb3RvdHlwZTtcbiAgX3Byb3RvMy5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHZhciBjYWxEb3cgPSB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuREFZX09GX1dFRUspO1xuICAgIGlmICh0aGlzLl9yZWxhdGl2ZSA8IDIgJiYgY2FsRG93ID09PSB0aGlzLl9kb3dWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH1cbiAgICBpZiAoKHRoaXMuX3JlbGF0aXZlICYgMSkgPT09IDApIHtcbiAgICAgIHZhciBkYXlzRGlmZiA9IGNhbERvdyAtIHRoaXMuX2Rvd1ZhbHVlO1xuICAgICAgcmV0dXJuIHRlbXBvcmFsLnBsdXMoZGF5c0RpZmYgPj0gMCA/IDcgLSBkYXlzRGlmZiA6IC1kYXlzRGlmZiwgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kYXlzRGlmZiA9IHRoaXMuX2Rvd1ZhbHVlIC0gY2FsRG93O1xuICAgICAgcmV0dXJuIHRlbXBvcmFsLm1pbnVzKF9kYXlzRGlmZiA+PSAwID8gNyAtIF9kYXlzRGlmZiA6IC1fZGF5c0RpZmYsIENocm9ub1VuaXQuREFZUyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gUmVsYXRpdmVEYXlPZldlZWs7XG59KFRlbXBvcmFsQWRqdXN0ZXIpO1xuXG52YXIgSXNvQ2hyb25vbG9neSA9IGZ1bmN0aW9uIChfRW51bSkge1xuICBfaW5oZXJpdHNMb29zZShJc29DaHJvbm9sb2d5LCBfRW51bSk7XG4gIGZ1bmN0aW9uIElzb0Nocm9ub2xvZ3koKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKHByb2xlcHRpY1llYXIpIHtcbiAgICByZXR1cm4gKHByb2xlcHRpY1llYXIgJiAzKSA9PT0gMCAmJiAocHJvbGVwdGljWWVhciAlIDEwMCAhPT0gMCB8fCBwcm9sZXB0aWNZZWFyICUgNDAwID09PSAwKTtcbiAgfTtcbiAgdmFyIF9wcm90byA9IElzb0Nocm9ub2xvZ3kucHJvdG90eXBlO1xuICBfcHJvdG8uX3VwZGF0ZVJlc29sdmVNYXAgPSBmdW5jdGlvbiBfdXBkYXRlUmVzb2x2ZU1hcChmaWVsZFZhbHVlcywgZmllbGQsIHZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGRWYWx1ZXMsICdmaWVsZFZhbHVlcycpO1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICB2YXIgY3VycmVudCA9IGZpZWxkVmFsdWVzLmdldChmaWVsZCk7XG4gICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCBzdGF0ZSwgZmllbGQ6IFwiICsgZmllbGQgKyBcIiBcIiArIGN1cnJlbnQgKyBcIiBjb25mbGljdHMgd2l0aCBcIiArIGZpZWxkICsgXCIgXCIgKyB2YWx1ZSk7XG4gICAgfVxuICAgIGZpZWxkVmFsdWVzLnB1dChmaWVsZCwgdmFsdWUpO1xuICB9O1xuICBfcHJvdG8ucmVzb2x2ZURhdGUgPSBmdW5jdGlvbiByZXNvbHZlRGF0ZShmaWVsZFZhbHVlcywgcmVzb2x2ZXJTdHlsZSkge1xuICAgIGlmIChmaWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5FUE9DSF9EQVkpKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlLm9mRXBvY2hEYXkoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkVQT0NIX0RBWSkpO1xuICAgIH1cbiAgICB2YXIgcHJvbGVwdGljTW9udGggPSBmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIKTtcbiAgICBpZiAocHJvbGVwdGljTW9udGggIT0gbnVsbCkge1xuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEguY2hlY2tWYWxpZFZhbHVlKHByb2xlcHRpY01vbnRoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIE1hdGhVdGlsLmZsb29yTW9kKHByb2xlcHRpY01vbnRoLCAxMikgKyAxKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIENocm9ub0ZpZWxkLllFQVIsIE1hdGhVdGlsLmZsb29yRGl2KHByb2xlcHRpY01vbnRoLCAxMikpO1xuICAgIH1cbiAgICB2YXIgeW9lTG9uZyA9IGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQSk7XG4gICAgaWYgKHlvZUxvbmcgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQS5jaGVja1ZhbGlkVmFsdWUoeW9lTG9uZyk7XG4gICAgICB9XG4gICAgICB2YXIgZXJhID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkVSQSk7XG4gICAgICBpZiAoZXJhID09IG51bGwpIHtcbiAgICAgICAgdmFyIHllYXIgPSBmaWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuWUVBUik7XG4gICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNUUklDVCkge1xuICAgICAgICAgIGlmICh5ZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIENocm9ub0ZpZWxkLllFQVIsIHllYXIgPiAwID8geW9lTG9uZyA6IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdCgxLCB5b2VMb25nKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWVzLnB1dChDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQSwgeW9lTG9uZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIENocm9ub0ZpZWxkLllFQVIsIHllYXIgPT0gbnVsbCB8fCB5ZWFyID4gMCA/IHlvZUxvbmcgOiBNYXRoVXRpbC5zYWZlU3VidHJhY3QoMSwgeW9lTG9uZykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVyYSA9PT0gMSkge1xuICAgICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5ZRUFSLCB5b2VMb25nKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJhID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIENocm9ub0ZpZWxkLllFQVIsIE1hdGhVdGlsLnNhZmVTdWJ0cmFjdCgxLCB5b2VMb25nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbnZhbGlkIHZhbHVlIGZvciBlcmE6IFwiICsgZXJhKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkVSQSkpIHtcbiAgICAgIENocm9ub0ZpZWxkLkVSQS5jaGVja1ZhbGlkVmFsdWUoZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLkVSQSkpO1xuICAgIH1cbiAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuWUVBUikpIHtcbiAgICAgIGlmIChmaWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSkge1xuICAgICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKSkge1xuICAgICAgICAgIHZhciB5ID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLllFQVIpKTtcbiAgICAgICAgICB2YXIgbW95ID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpO1xuICAgICAgICAgIHZhciBkb20gPSBmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKTtcbiAgICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgICAgICB2YXIgbW9udGhzID0gbW95IC0gMTtcbiAgICAgICAgICAgIHZhciBkYXlzID0gZG9tIC0gMTtcbiAgICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2YoeSwgMSwgMSkucGx1c01vbnRocyhtb250aHMpLnBsdXNEYXlzKGRheXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TTUFSVCkge1xuICAgICAgICAgICAgQ2hyb25vRmllbGQuREFZX09GX01PTlRILmNoZWNrVmFsaWRWYWx1ZShkb20pO1xuICAgICAgICAgICAgaWYgKG1veSA9PT0gNCB8fCBtb3kgPT09IDYgfHwgbW95ID09PSA5IHx8IG1veSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgZG9tID0gTWF0aC5taW4oZG9tLCAzMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1veSA9PT0gMikge1xuICAgICAgICAgICAgICBkb20gPSBNYXRoLm1pbihkb20sIE1vbnRoLkZFQlJVQVJZLmxlbmd0aChZZWFyLmlzTGVhcCh5KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZih5LCBtb3ksIGRvbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2YoeSwgbW95LCBkb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKSkge1xuICAgICAgICB2YXIgX3kgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuWUVBUikpO1xuICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgICAgdmFyIF9kYXlzID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiksIDEpO1xuICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2ZZZWFyRGF5KF95LCAxKS5wbHVzRGF5cyhfZGF5cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRveSA9IENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpKTtcbiAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZlllYXJEYXkoX3ksIGRveSk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpKSB7XG4gICAgICAgIGlmIChmaWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX1lFQVIpKSB7XG4gICAgICAgICAgdmFyIF95MiA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5ZRUFSKSk7XG4gICAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICAgICAgdmFyIHdlZWtzID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUiksIDEpO1xuICAgICAgICAgICAgdmFyIF9kYXlzMiA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gTG9jYWxEYXRlLm9mKF95MiwgMSwgMSkucGx1c1dlZWtzKHdlZWtzKS5wbHVzRGF5cyhfZGF5czIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXcgPSBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSKSk7XG4gICAgICAgICAgdmFyIGFkID0gQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSKSk7XG4gICAgICAgICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2YoX3kyLCAxLCAxKS5wbHVzRGF5cygoYXcgLSAxKSAqIDcgKyAoYWQgLSAxKSk7XG4gICAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU1RSSUNUICYmIGRhdGUuZ2V0KENocm9ub0ZpZWxkLllFQVIpICE9PSBfeTIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignU3RyaWN0IG1vZGUgcmVqZWN0ZWQgZGF0ZSBwYXJzZWQgdG8gYSBkaWZmZXJlbnQgeWVhcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuREFZX09GX1dFRUspKSB7XG4gICAgICAgICAgdmFyIF95MyA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5ZRUFSKSk7XG4gICAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICAgICAgdmFyIF93ZWVrcyA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpLCAxKTtcbiAgICAgICAgICAgIHZhciBfZGF5czMgPSBNYXRoVXRpbC5zYWZlU3VidHJhY3QoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gTG9jYWxEYXRlLm9mKF95MywgMSwgMSkucGx1c1dlZWtzKF93ZWVrcykucGx1c0RheXMoX2RheXMzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9hdyA9IENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpKTtcbiAgICAgICAgICB2YXIgZG93ID0gQ2hyb25vRmllbGQuREFZX09GX1dFRUsuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSykpO1xuICAgICAgICAgIHZhciBfZGF0ZSA9IExvY2FsRGF0ZS5vZihfeTMsIDEsIDEpLnBsdXNXZWVrcyhfYXcgLSAxKS53aXRoKFRlbXBvcmFsQWRqdXN0ZXJzLm5leHRPclNhbWUoRGF5T2ZXZWVrLm9mKGRvdykpKTtcbiAgICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TVFJJQ1QgJiYgX2RhdGUuZ2V0KENocm9ub0ZpZWxkLllFQVIpICE9PSBfeTMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignU3RyaWN0IG1vZGUgcmVqZWN0ZWQgZGF0ZSBwYXJzZWQgdG8gYSBkaWZmZXJlbnQgbW9udGgnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9kYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBfcHJvdG8uZGF0ZSA9IGZ1bmN0aW9uIGRhdGUodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gTG9jYWxEYXRlLmZyb20odGVtcG9yYWwpO1xuICB9O1xuICByZXR1cm4gSXNvQ2hyb25vbG9neTtcbn0oRW51bSk7XG5mdW5jdGlvbiBfaW5pdCQ5KCkge1xuICBJc29DaHJvbm9sb2d5LklOU1RBTkNFID0gbmV3IElzb0Nocm9ub2xvZ3koJ0lzb0Nocm9ub2xvZ3knKTtcbn1cblxudmFyIE9mZnNldFRpbWUgPSBmdW5jdGlvbiAoX1RlbXBvcmFsKSB7XG4gIF9pbmhlcml0c0xvb3NlKE9mZnNldFRpbWUsIF9UZW1wb3JhbCk7XG4gIE9mZnNldFRpbWUuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgT2Zmc2V0VGltZSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH0gZWxzZSBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBPZmZzZXREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsLnRvT2Zmc2V0VGltZSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFyIHRpbWUgPSBMb2NhbFRpbWUuZnJvbSh0ZW1wb3JhbCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gWm9uZU9mZnNldC5mcm9tKHRlbXBvcmFsKTtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2V0VGltZSh0aW1lLCBvZmZzZXQpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJVbmFibGUgdG8gb2J0YWluIE9mZnNldFRpbWUgVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiLCB0eXBlIFwiICsgKHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG4gIH07XG4gIE9mZnNldFRpbWUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBPZmZzZXRUaW1lLl9ub3coQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gICAgfSBlbHNlIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIENsb2NrKSB7XG4gICAgICByZXR1cm4gT2Zmc2V0VGltZS5fbm93KGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9mZnNldFRpbWUuX25vdyhDbG9jay5zeXN0ZW0oY2xvY2tPclpvbmUpKTtcbiAgICB9XG4gIH07XG4gIE9mZnNldFRpbWUuX25vdyA9IGZ1bmN0aW9uIF9ub3coY2xvY2spIHtcbiAgICByZXF1aXJlTm9uTnVsbChjbG9jaywgJ2Nsb2NrJyk7XG4gICAgdmFyIG5vdyA9IGNsb2NrLmluc3RhbnQoKTtcbiAgICByZXR1cm4gT2Zmc2V0VGltZS5vZkluc3RhbnQobm93LCBjbG9jay56b25lKCkucnVsZXMoKS5vZmZzZXQobm93KSk7XG4gIH07XG4gIE9mZnNldFRpbWUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gT2Zmc2V0VGltZS5vZlRpbWVBbmRPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9mZnNldFRpbWUub2ZOdW1iZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICBPZmZzZXRUaW1lLm9mTnVtYmVycyA9IGZ1bmN0aW9uIG9mTnVtYmVycyhob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kLCBvZmZzZXQpIHtcbiAgICB2YXIgdGltZSA9IExvY2FsVGltZS5vZihob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gbmV3IE9mZnNldFRpbWUodGltZSwgb2Zmc2V0KTtcbiAgfTtcbiAgT2Zmc2V0VGltZS5vZlRpbWVBbmRPZmZzZXQgPSBmdW5jdGlvbiBvZlRpbWVBbmRPZmZzZXQodGltZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCk7XG4gIH07XG4gIE9mZnNldFRpbWUub2ZJbnN0YW50ID0gZnVuY3Rpb24gb2ZJbnN0YW50KGluc3RhbnQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShpbnN0YW50LCBJbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHpvbmUsIFpvbmVJZCwgJ3pvbmUnKTtcbiAgICB2YXIgcnVsZXMgPSB6b25lLnJ1bGVzKCk7XG4gICAgdmFyIG9mZnNldCA9IHJ1bGVzLm9mZnNldChpbnN0YW50KTtcbiAgICB2YXIgc2Vjc09mRGF5ID0gaW5zdGFudC5lcG9jaFNlY29uZCgpICUgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWTtcbiAgICBzZWNzT2ZEYXkgPSAoc2Vjc09mRGF5ICsgb2Zmc2V0LnRvdGFsU2Vjb25kcygpKSAlIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVk7XG4gICAgaWYgKHNlY3NPZkRheSA8IDApIHtcbiAgICAgIHNlY3NPZkRheSArPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZO1xuICAgIH1cbiAgICB2YXIgdGltZSA9IExvY2FsVGltZS5vZlNlY29uZE9mRGF5KHNlY3NPZkRheSwgaW5zdGFudC5uYW5vKCkpO1xuICAgIHJldHVybiBuZXcgT2Zmc2V0VGltZSh0aW1lLCBvZmZzZXQpO1xuICB9O1xuICBPZmZzZXRUaW1lLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGZvcm1hdHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBEYXRlVGltZUZvcm1hdHRlci5JU09fT0ZGU0VUX1RJTUU7XG4gICAgfVxuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgT2Zmc2V0VGltZS5GUk9NKTtcbiAgfTtcbiAgZnVuY3Rpb24gT2Zmc2V0VGltZSh0aW1lLCBvZmZzZXQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfVGVtcG9yYWwuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHJlcXVpcmVOb25OdWxsKHRpbWUsICd0aW1lJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRpbWUsIExvY2FsVGltZSwgJ3RpbWUnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob2Zmc2V0LCBab25lT2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgX3RoaXMuX3RpbWUgPSB0aW1lO1xuICAgIF90aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBPZmZzZXRUaW1lLnByb3RvdHlwZTtcbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuTkFOT19PRl9EQVksIHRoaXMuX3RpbWUudG9OYW5vT2ZEYXkoKSkud2l0aChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKSk7XG4gIH07XG4gIF9wcm90by5hdERhdGUgPSBmdW5jdGlvbiBhdERhdGUoZGF0ZSkge1xuICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZihkYXRlLCB0aGlzLl90aW1lLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMsIE9mZnNldFRpbWUuRlJPTSk7XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGltZS5nZXRMb25nKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5ob3VyID0gZnVuY3Rpb24gaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS5ob3VyKCk7XG4gIH07XG4gIF9wcm90by5taW51dGUgPSBmdW5jdGlvbiBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUubWludXRlKCk7XG4gIH07XG4gIF9wcm90by5zZWNvbmQgPSBmdW5jdGlvbiBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUuc2Vjb25kKCk7XG4gIH07XG4gIF9wcm90by5uYW5vID0gZnVuY3Rpb24gbmFubygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS5uYW5vKCk7XG4gIH07XG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl90b0Vwb2NoTmFubygpID4gb3RoZXIuX3RvRXBvY2hOYW5vKCk7XG4gIH07XG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl90b0Vwb2NoTmFubygpIDwgb3RoZXIuX3RvRXBvY2hOYW5vKCk7XG4gIH07XG4gIF9wcm90by5pc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbChvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5fdG9FcG9jaE5hbm8oKSA9PT0gb3RoZXIuX3RvRXBvY2hOYW5vKCk7XG4gIH07XG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpIHx8IGZpZWxkT3JVbml0ID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUztcbiAgICB9IGVsc2UgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUubWludXNIb3Vycyhob3VycyksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5taW51c01pbnV0ZXMgPSBmdW5jdGlvbiBtaW51c01pbnV0ZXMobWludXRlcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUubWludXNNaW51dGVzKG1pbnV0ZXMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNTZWNvbmRzID0gZnVuY3Rpb24gbWludXNTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLm1pbnVzU2Vjb25kcyhzZWNvbmRzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5taW51c05hbm9zKG5hbm9zKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLl9taW51c0Ftb3VudCA9IGZ1bmN0aW9uIF9taW51c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQpO1xuICAgIHJldHVybiBhbW91bnQuc3VidHJhY3RGcm9tKHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXMoLTEgKiBhbW91bnRUb1N1YnRyYWN0LCB1bml0KTtcbiAgfTtcbiAgX3Byb3RvLl9wbHVzQW1vdW50ID0gZnVuY3Rpb24gX3BsdXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50KTtcbiAgICByZXR1cm4gYW1vdW50LmFkZFRvKHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX3BsdXNVbml0ID0gZnVuY3Rpb24gX3BsdXNVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLnBsdXMoYW1vdW50VG9BZGQsIHVuaXQpLCB0aGlzLl9vZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG4gIF9wcm90by5wbHVzSG91cnMgPSBmdW5jdGlvbiBwbHVzSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLnBsdXNIb3Vycyhob3VycyksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5wbHVzTWludXRlcyA9IGZ1bmN0aW9uIHBsdXNNaW51dGVzKG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLnBsdXNNaW51dGVzKG1pbnV0ZXMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5wbHVzU2Vjb25kcyhzZWNvbmRzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNOYW5vcyA9IGZ1bmN0aW9uIHBsdXNOYW5vcyhuYW5vcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUucGx1c05hbm9zKG5hbm9zKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk5BTk9TO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykge1xuICAgICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90aW1lLnJhbmdlKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8udG9Mb2NhbFRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgfTtcbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUudHJ1bmNhdGVkVG8odW5pdCksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZEV4Y2x1c2l2ZSwgJ2VuZEV4Y2x1c2l2ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgdmFyIGVuZCA9IE9mZnNldFRpbWUuZnJvbShlbmRFeGNsdXNpdmUpO1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgdmFyIG5hbm9zVW50aWwgPSBlbmQuX3RvRXBvY2hOYW5vKCkgLSB0aGlzLl90b0Vwb2NoTmFubygpO1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5OQU5PUzpcbiAgICAgICAgICByZXR1cm4gbmFub3NVbnRpbDtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG5hbm9zVW50aWwsIDEwMDApO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgMTAwMDAwMCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG5hbm9zVW50aWwsIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhPVVJTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhBTEZfREFZUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG5hbm9zVW50aWwsIDEyICogTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcbiAgX3Byb3RvLndpdGhIb3VyID0gZnVuY3Rpb24gd2l0aEhvdXIoaG91cikge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUud2l0aEhvdXIoaG91ciksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by53aXRoTWludXRlID0gZnVuY3Rpb24gd2l0aE1pbnV0ZShtaW51dGUpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLndpdGhNaW51dGUobWludXRlKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLndpdGhTZWNvbmQgPSBmdW5jdGlvbiB3aXRoU2Vjb25kKHNlY29uZCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUud2l0aFNlY29uZChzZWNvbmQpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ud2l0aE5hbm8gPSBmdW5jdGlvbiB3aXRoTmFubyhuYW5vKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS53aXRoTmFubyhuYW5vKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLndpdGhPZmZzZXRTYW1lSW5zdGFudCA9IGZ1bmN0aW9uIHdpdGhPZmZzZXRTYW1lSW5zdGFudChvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICBpZiAob2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGRpZmZlcmVuY2UgPSBvZmZzZXQudG90YWxTZWNvbmRzKCkgLSB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCk7XG4gICAgdmFyIGFkanVzdGVkID0gdGhpcy5fdGltZS5wbHVzU2Vjb25kcyhkaWZmZXJlbmNlKTtcbiAgICByZXR1cm4gbmV3IE9mZnNldFRpbWUoYWRqdXN0ZWQsIG9mZnNldCk7XG4gIH07XG4gIF9wcm90by53aXRoT2Zmc2V0U2FtZUxvY2FsID0gZnVuY3Rpb24gd2l0aE9mZnNldFNhbWVMb2NhbChvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ICE9IG51bGwgJiYgb2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpID8gdGhpcyA6IG5ldyBPZmZzZXRUaW1lKHRoaXMuX3RpbWUsIG9mZnNldCk7XG4gIH07XG4gIF9wcm90by5fdG9FcG9jaE5hbm8gPSBmdW5jdGlvbiBfdG9FcG9jaE5hbm8oKSB7XG4gICAgdmFyIG5vZCA9IHRoaXMuX3RpbWUudG9OYW5vT2ZEYXkoKTtcbiAgICB2YXIgb2Zmc2V0TmFub3MgPSB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCkgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORDtcbiAgICByZXR1cm4gbm9kIC0gb2Zmc2V0TmFub3M7XG4gIH07XG4gIF9wcm90by5fd2l0aEFkanVzdGVyID0gZnVuY3Rpb24gX3dpdGhBZGp1c3RlcihhZGp1c3Rlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGFkanVzdGVyLCAnYWRqdXN0ZXInKTtcbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KGFkanVzdGVyLCB0aGlzLl9vZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBab25lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLCBhZGp1c3Rlcik7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIE9mZnNldFRpbWUpIHtcbiAgICAgIHJldHVybiBhZGp1c3RlcjtcbiAgICB9XG4gICAgcmV0dXJuIGFkanVzdGVyLmFkanVzdEludG8odGhpcyk7XG4gIH07XG4gIF9wcm90by5fd2l0aEZpZWxkID0gZnVuY3Rpb24gX3dpdGhGaWVsZChmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZSwgWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhmaWVsZC5jaGVja1ZhbGlkSW50VmFsdWUobmV3VmFsdWUpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLndpdGgoZmllbGQsIG5ld1ZhbHVlKSwgdGhpcy5fb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhMb2NhbFRpbWVPZmZzZXQgPSBmdW5jdGlvbiBfd2l0aExvY2FsVGltZU9mZnNldCh0aW1lLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5fdGltZSA9PT0gdGltZSAmJiB0aGlzLl9vZmZzZXQuZXF1YWxzKG9mZnNldCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9mZnNldFRpbWUodGltZSwgb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE9mZnNldFRpbWUsICdvdGhlcicpO1xuICAgIGlmICh0aGlzLl9vZmZzZXQuZXF1YWxzKG90aGVyLl9vZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZS5jb21wYXJlVG8ob3RoZXIuX3RpbWUpO1xuICAgIH1cbiAgICB2YXIgY29tcGFyZSA9IE1hdGhVdGlsLmNvbXBhcmVOdW1iZXJzKHRoaXMuX3RvRXBvY2hOYW5vKCksIG90aGVyLl90b0Vwb2NoTmFubygpKTtcbiAgICBpZiAoY29tcGFyZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWUuY29tcGFyZVRvKG90aGVyLl90aW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmU7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBPZmZzZXRUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZS5lcXVhbHMob3RoZXIuX3RpbWUpICYmIHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUuaGFzaENvZGUoKSBeIHRoaXMuX29mZnNldC5oYXNoQ29kZSgpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS50b1N0cmluZygpICsgdGhpcy5fb2Zmc2V0LnRvU3RyaW5nKCk7XG4gIH07XG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgcmV0dXJuIE9mZnNldFRpbWU7XG59KFRlbXBvcmFsKTtcbmZ1bmN0aW9uIF9pbml0JDgoKSB7XG4gIE9mZnNldFRpbWUuTUlOID0gT2Zmc2V0VGltZS5vZk51bWJlcnMoMCwgMCwgMCwgMCwgWm9uZU9mZnNldC5NQVgpO1xuICBPZmZzZXRUaW1lLk1BWCA9IE9mZnNldFRpbWUub2ZOdW1iZXJzKDIzLCA1OSwgNTksIDk5OTk5OTk5OSwgWm9uZU9mZnNldC5NSU4pO1xuICBPZmZzZXRUaW1lLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdPZmZzZXRUaW1lLkZST00nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gT2Zmc2V0VGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBDaHJvbm9ab25lZERhdGVUaW1lID0gZnVuY3Rpb24gKF9UZW1wb3JhbCkge1xuICBfaW5oZXJpdHNMb29zZShDaHJvbm9ab25lZERhdGVUaW1lLCBfVGVtcG9yYWwpO1xuICBmdW5jdGlvbiBDaHJvbm9ab25lZERhdGVUaW1lKCkge1xuICAgIHJldHVybiBfVGVtcG9yYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBDaHJvbm9ab25lZERhdGVUaW1lLnByb3RvdHlwZTtcbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0xvY2FsRGF0ZSgpLmNocm9ub2xvZ3koKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5OQU5PUztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlLm9mRXBvY2hEYXkodGhpcy50b0xvY2FsRGF0ZSgpLnRvRXBvY2hEYXkoKSk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbFRpbWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuICBfcHJvdG8udG9JbnN0YW50ID0gZnVuY3Rpb24gdG9JbnN0YW50KCkge1xuICAgIHJldHVybiBJbnN0YW50Lm9mRXBvY2hTZWNvbmQodGhpcy50b0Vwb2NoU2Vjb25kKCksIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkpO1xuICB9O1xuICBfcHJvdG8udG9FcG9jaFNlY29uZCA9IGZ1bmN0aW9uIHRvRXBvY2hTZWNvbmQoKSB7XG4gICAgdmFyIGVwb2NoRGF5ID0gdGhpcy50b0xvY2FsRGF0ZSgpLnRvRXBvY2hEYXkoKTtcbiAgICB2YXIgc2VjcyA9IGVwb2NoRGF5ICogODY0MDAgKyB0aGlzLnRvTG9jYWxUaW1lKCkudG9TZWNvbmRPZkRheSgpO1xuICAgIHNlY3MgLT0gdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKTtcbiAgICByZXR1cm4gc2VjcztcbiAgfTtcbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy50b0Vwb2NoU2Vjb25kKCksIG90aGVyLnRvRXBvY2hTZWNvbmQoKSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSAtIG90aGVyLnRvTG9jYWxUaW1lKCkubmFubygpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICBjbXAgPSB0aGlzLnRvTG9jYWxEYXRlVGltZSgpLmNvbXBhcmVUbyhvdGhlci50b0xvY2FsRGF0ZVRpbWUoKSk7XG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICBjbXAgPSBzdHJjbXAodGhpcy56b25lKCkuaWQoKSwgb3RoZXIuem9uZSgpLmlkKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbXA7XG4gIH07XG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICB2YXIgdGhpc0Vwb2NoU2VjID0gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG4gICAgdmFyIG90aGVyRXBvY2hTZWMgPSBvdGhlci50b0Vwb2NoU2Vjb25kKCk7XG4gICAgcmV0dXJuIHRoaXNFcG9jaFNlYyA+IG90aGVyRXBvY2hTZWMgfHwgdGhpc0Vwb2NoU2VjID09PSBvdGhlckVwb2NoU2VjICYmIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgPiBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgfTtcbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgdmFyIHRoaXNFcG9jaFNlYyA9IHRoaXMudG9FcG9jaFNlY29uZCgpO1xuICAgIHZhciBvdGhlckVwb2NoU2VjID0gb3RoZXIudG9FcG9jaFNlY29uZCgpO1xuICAgIHJldHVybiB0aGlzRXBvY2hTZWMgPCBvdGhlckVwb2NoU2VjIHx8IHRoaXNFcG9jaFNlYyA9PT0gb3RoZXJFcG9jaFNlYyAmJiB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpIDwgb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG4gIH07XG4gIF9wcm90by5pc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbChvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy50b0Vwb2NoU2Vjb25kKCkgPT09IG90aGVyLnRvRXBvY2hTZWNvbmQoKSAmJiB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpID09PSBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENocm9ub1pvbmVkRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPT09IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgcmV0dXJuIENocm9ub1pvbmVkRGF0ZVRpbWU7XG59KFRlbXBvcmFsKTtcbmZ1bmN0aW9uIHN0cmNtcChhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxudmFyIFpvbmVkRGF0ZVRpbWUgPSBmdW5jdGlvbiAoX0Nocm9ub1pvbmVkRGF0ZVRpbWUpIHtcbiAgX2luaGVyaXRzTG9vc2UoWm9uZWREYXRlVGltZSwgX0Nocm9ub1pvbmVkRGF0ZVRpbWUpO1xuICBab25lZERhdGVUaW1lLm5vdyA9IGZ1bmN0aW9uIG5vdyhjbG9ja09yWm9uZSkge1xuICAgIHZhciBjbG9jaztcbiAgICBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBab25lSWQpIHtcbiAgICAgIGNsb2NrID0gQ2xvY2suc3lzdGVtKGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvY2sgPSBjbG9ja09yWm9uZSA9PSBudWxsID8gQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSA6IGNsb2NrT3Jab25lO1xuICAgIH1cbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQoY2xvY2suaW5zdGFudCgpLCBjbG9jay56b25lKCkpO1xuICB9O1xuICBab25lZERhdGVUaW1lLm9mID0gZnVuY3Rpb24gb2YoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikge1xuICAgICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2YyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExvY2FsRGF0ZSkge1xuICAgICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2YzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mOC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgWm9uZWREYXRlVGltZS5vZjMgPSBmdW5jdGlvbiBvZjMoZGF0ZSwgdGltZSwgem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mMihMb2NhbERhdGVUaW1lLm9mKGRhdGUsIHRpbWUpLCB6b25lKTtcbiAgfTtcbiAgWm9uZWREYXRlVGltZS5vZjIgPSBmdW5jdGlvbiBvZjIobG9jYWxEYXRlVGltZSwgem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mTG9jYWwobG9jYWxEYXRlVGltZSwgem9uZSwgbnVsbCk7XG4gIH07XG4gIFpvbmVkRGF0ZVRpbWUub2Y4ID0gZnVuY3Rpb24gb2Y4KHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kLCB6b25lKSB7XG4gICAgdmFyIGR0ID0gTG9jYWxEYXRlVGltZS5vZih5ZWFyLCBtb250aCwgZGF5T2ZNb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2ZMb2NhbChkdCwgem9uZSwgbnVsbCk7XG4gIH07XG4gIFpvbmVkRGF0ZVRpbWUub2ZMb2NhbCA9IGZ1bmN0aW9uIG9mTG9jYWwobG9jYWxEYXRlVGltZSwgem9uZSwgcHJlZmVycmVkT2Zmc2V0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwobG9jYWxEYXRlVGltZSwgJ2xvY2FsRGF0ZVRpbWUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIGlmICh6b25lIGluc3RhbmNlb2YgWm9uZU9mZnNldCkge1xuICAgICAgcmV0dXJuIG5ldyBab25lZERhdGVUaW1lKGxvY2FsRGF0ZVRpbWUsIHpvbmUsIHpvbmUpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gbnVsbDtcbiAgICB2YXIgcnVsZXMgPSB6b25lLnJ1bGVzKCk7XG4gICAgdmFyIHZhbGlkT2Zmc2V0cyA9IHJ1bGVzLnZhbGlkT2Zmc2V0cyhsb2NhbERhdGVUaW1lKTtcbiAgICBpZiAodmFsaWRPZmZzZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gdmFsaWRPZmZzZXRzWzBdO1xuICAgIH0gZWxzZSBpZiAodmFsaWRPZmZzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIHRyYW5zID0gcnVsZXMudHJhbnNpdGlvbihsb2NhbERhdGVUaW1lKTtcbiAgICAgIGxvY2FsRGF0ZVRpbWUgPSBsb2NhbERhdGVUaW1lLnBsdXNTZWNvbmRzKHRyYW5zLmR1cmF0aW9uKCkuc2Vjb25kcygpKTtcbiAgICAgIG9mZnNldCA9IHRyYW5zLm9mZnNldEFmdGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmVmZXJyZWRPZmZzZXQgIT0gbnVsbCAmJiB2YWxpZE9mZnNldHMuc29tZShmdW5jdGlvbiAodmFsaWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkT2Zmc2V0LmVxdWFscyhwcmVmZXJyZWRPZmZzZXQpO1xuICAgICAgfSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gcHJlZmVycmVkT2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gcmVxdWlyZU5vbk51bGwodmFsaWRPZmZzZXRzWzBdLCAnb2Zmc2V0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9uZWREYXRlVGltZShsb2NhbERhdGVUaW1lLCBvZmZzZXQsIHpvbmUpO1xuICB9O1xuICBab25lZERhdGVUaW1lLm9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mSW5zdGFudCgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2ZJbnN0YW50Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICBab25lZERhdGVUaW1lLm9mSW5zdGFudDIgPSBmdW5jdGlvbiBvZkluc3RhbnQyKGluc3RhbnQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuX2NyZWF0ZShpbnN0YW50LmVwb2NoU2Vjb25kKCksIGluc3RhbnQubmFubygpLCB6b25lKTtcbiAgfTtcbiAgWm9uZWREYXRlVGltZS5vZkluc3RhbnQzID0gZnVuY3Rpb24gb2ZJbnN0YW50Myhsb2NhbERhdGVUaW1lLCBvZmZzZXQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChsb2NhbERhdGVUaW1lLCAnbG9jYWxEYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuX2NyZWF0ZShsb2NhbERhdGVUaW1lLnRvRXBvY2hTZWNvbmQob2Zmc2V0KSwgbG9jYWxEYXRlVGltZS5uYW5vKCksIHpvbmUpO1xuICB9O1xuICBab25lZERhdGVUaW1lLl9jcmVhdGUgPSBmdW5jdGlvbiBfY3JlYXRlKGVwb2NoU2Vjb25kLCBuYW5vT2ZTZWNvbmQsIHpvbmUpIHtcbiAgICB2YXIgcnVsZXMgPSB6b25lLnJ1bGVzKCk7XG4gICAgdmFyIGluc3RhbnQgPSBJbnN0YW50Lm9mRXBvY2hTZWNvbmQoZXBvY2hTZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gICAgdmFyIG9mZnNldCA9IHJ1bGVzLm9mZnNldChpbnN0YW50KTtcbiAgICB2YXIgbGR0ID0gTG9jYWxEYXRlVGltZS5vZkVwb2NoU2Vjb25kKGVwb2NoU2Vjb25kLCBuYW5vT2ZTZWNvbmQsIG9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBab25lZERhdGVUaW1lKGxkdCwgb2Zmc2V0LCB6b25lKTtcbiAgfTtcbiAgWm9uZWREYXRlVGltZS5vZlN0cmljdCA9IGZ1bmN0aW9uIG9mU3RyaWN0KGxvY2FsRGF0ZVRpbWUsIG9mZnNldCwgem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGxvY2FsRGF0ZVRpbWUsICdsb2NhbERhdGVUaW1lJyk7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICB2YXIgcnVsZXMgPSB6b25lLnJ1bGVzKCk7XG4gICAgaWYgKHJ1bGVzLmlzVmFsaWRPZmZzZXQobG9jYWxEYXRlVGltZSwgb2Zmc2V0KSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciB0cmFucyA9IHJ1bGVzLnRyYW5zaXRpb24obG9jYWxEYXRlVGltZSk7XG4gICAgICBpZiAodHJhbnMgIT0gbnVsbCAmJiB0cmFucy5pc0dhcCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkxvY2FsRGF0ZVRpbWUgXCIgKyBsb2NhbERhdGVUaW1lICsgXCIgZG9lcyBub3QgZXhpc3QgaW4gem9uZSBcIiArIHpvbmUgKyBcIiBkdWUgdG8gYSBnYXAgaW4gdGhlIGxvY2FsIHRpbWUtbGluZSwgdHlwaWNhbGx5IGNhdXNlZCBieSBkYXlsaWdodCBzYXZpbmdzXCIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiWm9uZU9mZnNldCBcXFwiXCIgKyBvZmZzZXQgKyBcIlxcXCIgaXMgbm90IHZhbGlkIGZvciBMb2NhbERhdGVUaW1lIFxcXCJcIiArIGxvY2FsRGF0ZVRpbWUgKyBcIlxcXCIgaW4gem9uZSBcXFwiXCIgKyB6b25lICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobG9jYWxEYXRlVGltZSwgb2Zmc2V0LCB6b25lKTtcbiAgfTtcbiAgWm9uZWREYXRlVGltZS5vZkxlbmllbnQgPSBmdW5jdGlvbiBvZkxlbmllbnQobG9jYWxEYXRlVGltZSwgb2Zmc2V0LCB6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobG9jYWxEYXRlVGltZSwgJ2xvY2FsRGF0ZVRpbWUnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIGlmICh6b25lIGluc3RhbmNlb2YgWm9uZU9mZnNldCAmJiBvZmZzZXQuZXF1YWxzKHpvbmUpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignWm9uZUlkIG11c3QgbWF0Y2ggWm9uZU9mZnNldCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobG9jYWxEYXRlVGltZSwgb2Zmc2V0LCB6b25lKTtcbiAgfTtcbiAgWm9uZWREYXRlVGltZS5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBab25lZERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfVxuICAgIHZhciB6b25lID0gWm9uZUlkLmZyb20odGVtcG9yYWwpO1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMpKSB7XG4gICAgICB2YXIgemR0ID0gWm9uZWREYXRlVGltZS5fZnJvbSh0ZW1wb3JhbCwgem9uZSk7XG4gICAgICBpZiAoemR0ICE9IG51bGwpIHJldHVybiB6ZHQ7XG4gICAgfVxuICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mMihsZHQsIHpvbmUpO1xuICB9O1xuICBab25lZERhdGVUaW1lLl9mcm9tID0gZnVuY3Rpb24gX2Zyb20odGVtcG9yYWwsIHpvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuX19mcm9tKHRlbXBvcmFsLCB6b25lKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKCEoZXggaW5zdGFuY2VvZiBEYXRlVGltZUV4Y2VwdGlvbikpIHRocm93IGV4O1xuICAgIH1cbiAgfTtcbiAgWm9uZWREYXRlVGltZS5fX2Zyb20gPSBmdW5jdGlvbiBfX2Zyb20odGVtcG9yYWwsIHpvbmUpIHtcbiAgICB2YXIgZXBvY2hTZWNvbmQgPSB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgdmFyIG5hbm9PZlNlY29uZCA9IHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCk7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuX2NyZWF0ZShlcG9jaFNlY29uZCwgbmFub09mU2Vjb25kLCB6b25lKTtcbiAgfTtcbiAgWm9uZWREYXRlVGltZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX1pPTkVEX0RBVEVfVElNRTtcbiAgICB9XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBab25lZERhdGVUaW1lLkZST00pO1xuICB9O1xuICBmdW5jdGlvbiBab25lZERhdGVUaW1lKGRhdGVUaW1lLCBvZmZzZXQsIHpvbmUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF0ZVRpbWUsICdkYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgX3RoaXMgPSBfQ2hyb25vWm9uZWREYXRlVGltZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2RhdGVUaW1lID0gZGF0ZVRpbWU7XG4gICAgX3RoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICBfdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBab25lZERhdGVUaW1lLnByb3RvdHlwZTtcbiAgX3Byb3RvLl9yZXNvbHZlTG9jYWwgPSBmdW5jdGlvbiBfcmVzb2x2ZUxvY2FsKG5ld0RhdGVUaW1lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobmV3RGF0ZVRpbWUsICduZXdEYXRlVGltZScpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mTG9jYWwobmV3RGF0ZVRpbWUsIHRoaXMuX3pvbmUsIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5fcmVzb2x2ZUluc3RhbnQgPSBmdW5jdGlvbiBfcmVzb2x2ZUluc3RhbnQobmV3RGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQzKG5ld0RhdGVUaW1lLCB0aGlzLl9vZmZzZXQsIHRoaXMuX3pvbmUpO1xuICB9O1xuICBfcHJvdG8uX3Jlc29sdmVPZmZzZXQgPSBmdW5jdGlvbiBfcmVzb2x2ZU9mZnNldChvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpID09PSBmYWxzZSAmJiB0aGlzLl96b25lLnJ1bGVzKCkuaXNWYWxpZE9mZnNldCh0aGlzLl9kYXRlVGltZSwgb2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIG5ldyBab25lZERhdGVUaW1lKHRoaXMuX2RhdGVUaW1lLCBvZmZzZXQsIHRoaXMuX3pvbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTIHx8IGZpZWxkID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykge1xuICAgICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5yYW5nZVJlZmluZWRCeSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmdldExvbmcoZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5nZXRMb25nKGZpZWxkKTtcbiAgICB9XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuICBfcHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH07XG4gIF9wcm90by53aXRoRWFybGllck9mZnNldEF0T3ZlcmxhcCA9IGZ1bmN0aW9uIHdpdGhFYXJsaWVyT2Zmc2V0QXRPdmVybGFwKCkge1xuICAgIHZhciB0cmFucyA9IHRoaXMuX3pvbmUucnVsZXMoKS50cmFuc2l0aW9uKHRoaXMuX2RhdGVUaW1lKTtcbiAgICBpZiAodHJhbnMgIT0gbnVsbCAmJiB0cmFucy5pc092ZXJsYXAoKSkge1xuICAgICAgdmFyIGVhcmxpZXJPZmZzZXQgPSB0cmFucy5vZmZzZXRCZWZvcmUoKTtcbiAgICAgIGlmIChlYXJsaWVyT2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUodGhpcy5fZGF0ZVRpbWUsIGVhcmxpZXJPZmZzZXQsIHRoaXMuX3pvbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX3Byb3RvLndpdGhMYXRlck9mZnNldEF0T3ZlcmxhcCA9IGZ1bmN0aW9uIHdpdGhMYXRlck9mZnNldEF0T3ZlcmxhcCgpIHtcbiAgICB2YXIgdHJhbnMgPSB0aGlzLl96b25lLnJ1bGVzKCkudHJhbnNpdGlvbih0aGlzLnRvTG9jYWxEYXRlVGltZSgpKTtcbiAgICBpZiAodHJhbnMgIT0gbnVsbCkge1xuICAgICAgdmFyIGxhdGVyT2Zmc2V0ID0gdHJhbnMub2Zmc2V0QWZ0ZXIoKTtcbiAgICAgIGlmIChsYXRlck9mZnNldC5lcXVhbHModGhpcy5fb2Zmc2V0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab25lZERhdGVUaW1lKHRoaXMuX2RhdGVUaW1lLCBsYXRlck9mZnNldCwgdGhpcy5fem9uZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfcHJvdG8uem9uZSA9IGZ1bmN0aW9uIHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gIH07XG4gIF9wcm90by53aXRoWm9uZVNhbWVMb2NhbCA9IGZ1bmN0aW9uIHdpdGhab25lU2FtZUxvY2FsKHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHJldHVybiB0aGlzLl96b25lLmVxdWFscyh6b25lKSA/IHRoaXMgOiBab25lZERhdGVUaW1lLm9mTG9jYWwodGhpcy5fZGF0ZVRpbWUsIHpvbmUsIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by53aXRoWm9uZVNhbWVJbnN0YW50ID0gZnVuY3Rpb24gd2l0aFpvbmVTYW1lSW5zdGFudCh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXR1cm4gdGhpcy5fem9uZS5lcXVhbHMoem9uZSkgPyB0aGlzIDogWm9uZWREYXRlVGltZS5fY3JlYXRlKHRoaXMuX2RhdGVUaW1lLnRvRXBvY2hTZWNvbmQodGhpcy5fb2Zmc2V0KSwgdGhpcy5fZGF0ZVRpbWUubmFubygpLCB6b25lKTtcbiAgfTtcbiAgX3Byb3RvLndpdGhGaXhlZE9mZnNldFpvbmUgPSBmdW5jdGlvbiB3aXRoRml4ZWRPZmZzZXRab25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lLmVxdWFscyh0aGlzLl9vZmZzZXQpID8gdGhpcyA6IG5ldyBab25lZERhdGVUaW1lKHRoaXMuX2RhdGVUaW1lLCB0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by55ZWFyID0gZnVuY3Rpb24geWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUueWVhcigpO1xuICB9O1xuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm1vbnRoVmFsdWUoKTtcbiAgfTtcbiAgX3Byb3RvLm1vbnRoID0gZnVuY3Rpb24gbW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm1vbnRoKCk7XG4gIH07XG4gIF9wcm90by5kYXlPZk1vbnRoID0gZnVuY3Rpb24gZGF5T2ZNb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuZGF5T2ZNb250aCgpO1xuICB9O1xuICBfcHJvdG8uZGF5T2ZZZWFyID0gZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZlllYXIoKTtcbiAgfTtcbiAgX3Byb3RvLmRheU9mV2VlayA9IGZ1bmN0aW9uIGRheU9mV2VlaygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuZGF5T2ZXZWVrKCk7XG4gIH07XG4gIF9wcm90by5ob3VyID0gZnVuY3Rpb24gaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuaG91cigpO1xuICB9O1xuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5taW51dGUoKTtcbiAgfTtcbiAgX3Byb3RvLnNlY29uZCA9IGZ1bmN0aW9uIHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuc2Vjb25kKCk7XG4gIH07XG4gIF9wcm90by5uYW5vID0gZnVuY3Rpb24gbmFubygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUubmFubygpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhBZGp1c3RlciA9IGZ1bmN0aW9uIF93aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwoTG9jYWxEYXRlVGltZS5vZihhZGp1c3RlciwgdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbFRpbWUoKSkpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwoTG9jYWxEYXRlVGltZS5vZih0aGlzLl9kYXRlVGltZS50b0xvY2FsRGF0ZSgpLCBhZGp1c3RlcikpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKGFkanVzdGVyKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgSW5zdGFudCkge1xuICAgICAgdmFyIGluc3RhbnQgPSBhZGp1c3RlcjtcbiAgICAgIHJldHVybiBab25lZERhdGVUaW1lLl9jcmVhdGUoaW5zdGFudC5lcG9jaFNlY29uZCgpLCBpbnN0YW50Lm5hbm8oKSwgdGhpcy5fem9uZSk7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIFpvbmVPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlT2Zmc2V0KGFkanVzdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIF9DaHJvbm9ab25lZERhdGVUaW1lLnByb3RvdHlwZS5fd2l0aEFkanVzdGVyLmNhbGwodGhpcywgYWRqdXN0ZXIpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuX2NyZWF0ZShuZXdWYWx1ZSwgdGhpcy5uYW5vKCksIHRoaXMuX3pvbmUpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKGZpZWxkLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGgoZmllbGQsIG5ld1ZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUud2l0aFllYXIoeWVhcikpO1xuICB9O1xuICBfcHJvdG8ud2l0aE1vbnRoID0gZnVuY3Rpb24gd2l0aE1vbnRoKG1vbnRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoTW9udGgobW9udGgpKTtcbiAgfTtcbiAgX3Byb3RvLndpdGhEYXlPZk1vbnRoID0gZnVuY3Rpb24gd2l0aERheU9mTW9udGgoZGF5T2ZNb250aCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUud2l0aERheU9mTW9udGgoZGF5T2ZNb250aCkpO1xuICB9O1xuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoRGF5T2ZZZWFyKGRheU9mWWVhcikpO1xuICB9O1xuICBfcHJvdG8ud2l0aEhvdXIgPSBmdW5jdGlvbiB3aXRoSG91cihob3VyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoSG91cihob3VyKSk7XG4gIH07XG4gIF9wcm90by53aXRoTWludXRlID0gZnVuY3Rpb24gd2l0aE1pbnV0ZShtaW51dGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhNaW51dGUobWludXRlKSk7XG4gIH07XG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhTZWNvbmQoc2Vjb25kKSk7XG4gIH07XG4gIF9wcm90by53aXRoTmFubyA9IGZ1bmN0aW9uIHdpdGhOYW5vKG5hbm9PZlNlY29uZCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUud2l0aE5hbm8obmFub09mU2Vjb25kKSk7XG4gIH07XG4gIF9wcm90by50cnVuY2F0ZWRUbyA9IGZ1bmN0aW9uIHRydW5jYXRlZFRvKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLnRydW5jYXRlZFRvKHVuaXQpKTtcbiAgfTtcbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgaWYgKHVuaXQuaXNEYXRlQmFzZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLnBsdXMoYW1vdW50VG9BZGQsIHVuaXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlSW5zdGFudCh0aGlzLl9kYXRlVGltZS5wbHVzKGFtb3VudFRvQWRkLCB1bml0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuICBfcHJvdG8ucGx1c1llYXJzID0gZnVuY3Rpb24gcGx1c1llYXJzKHllYXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS5wbHVzWWVhcnMoeWVhcnMpKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUucGx1c01vbnRocyhtb250aHMpKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNXZWVrcyA9IGZ1bmN0aW9uIHBsdXNXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUucGx1c1dlZWtzKHdlZWtzKSk7XG4gIH07XG4gIF9wcm90by5wbHVzRGF5cyA9IGZ1bmN0aW9uIHBsdXNEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLnBsdXNEYXlzKGRheXMpKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlSW5zdGFudCh0aGlzLl9kYXRlVGltZS5wbHVzSG91cnMoaG91cnMpKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNNaW51dGVzID0gZnVuY3Rpb24gcGx1c01pbnV0ZXMobWludXRlcykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlSW5zdGFudCh0aGlzLl9kYXRlVGltZS5wbHVzTWludXRlcyhtaW51dGVzKSk7XG4gIH07XG4gIF9wcm90by5wbHVzU2Vjb25kcyA9IGZ1bmN0aW9uIHBsdXNTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUluc3RhbnQodGhpcy5fZGF0ZVRpbWUucGx1c1NlY29uZHMoc2Vjb25kcykpO1xuICB9O1xuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVJbnN0YW50KHRoaXMuX2RhdGVUaW1lLnBsdXNOYW5vcyhuYW5vcykpO1xuICB9O1xuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVzVW5pdCgtMSAqIGFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNZZWFycyA9IGZ1bmN0aW9uIG1pbnVzWWVhcnMoeWVhcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoLTEgKiB5ZWFycyk7XG4gIH07XG4gIF9wcm90by5taW51c01vbnRocyA9IGZ1bmN0aW9uIG1pbnVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMoLTEgKiBtb250aHMpO1xuICB9O1xuICBfcHJvdG8ubWludXNXZWVrcyA9IGZ1bmN0aW9uIG1pbnVzV2Vla3Mod2Vla3MpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzV2Vla3MoLTEgKiB3ZWVrcyk7XG4gIH07XG4gIF9wcm90by5taW51c0RheXMgPSBmdW5jdGlvbiBtaW51c0RheXMoZGF5cykge1xuICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKC0xICogZGF5cyk7XG4gIH07XG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygtMSAqIGhvdXJzKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTWludXRlcyA9IGZ1bmN0aW9uIG1pbnVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c01pbnV0ZXMoLTEgKiBtaW51dGVzKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoLTEgKiBzZWNvbmRzKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKC0xICogbmFub3MpO1xuICB9O1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxEYXRlKCk7XG4gICAgfVxuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG4gICAgcmV0dXJuIF9DaHJvbm9ab25lZERhdGVUaW1lLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIF9xdWVyeSk7XG4gIH07XG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHZhciBlbmQgPSBab25lZERhdGVUaW1lLmZyb20oZW5kRXhjbHVzaXZlKTtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIGVuZCA9IGVuZC53aXRoWm9uZVNhbWVJbnN0YW50KHRoaXMuX3pvbmUpO1xuICAgICAgaWYgKHVuaXQuaXNEYXRlQmFzZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudW50aWwoZW5kLl9kYXRlVGltZSwgdW5pdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IHRoaXMuX29mZnNldC50b3RhbFNlY29uZHMoKSAtIGVuZC5fb2Zmc2V0LnRvdGFsU2Vjb25kcygpO1xuICAgICAgICB2YXIgYWRqdXN0ZWRFbmQgPSBlbmQuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKGRpZmZlcmVuY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudW50aWwoYWRqdXN0ZWRFbmQsIHVuaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG4gIF9wcm90by50b0xvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lO1xuICB9O1xuICBfcHJvdG8udG9Mb2NhbERhdGUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbERhdGUoKTtcbiAgfTtcbiAgX3Byb3RvLnRvTG9jYWxUaW1lID0gZnVuY3Rpb24gdG9Mb2NhbFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnRvTG9jYWxUaW1lKCk7XG4gIH07XG4gIF9wcm90by50b09mZnNldERhdGVUaW1lID0gZnVuY3Rpb24gdG9PZmZzZXREYXRlVGltZSgpIHtcbiAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YodGhpcy5fZGF0ZVRpbWUsIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBab25lZERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuZXF1YWxzKG90aGVyLl9kYXRlVGltZSkgJiYgdGhpcy5fb2Zmc2V0LmVxdWFscyhvdGhlci5fb2Zmc2V0KSAmJiB0aGlzLl96b25lLmVxdWFscyhvdGhlci5fem9uZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2hDb2RlKHRoaXMuX2RhdGVUaW1lLmhhc2hDb2RlKCksIHRoaXMuX29mZnNldC5oYXNoQ29kZSgpLCB0aGlzLl96b25lLmhhc2hDb2RlKCkpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gdGhpcy5fZGF0ZVRpbWUudG9TdHJpbmcoKSArIHRoaXMuX29mZnNldC50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLl9vZmZzZXQgIT09IHRoaXMuX3pvbmUpIHtcbiAgICAgIHN0ciArPSBcIltcIiArIHRoaXMuX3pvbmUudG9TdHJpbmcoKSArIFwiXVwiO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmV0dXJuIF9DaHJvbm9ab25lZERhdGVUaW1lLnByb3RvdHlwZS5mb3JtYXQuY2FsbCh0aGlzLCBmb3JtYXR0ZXIpO1xuICB9O1xuICByZXR1cm4gWm9uZWREYXRlVGltZTtcbn0oQ2hyb25vWm9uZWREYXRlVGltZSk7XG5mdW5jdGlvbiBfaW5pdCQ3KCkge1xuICBab25lZERhdGVUaW1lLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdab25lZERhdGVUaW1lLkZST00nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBPZmZzZXREYXRlVGltZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoT2Zmc2V0RGF0ZVRpbWUsIF9UZW1wb3JhbCk7XG4gIE9mZnNldERhdGVUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIE9mZnNldERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gWm9uZU9mZnNldC5mcm9tKHRlbXBvcmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICAgICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YobGR0LCBvZmZzZXQpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB2YXIgaW5zdGFudCA9IEluc3RhbnQuZnJvbSh0ZW1wb3JhbCk7XG4gICAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZkluc3RhbnQoaW5zdGFudCwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBPZmZzZXREYXRlVGltZSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgfTtcbiAgT2Zmc2V0RGF0ZVRpbWUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5ub3coQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrT3Jab25lLCAnY2xvY2tPclpvbmUnKTtcbiAgICAgIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIFpvbmVJZCkge1xuICAgICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUubm93KENsb2NrLnN5c3RlbShjbG9ja09yWm9uZSkpO1xuICAgICAgfSBlbHNlIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIENsb2NrKSB7XG4gICAgICAgIHZhciBub3cgPSBjbG9ja09yWm9uZS5pbnN0YW50KCk7XG4gICAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZkluc3RhbnQobm93LCBjbG9ja09yWm9uZS56b25lKCkucnVsZXMoKS5vZmZzZXQobm93KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdjbG9ja09yWm9uZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFpvbmVJZCBvciBDbG9jaycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgT2Zmc2V0RGF0ZVRpbWUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZEYXRlVGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mRGF0ZUFuZFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mTnVtYmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgT2Zmc2V0RGF0ZVRpbWUub2ZEYXRlVGltZSA9IGZ1bmN0aW9uIG9mRGF0ZVRpbWUoZGF0ZVRpbWUsIG9mZnNldCkge1xuICAgIHJldHVybiBuZXcgT2Zmc2V0RGF0ZVRpbWUoZGF0ZVRpbWUsIG9mZnNldCk7XG4gIH07XG4gIE9mZnNldERhdGVUaW1lLm9mRGF0ZUFuZFRpbWUgPSBmdW5jdGlvbiBvZkRhdGVBbmRUaW1lKGRhdGUsIHRpbWUsIG9mZnNldCkge1xuICAgIHZhciBkdCA9IExvY2FsRGF0ZVRpbWUub2YoZGF0ZSwgdGltZSk7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShkdCwgb2Zmc2V0KTtcbiAgfTtcbiAgT2Zmc2V0RGF0ZVRpbWUub2ZOdW1iZXJzID0gZnVuY3Rpb24gb2ZOdW1iZXJzKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kLCBvZmZzZXQpIHtcbiAgICBpZiAoaG91ciA9PT0gdm9pZCAwKSB7XG4gICAgICBob3VyID0gMDtcbiAgICB9XG4gICAgaWYgKG1pbnV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW51dGUgPSAwO1xuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZCA9IDA7XG4gICAgfVxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG4gICAgdmFyIGR0ID0gTG9jYWxEYXRlVGltZS5vZih5ZWFyLCBtb250aCwgZGF5T2ZNb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShkdCwgb2Zmc2V0KTtcbiAgfTtcbiAgT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50ID0gZnVuY3Rpb24gb2ZJbnN0YW50KGluc3RhbnQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgdmFyIHJ1bGVzID0gem9uZS5ydWxlcygpO1xuICAgIHZhciBvZmZzZXQgPSBydWxlcy5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIGxkdCA9IExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZChpbnN0YW50LmVwb2NoU2Vjb25kKCksIGluc3RhbnQubmFubygpLCBvZmZzZXQpO1xuICAgIHJldHVybiBuZXcgT2Zmc2V0RGF0ZVRpbWUobGR0LCBvZmZzZXQpO1xuICB9O1xuICBPZmZzZXREYXRlVGltZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9EQVRFX1RJTUU7XG4gICAgfVxuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgT2Zmc2V0RGF0ZVRpbWUuRlJPTSk7XG4gIH07XG4gIGZ1bmN0aW9uIE9mZnNldERhdGVUaW1lKGRhdGVUaW1lLCBvZmZzZXQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfVGVtcG9yYWwuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHJlcXVpcmVOb25OdWxsKGRhdGVUaW1lLCAnZGF0ZVRpbWUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZGF0ZVRpbWUsIExvY2FsRGF0ZVRpbWUsICdkYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvZmZzZXQsIFpvbmVPZmZzZXQsICdvZmZzZXQnKTtcbiAgICBfdGhpcy5fZGF0ZVRpbWUgPSBkYXRlVGltZTtcbiAgICBfdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gT2Zmc2V0RGF0ZVRpbWUucHJvdG90eXBlO1xuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5FUE9DSF9EQVksIHRoaXMudG9Mb2NhbERhdGUoKS50b0Vwb2NoRGF5KCkpLndpdGgoQ2hyb25vRmllbGQuTkFOT19PRl9EQVksIHRoaXMudG9Mb2NhbFRpbWUoKS50b05hbm9PZkRheSgpKS53aXRoKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTLCB0aGlzLm9mZnNldCgpLnRvdGFsU2Vjb25kcygpKTtcbiAgfTtcbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgdmFyIGVuZCA9IE9mZnNldERhdGVUaW1lLmZyb20oZW5kRXhjbHVzaXZlKTtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIGVuZCA9IGVuZC53aXRoT2Zmc2V0U2FtZUluc3RhbnQodGhpcy5fb2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS51bnRpbChlbmQuX2RhdGVUaW1lLCB1bml0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuICBfcHJvdG8uYXRab25lU2FtZUluc3RhbnQgPSBmdW5jdGlvbiBhdFpvbmVTYW1lSW5zdGFudCh6b25lKSB7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2ZJbnN0YW50KHRoaXMuX2RhdGVUaW1lLCB0aGlzLl9vZmZzZXQsIHpvbmUpO1xuICB9O1xuICBfcHJvdG8uYXRab25lU2ltaWxhckxvY2FsID0gZnVuY3Rpb24gYXRab25lU2ltaWxhckxvY2FsKHpvbmUpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkxvY2FsKHRoaXMuX2RhdGVUaW1lLCB6b25lLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk5BTk9TO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0xvY2FsRGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxUaW1lKCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTOlxuICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkZpZWxkIHRvbyBsYXJnZSBmb3IgYW4gaW50OiBcIiArIGZpZWxkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5nZXQoZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnRvRXBvY2hTZWNvbmQoKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5nZXRMb25nKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcbiAgX3Byb3RvLnllYXIgPSBmdW5jdGlvbiB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS55ZWFyKCk7XG4gIH07XG4gIF9wcm90by5tb250aFZhbHVlID0gZnVuY3Rpb24gbW9udGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUubW9udGhWYWx1ZSgpO1xuICB9O1xuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUubW9udGgoKTtcbiAgfTtcbiAgX3Byb3RvLmRheU9mTW9udGggPSBmdW5jdGlvbiBkYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZk1vbnRoKCk7XG4gIH07XG4gIF9wcm90by5kYXlPZlllYXIgPSBmdW5jdGlvbiBkYXlPZlllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmRheU9mWWVhcigpO1xuICB9O1xuICBfcHJvdG8uZGF5T2ZXZWVrID0gZnVuY3Rpb24gZGF5T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZldlZWsoKTtcbiAgfTtcbiAgX3Byb3RvLmhvdXIgPSBmdW5jdGlvbiBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5ob3VyKCk7XG4gIH07XG4gIF9wcm90by5taW51dGUgPSBmdW5jdGlvbiBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm1pbnV0ZSgpO1xuICB9O1xuICBfcHJvdG8uc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5zZWNvbmQoKTtcbiAgfTtcbiAgX3Byb3RvLm5hbm8gPSBmdW5jdGlvbiBuYW5vKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5uYW5vKCk7XG4gIH07XG4gIF9wcm90by50b0xvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lO1xuICB9O1xuICBfcHJvdG8udG9Mb2NhbERhdGUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbERhdGUoKTtcbiAgfTtcbiAgX3Byb3RvLnRvTG9jYWxUaW1lID0gZnVuY3Rpb24gdG9Mb2NhbFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnRvTG9jYWxUaW1lKCk7XG4gIH07XG4gIF9wcm90by50b09mZnNldFRpbWUgPSBmdW5jdGlvbiB0b09mZnNldFRpbWUoKSB7XG4gICAgcmV0dXJuIE9mZnNldFRpbWUub2YodGhpcy5fZGF0ZVRpbWUudG9Mb2NhbFRpbWUoKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnRvWm9uZWREYXRlVGltZSA9IGZ1bmN0aW9uIHRvWm9uZWREYXRlVGltZSgpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZih0aGlzLl9kYXRlVGltZSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnRvSW5zdGFudCA9IGZ1bmN0aW9uIHRvSW5zdGFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9JbnN0YW50KHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by50b0Vwb2NoU2Vjb25kID0gZnVuY3Rpb24gdG9FcG9jaFNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9FcG9jaFNlY29uZCh0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZE9yVW5pdCkge1xuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNEYXRlQmFzZWQoKSB8fCBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpO1xuICAgIH1cbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNEYXRlQmFzZWQoKSB8fCBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRPclVuaXQgIT0gbnVsbCAmJiBmaWVsZE9yVW5pdC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUucmFuZ2UoZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQucmFuZ2VSZWZpbmVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5fd2l0aEFkanVzdGVyID0gZnVuY3Rpb24gX3dpdGhBZGp1c3RlcihhZGp1c3Rlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGFkanVzdGVyKTtcbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGUgfHwgYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUgfHwgYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGgoYWRqdXN0ZXIpLCB0aGlzLl9vZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBJbnN0YW50KSB7XG4gICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50KGFkanVzdGVyLCB0aGlzLl9vZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBab25lT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLCBhZGp1c3Rlcik7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIE9mZnNldERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gYWRqdXN0ZXI7XG4gICAgfVxuICAgIHJldHVybiBhZGp1c3Rlci5hZGp1c3RJbnRvKHRoaXMpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQpO1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICB2YXIgZiA9IGZpZWxkO1xuICAgICAgc3dpdGNoIChmKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZkluc3RhbnQoSW5zdGFudC5vZkVwb2NoU2Vjb25kKG5ld1ZhbHVlLCB0aGlzLm5hbm8oKSksIHRoaXMuX29mZnNldCk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFM6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZSwgWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhmLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGgoZmllbGQsIG5ld1ZhbHVlKSwgdGhpcy5fb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhEYXRlVGltZU9mZnNldCA9IGZ1bmN0aW9uIF93aXRoRGF0ZVRpbWVPZmZzZXQoZGF0ZVRpbWUsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLl9kYXRlVGltZSA9PT0gZGF0ZVRpbWUgJiYgdGhpcy5fb2Zmc2V0LmVxdWFscyhvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShkYXRlVGltZSwgb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aFllYXIoeWVhciksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhNb250aChtb250aCksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by53aXRoRGF5T2ZNb250aCA9IGZ1bmN0aW9uIHdpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS53aXRoRGF5T2ZZZWFyKGRheU9mWWVhciksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by53aXRoSG91ciA9IGZ1bmN0aW9uIHdpdGhIb3VyKGhvdXIpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhIb3VyKGhvdXIpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ud2l0aE1pbnV0ZSA9IGZ1bmN0aW9uIHdpdGhNaW51dGUobWludXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS53aXRoTWludXRlKG1pbnV0ZSksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhTZWNvbmQoc2Vjb25kKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLndpdGhOYW5vID0gZnVuY3Rpb24gd2l0aE5hbm8obmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS53aXRoTmFubyhuYW5vT2ZTZWNvbmQpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ud2l0aE9mZnNldFNhbWVMb2NhbCA9IGZ1bmN0aW9uIHdpdGhPZmZzZXRTYW1lTG9jYWwob2Zmc2V0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZSwgb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLndpdGhPZmZzZXRTYW1lSW5zdGFudCA9IGZ1bmN0aW9uIHdpdGhPZmZzZXRTYW1lSW5zdGFudChvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICBpZiAob2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGRpZmZlcmVuY2UgPSBvZmZzZXQudG90YWxTZWNvbmRzKCkgLSB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCk7XG4gICAgdmFyIGFkanVzdGVkID0gdGhpcy5fZGF0ZVRpbWUucGx1c1NlY29uZHMoZGlmZmVyZW5jZSk7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShhZGp1c3RlZCwgb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUudHJ1bmNhdGVkVG8odW5pdCksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5fcGx1c0Ftb3VudCA9IGZ1bmN0aW9uIF9wbHVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJldHVybiBhbW91bnQuYWRkVG8odGhpcyk7XG4gIH07XG4gIF9wcm90by5fcGx1c1VuaXQgPSBmdW5jdGlvbiBfcGx1c1VuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1cyhhbW91bnRUb0FkZCwgdW5pdCksIHRoaXMuX29mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c1llYXJzKHllYXJzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c01vbnRocyhtb250aHMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ucGx1c1dlZWtzID0gZnVuY3Rpb24gcGx1c1dlZWtzKHdlZWtzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzV2Vla3Mod2Vla3MpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzRGF5cyhkYXlzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c0hvdXJzKGhvdXJzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNNaW51dGVzID0gZnVuY3Rpb24gcGx1c01pbnV0ZXMobWludXRlcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c01pbnV0ZXMobWludXRlcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5wbHVzU2Vjb25kcyA9IGZ1bmN0aW9uIHBsdXNTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKHNlY29uZHMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzTmFub3MobmFub3MpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8uX21pbnVzQW1vdW50ID0gZnVuY3Rpb24gX21pbnVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCk7XG4gICAgcmV0dXJuIGFtb3VudC5zdWJ0cmFjdEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5fbWludXNVbml0ID0gZnVuY3Rpb24gX21pbnVzVW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1cygtMSAqIGFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNZZWFycyA9IGZ1bmN0aW9uIG1pbnVzWWVhcnMoeWVhcnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzWWVhcnMoeWVhcnMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNNb250aHMgPSBmdW5jdGlvbiBtaW51c01vbnRocyhtb250aHMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzTW9udGhzKG1vbnRocyksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5taW51c1dlZWtzID0gZnVuY3Rpb24gbWludXNXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNXZWVrcyh3ZWVrcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5taW51c0RheXMgPSBmdW5jdGlvbiBtaW51c0RheXMoZGF5cykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNEYXlzKGRheXMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNIb3VycyA9IGZ1bmN0aW9uIG1pbnVzSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzSG91cnMoaG91cnMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNNaW51dGVzID0gZnVuY3Rpb24gbWludXNNaW51dGVzKG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzTWludXRlcyhtaW51dGVzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5taW51c1NlY29uZHMoc2Vjb25kcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNOYW5vcyhuYW5vcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBPZmZzZXREYXRlVGltZSwgJ290aGVyJyk7XG4gICAgaWYgKHRoaXMub2Zmc2V0KCkuZXF1YWxzKG90aGVyLm9mZnNldCgpKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbERhdGVUaW1lKCkuY29tcGFyZVRvKG90aGVyLnRvTG9jYWxEYXRlVGltZSgpKTtcbiAgICB9XG4gICAgdmFyIGNtcCA9IE1hdGhVdGlsLmNvbXBhcmVOdW1iZXJzKHRoaXMudG9FcG9jaFNlY29uZCgpLCBvdGhlci50b0Vwb2NoU2Vjb25kKCkpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGNtcCA9IHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgLSBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgY21wID0gdGhpcy50b0xvY2FsRGF0ZVRpbWUoKS5jb21wYXJlVG8ob3RoZXIudG9Mb2NhbERhdGVUaW1lKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY21wO1xuICB9O1xuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgdmFyIHRoaXNFcG9jaFNlYyA9IHRoaXMudG9FcG9jaFNlY29uZCgpO1xuICAgIHZhciBvdGhlckVwb2NoU2VjID0gb3RoZXIudG9FcG9jaFNlY29uZCgpO1xuICAgIHJldHVybiB0aGlzRXBvY2hTZWMgPiBvdGhlckVwb2NoU2VjIHx8IHRoaXNFcG9jaFNlYyA9PT0gb3RoZXJFcG9jaFNlYyAmJiB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpID4gb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG4gIH07XG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHZhciB0aGlzRXBvY2hTZWMgPSB0aGlzLnRvRXBvY2hTZWNvbmQoKTtcbiAgICB2YXIgb3RoZXJFcG9jaFNlYyA9IG90aGVyLnRvRXBvY2hTZWNvbmQoKTtcbiAgICByZXR1cm4gdGhpc0Vwb2NoU2VjIDwgb3RoZXJFcG9jaFNlYyB8fCB0aGlzRXBvY2hTZWMgPT09IG90aGVyRXBvY2hTZWMgJiYgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSA8IG90aGVyLnRvTG9jYWxUaW1lKCkubmFubygpO1xuICB9O1xuICBfcHJvdG8uaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMudG9FcG9jaFNlY29uZCgpID09PSBvdGhlci50b0Vwb2NoU2Vjb25kKCkgJiYgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSA9PT0gb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBPZmZzZXREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmVxdWFscyhvdGhlci5fZGF0ZVRpbWUpICYmIHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmhhc2hDb2RlKCkgXiB0aGlzLl9vZmZzZXQuaGFzaENvZGUoKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnRvU3RyaW5nKCkgKyB0aGlzLl9vZmZzZXQudG9TdHJpbmcoKTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWU7XG59KFRlbXBvcmFsKTtcbmZ1bmN0aW9uIF9pbml0JDYoKSB7XG4gIE9mZnNldERhdGVUaW1lLk1JTiA9IExvY2FsRGF0ZVRpbWUuTUlOLmF0T2Zmc2V0KFpvbmVPZmZzZXQuTUFYKTtcbiAgT2Zmc2V0RGF0ZVRpbWUuTUFYID0gTG9jYWxEYXRlVGltZS5NQVguYXRPZmZzZXQoWm9uZU9mZnNldC5NSU4pO1xuICBPZmZzZXREYXRlVGltZS5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnT2Zmc2V0RGF0ZVRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBEQVlTX1BFUl9DWUNMRSA9IDE0NjA5NztcbnZhciBEQVlTXzAwMDBfVE9fMTk3MCA9IERBWVNfUEVSX0NZQ0xFICogNSAtICgzMCAqIDM2NSArIDcpO1xudmFyIExvY2FsRGF0ZSA9IGZ1bmN0aW9uIChfQ2hyb25vTG9jYWxEYXRlKSB7XG4gIF9pbmhlcml0c0xvb3NlKExvY2FsRGF0ZSwgX0Nocm9ub0xvY2FsRGF0ZSk7XG4gIExvY2FsRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coY2xvY2tPclpvbmUpIHtcbiAgICB2YXIgY2xvY2s7XG4gICAgaWYgKGNsb2NrT3Jab25lID09IG51bGwpIHtcbiAgICAgIGNsb2NrID0gQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKTtcbiAgICB9IGVsc2UgaWYgKGNsb2NrT3Jab25lIGluc3RhbmNlb2YgWm9uZUlkKSB7XG4gICAgICBjbG9jayA9IENsb2NrLnN5c3RlbShjbG9ja09yWm9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb2NrID0gY2xvY2tPclpvbmU7XG4gICAgfVxuICAgIHJldHVybiBMb2NhbERhdGUub2ZJbnN0YW50KGNsb2NrLmluc3RhbnQoKSwgY2xvY2suem9uZSgpKTtcbiAgfTtcbiAgTG9jYWxEYXRlLm9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mSW5zdGFudChpbnN0YW50LCB6b25lKSB7XG4gICAgaWYgKHpvbmUgPT09IHZvaWQgMCkge1xuICAgICAgem9uZSA9IFpvbmVJZC5zeXN0ZW1EZWZhdWx0KCk7XG4gICAgfVxuICAgIHJlcXVpcmVOb25OdWxsKGluc3RhbnQsICdpbnN0YW50Jyk7XG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIGVwb2NoU2VjID0gaW5zdGFudC5lcG9jaFNlY29uZCgpICsgb2Zmc2V0LnRvdGFsU2Vjb25kcygpO1xuICAgIHZhciBlcG9jaERheSA9IE1hdGhVdGlsLmZsb29yRGl2KGVwb2NoU2VjLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mRXBvY2hEYXkoZXBvY2hEYXkpO1xuICB9O1xuICBMb2NhbERhdGUub2YgPSBmdW5jdGlvbiBvZih5ZWFyLCBtb250aCwgZGF5T2ZNb250aCkge1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoKTtcbiAgfTtcbiAgTG9jYWxEYXRlLm9mWWVhckRheSA9IGZ1bmN0aW9uIG9mWWVhckRheSh5ZWFyLCBkYXlPZlllYXIpIHtcbiAgICBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRWYWx1ZSh5ZWFyKTtcbiAgICB2YXIgbGVhcCA9IElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5ZWFyKTtcbiAgICBpZiAoZGF5T2ZZZWFyID09PSAzNjYgJiYgbGVhcCA9PT0gZmFsc2UpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgXCJJbnZhbGlkIGRhdGUgJ0RheU9mWWVhciAzNjYnIGFzICdcIiArIHllYXIgKyBcIicgaXMgbm90IGEgbGVhcCB5ZWFyXCIsIERhdGVUaW1lRXhjZXB0aW9uKTtcbiAgICB9XG4gICAgdmFyIG1veSA9IE1vbnRoLm9mKE1hdGguZmxvb3IoKGRheU9mWWVhciAtIDEpIC8gMzEgKyAxKSk7XG4gICAgdmFyIG1vbnRoRW5kID0gbW95LmZpcnN0RGF5T2ZZZWFyKGxlYXApICsgbW95Lmxlbmd0aChsZWFwKSAtIDE7XG4gICAgaWYgKGRheU9mWWVhciA+IG1vbnRoRW5kKSB7XG4gICAgICBtb3kgPSBtb3kucGx1cygxKTtcbiAgICB9XG4gICAgdmFyIGRvbSA9IGRheU9mWWVhciAtIG1veS5maXJzdERheU9mWWVhcihsZWFwKSArIDE7XG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGUoeWVhciwgbW95LnZhbHVlKCksIGRvbSk7XG4gIH07XG4gIExvY2FsRGF0ZS5vZkVwb2NoRGF5ID0gZnVuY3Rpb24gb2ZFcG9jaERheShlcG9jaERheSkge1xuICAgIGlmIChlcG9jaERheSA9PT0gdm9pZCAwKSB7XG4gICAgICBlcG9jaERheSA9IDA7XG4gICAgfVxuICAgIHZhciBhZGp1c3QsIGFkanVzdEN5Y2xlcywgZG95RXN0LCB5ZWFyRXN0LCB6ZXJvRGF5O1xuICAgIHplcm9EYXkgPSBlcG9jaERheSArIERBWVNfMDAwMF9UT18xOTcwO1xuICAgIHplcm9EYXkgLT0gNjA7XG4gICAgYWRqdXN0ID0gMDtcbiAgICBpZiAoemVyb0RheSA8IDApIHtcbiAgICAgIGFkanVzdEN5Y2xlcyA9IE1hdGhVdGlsLmludERpdih6ZXJvRGF5ICsgMSwgREFZU19QRVJfQ1lDTEUpIC0gMTtcbiAgICAgIGFkanVzdCA9IGFkanVzdEN5Y2xlcyAqIDQwMDtcbiAgICAgIHplcm9EYXkgKz0gLWFkanVzdEN5Y2xlcyAqIERBWVNfUEVSX0NZQ0xFO1xuICAgIH1cbiAgICB5ZWFyRXN0ID0gTWF0aFV0aWwuaW50RGl2KDQwMCAqIHplcm9EYXkgKyA1OTEsIERBWVNfUEVSX0NZQ0xFKTtcbiAgICBkb3lFc3QgPSB6ZXJvRGF5IC0gKDM2NSAqIHllYXJFc3QgKyBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgNCkgLSBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgMTAwKSArIE1hdGhVdGlsLmludERpdih5ZWFyRXN0LCA0MDApKTtcbiAgICBpZiAoZG95RXN0IDwgMCkge1xuICAgICAgeWVhckVzdC0tO1xuICAgICAgZG95RXN0ID0gemVyb0RheSAtICgzNjUgKiB5ZWFyRXN0ICsgTWF0aFV0aWwuaW50RGl2KHllYXJFc3QsIDQpIC0gTWF0aFV0aWwuaW50RGl2KHllYXJFc3QsIDEwMCkgKyBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgNDAwKSk7XG4gICAgfVxuICAgIHllYXJFc3QgKz0gYWRqdXN0O1xuICAgIHZhciBtYXJjaERveTAgPSBkb3lFc3Q7XG4gICAgdmFyIG1hcmNoTW9udGgwID0gTWF0aFV0aWwuaW50RGl2KG1hcmNoRG95MCAqIDUgKyAyLCAxNTMpO1xuICAgIHZhciBtb250aCA9IChtYXJjaE1vbnRoMCArIDIpICUgMTIgKyAxO1xuICAgIHZhciBkb20gPSBtYXJjaERveTAgLSBNYXRoVXRpbC5pbnREaXYobWFyY2hNb250aDAgKiAzMDYgKyA1LCAxMCkgKyAxO1xuICAgIHllYXJFc3QgKz0gTWF0aFV0aWwuaW50RGl2KG1hcmNoTW9udGgwLCAxMCk7XG4gICAgdmFyIHllYXIgPSB5ZWFyRXN0O1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlKHllYXIsIG1vbnRoLCBkb20pO1xuICB9O1xuICBMb2NhbERhdGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgdmFyIGRhdGUgPSB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpO1xuICAgIGlmIChkYXRlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gTG9jYWxEYXRlIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiLCB0eXBlIFwiICsgKHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG4gIH07XG4gIExvY2FsRGF0ZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEU7XG4gICAgfVxuICAgIGFzc2VydChmb3JtYXR0ZXIgIT0gbnVsbCwgJ2Zvcm1hdHRlcicsIE51bGxQb2ludGVyRXhjZXB0aW9uKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnBhcnNlKHRleHQsIExvY2FsRGF0ZS5GUk9NKTtcbiAgfTtcbiAgTG9jYWxEYXRlLl9yZXNvbHZlUHJldmlvdXNWYWxpZCA9IGZ1bmN0aW9uIF9yZXNvbHZlUHJldmlvdXNWYWxpZCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgc3dpdGNoIChtb250aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksIElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgOTpcbiAgICAgIGNhc2UgMTE6XG4gICAgICAgIGRheSA9IE1hdGgubWluKGRheSwgMzApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZih5ZWFyLCBtb250aCwgZGF5KTtcbiAgfTtcbiAgZnVuY3Rpb24gTG9jYWxEYXRlKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX0Nocm9ub0xvY2FsRGF0ZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmVxdWlyZU5vbk51bGwoeWVhciwgJ3llYXInKTtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZNb250aCwgJ2RheU9mTW9udGgnKTtcbiAgICBpZiAobW9udGggaW5zdGFuY2VvZiBNb250aCkge1xuICAgICAgbW9udGggPSBtb250aC52YWx1ZSgpO1xuICAgIH1cbiAgICBfdGhpcy5feWVhciA9IE1hdGhVdGlsLnNhZmVUb0ludCh5ZWFyKTtcbiAgICBfdGhpcy5fbW9udGggPSBNYXRoVXRpbC5zYWZlVG9JbnQobW9udGgpO1xuICAgIF90aGlzLl9kYXkgPSBNYXRoVXRpbC5zYWZlVG9JbnQoZGF5T2ZNb250aCk7XG4gICAgTG9jYWxEYXRlLl92YWxpZGF0ZShfdGhpcy5feWVhciwgX3RoaXMuX21vbnRoLCBfdGhpcy5fZGF5KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgTG9jYWxEYXRlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIF92YWxpZGF0ZSh5ZWFyLCBtb250aCwgZGF5T2ZNb250aCkge1xuICAgIHZhciBkb207XG4gICAgQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkVmFsdWUoeWVhcik7XG4gICAgQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUi5jaGVja1ZhbGlkVmFsdWUobW9udGgpO1xuICAgIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USC5jaGVja1ZhbGlkVmFsdWUoZGF5T2ZNb250aCk7XG4gICAgaWYgKGRheU9mTW9udGggPiAyOCkge1xuICAgICAgZG9tID0gMzE7XG4gICAgICBzd2l0Y2ggKG1vbnRoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBkb20gPSBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGRvbSA9IDMwO1xuICAgICAgfVxuICAgICAgaWYgKGRheU9mTW9udGggPiBkb20pIHtcbiAgICAgICAgaWYgKGRheU9mTW9udGggPT09IDI5KSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIkludmFsaWQgZGF0ZSAnRmVicnVhcnkgMjknIGFzICdcIiArIHllYXIgKyBcIicgaXMgbm90IGEgbGVhcCB5ZWFyXCIsIERhdGVUaW1lRXhjZXB0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiSW52YWxpZCBkYXRlICdcIiArIHllYXIgKyBcIicgJ1wiICsgbW9udGggKyBcIicgJ1wiICsgZGF5T2ZNb250aCArIFwiJ1wiLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBfcHJvdG8gPSBMb2NhbERhdGUucHJvdG90eXBlO1xuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlLnByb3RvdHlwZS5pc1N1cHBvcnRlZC5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkLmlzRGF0ZUJhc2VkKCkpIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX01PTlRIOlxuICAgICAgICAgICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgdGhpcy5sZW5ndGhPZk1vbnRoKCkpO1xuICAgICAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX1lFQVI6XG4gICAgICAgICAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCB0aGlzLmxlbmd0aE9mWWVhcigpKTtcbiAgICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USDpcbiAgICAgICAgICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIHRoaXMubW9udGgoKSA9PT0gTW9udGguRkVCUlVBUlkgJiYgdGhpcy5pc0xlYXBZZWFyKCkgPT09IGZhbHNlID8gNCA6IDUpO1xuICAgICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feWVhciA8PSAwID8gVmFsdWVSYW5nZS5vZigxLCBZZWFyLk1BWF9WQUxVRSArIDEpIDogVmFsdWVSYW5nZS5vZigxLCBZZWFyLk1BWF9WQUxVRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5yYW5nZVJlZmluZWRCeSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmdldExvbmcoZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBhc3NlcnQoZmllbGQgIT0gbnVsbCwgJycsIE51bGxQb2ludGVyRXhjZXB0aW9uKTtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldDAoZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQuZ2V0RnJvbSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLl9nZXQwID0gZnVuY3Rpb24gX2dldDAoZmllbGQpIHtcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXlPZldlZWsoKS52YWx1ZSgpO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2RheSAtIDEsIDcpICsgMTtcbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50TW9kKHRoaXMuZGF5T2ZZZWFyKCkgLSAxLCA3KSArIDE7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RheTtcbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX1lFQVI6XG4gICAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUE9DSF9EQVk6XG4gICAgICAgIHJldHVybiB0aGlzLnRvRXBvY2hEYXkoKTtcbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX01PTlRIOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX2RheSAtIDEsIDcpICsgMTtcbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVI6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5kYXlPZlllYXIoKSAtIDEsIDcpICsgMTtcbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEg6XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9sZXB0aWNNb250aCgpO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPj0gMSA/IHRoaXMuX3llYXIgOiAxIC0gdGhpcy5feWVhcjtcbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3llYXI7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPj0gMSA/IDEgOiAwO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gIH07XG4gIF9wcm90by5fcHJvbGVwdGljTW9udGggPSBmdW5jdGlvbiBfcHJvbGVwdGljTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXIgKiAxMiArICh0aGlzLl9tb250aCAtIDEpO1xuICB9O1xuICBfcHJvdG8uY2hyb25vbG9neSA9IGZ1bmN0aW9uIGNocm9ub2xvZ3koKSB7XG4gICAgcmV0dXJuIElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gIH07XG4gIF9wcm90by55ZWFyID0gZnVuY3Rpb24geWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhcjtcbiAgfTtcbiAgX3Byb3RvLm1vbnRoVmFsdWUgPSBmdW5jdGlvbiBtb250aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb250aDtcbiAgfTtcbiAgX3Byb3RvLm1vbnRoID0gZnVuY3Rpb24gbW9udGgoKSB7XG4gICAgcmV0dXJuIE1vbnRoLm9mKHRoaXMuX21vbnRoKTtcbiAgfTtcbiAgX3Byb3RvLmRheU9mTW9udGggPSBmdW5jdGlvbiBkYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXk7XG4gIH07XG4gIF9wcm90by5kYXlPZlllYXIgPSBmdW5jdGlvbiBkYXlPZlllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGgoKS5maXJzdERheU9mWWVhcih0aGlzLmlzTGVhcFllYXIoKSkgKyB0aGlzLl9kYXkgLSAxO1xuICB9O1xuICBfcHJvdG8uZGF5T2ZXZWVrID0gZnVuY3Rpb24gZGF5T2ZXZWVrKCkge1xuICAgIHZhciBkb3cwID0gTWF0aFV0aWwuZmxvb3JNb2QodGhpcy50b0Vwb2NoRGF5KCkgKyAzLCA3KTtcbiAgICByZXR1cm4gRGF5T2ZXZWVrLm9mKGRvdzAgKyAxKTtcbiAgfTtcbiAgX3Byb3RvLmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKCkge1xuICAgIHJldHVybiBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIodGhpcy5feWVhcik7XG4gIH07XG4gIF9wcm90by5sZW5ndGhPZk1vbnRoID0gZnVuY3Rpb24gbGVuZ3RoT2ZNb250aCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX21vbnRoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGVhcFllYXIoKSA/IDI5IDogMjg7XG4gICAgICBjYXNlIDQ6XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDk6XG4gICAgICBjYXNlIDExOlxuICAgICAgICByZXR1cm4gMzA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMzE7XG4gICAgfVxuICB9O1xuICBfcHJvdG8ubGVuZ3RoT2ZZZWFyID0gZnVuY3Rpb24gbGVuZ3RoT2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVhcFllYXIoKSA/IDM2NiA6IDM2NTtcbiAgfTtcbiAgX3Byb3RvLl93aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiBfd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuICAgIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsRGF0ZSkge1xuICAgICAgcmV0dXJuIGFkanVzdGVyO1xuICAgIH1cbiAgICByZXR1cm4gX0Nocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGUuX3dpdGhBZGp1c3Rlci5jYWxsKHRoaXMsIGFkanVzdGVyKTtcbiAgfTtcbiAgX3Byb3RvLl93aXRoRmllbGQgPSBmdW5jdGlvbiBfd2l0aEZpZWxkKGZpZWxkLCBuZXdWYWx1ZSkge1xuICAgIGFzc2VydChmaWVsZCAhPSBudWxsLCAnZmllbGQnLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHZhciBmID0gZmllbGQ7XG4gICAgICBmLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICBzd2l0Y2ggKGYpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhuZXdWYWx1ZSAtIHRoaXMuZGF5T2ZXZWVrKCkudmFsdWUoKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhuZXdWYWx1ZSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKG5ld1ZhbHVlIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUikpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoRGF5T2ZNb250aChuZXdWYWx1ZSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aERheU9mWWVhcihuZXdWYWx1ZSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuRVBPQ0hfREFZOlxuICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheShuZXdWYWx1ZSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX01PTlRIOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcyhuZXdWYWx1ZSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfTU9OVEgpKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzV2Vla3MobmV3VmFsdWUgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIpKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhNb250aChuZXdWYWx1ZSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMobmV3VmFsdWUgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFllYXIodGhpcy5feWVhciA+PSAxID8gbmV3VmFsdWUgOiAxIC0gbmV3VmFsdWUpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFllYXIobmV3VmFsdWUpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgPT09IG5ld1ZhbHVlID8gdGhpcyA6IHRoaXMud2l0aFllYXIoMSAtIHRoaXMuX3llYXIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG4gIF9wcm90by53aXRoWWVhciA9IGZ1bmN0aW9uIHdpdGhZZWFyKHllYXIpIHtcbiAgICBpZiAodGhpcy5feWVhciA9PT0geWVhcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZFZhbHVlKHllYXIpO1xuICAgIHJldHVybiBMb2NhbERhdGUuX3Jlc29sdmVQcmV2aW91c1ZhbGlkKHllYXIsIHRoaXMuX21vbnRoLCB0aGlzLl9kYXkpO1xuICB9O1xuICBfcHJvdG8ud2l0aE1vbnRoID0gZnVuY3Rpb24gd2l0aE1vbnRoKG1vbnRoKSB7XG4gICAgdmFyIG0gPSBtb250aCBpbnN0YW5jZW9mIE1vbnRoID8gbW9udGgudmFsdWUoKSA6IG1vbnRoO1xuICAgIGlmICh0aGlzLl9tb250aCA9PT0gbSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIuY2hlY2tWYWxpZFZhbHVlKG0pO1xuICAgIHJldHVybiBMb2NhbERhdGUuX3Jlc29sdmVQcmV2aW91c1ZhbGlkKHRoaXMuX3llYXIsIG0sIHRoaXMuX2RheSk7XG4gIH07XG4gIF9wcm90by53aXRoRGF5T2ZNb250aCA9IGZ1bmN0aW9uIHdpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpIHtcbiAgICBpZiAodGhpcy5fZGF5ID09PSBkYXlPZk1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZih0aGlzLl95ZWFyLCB0aGlzLl9tb250aCwgZGF5T2ZNb250aCk7XG4gIH07XG4gIF9wcm90by53aXRoRGF5T2ZZZWFyID0gZnVuY3Rpb24gd2l0aERheU9mWWVhcihkYXlPZlllYXIpIHtcbiAgICBpZiAodGhpcy5kYXlPZlllYXIoKSA9PT0gZGF5T2ZZZWFyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZlllYXJEYXkodGhpcy5feWVhciwgZGF5T2ZZZWFyKTtcbiAgfTtcbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvQWRkLCAnYW1vdW50VG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5EQVlTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LldFRUtTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcyhhbW91bnRUb0FkZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NT05USFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01vbnRocyhhbW91bnRUb0FkZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ZRUFSUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoYW1vdW50VG9BZGQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuREVDQURFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCAxMCkpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuQ0VOVFVSSUVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwMCkpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTEVOTklBOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwMDApKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkVSQVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aChDaHJvbm9GaWVsZC5FUkEsIE1hdGhVdGlsLnNhZmVBZGQodGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSksIGFtb3VudFRvQWRkKSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnNUb0FkZCkge1xuICAgIGlmICh5ZWFyc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld1llYXIgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZSh0aGlzLl95ZWFyICsgeWVhcnNUb0FkZCk7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5fcmVzb2x2ZVByZXZpb3VzVmFsaWQobmV3WWVhciwgdGhpcy5fbW9udGgsIHRoaXMuX2RheSk7XG4gIH07XG4gIF9wcm90by5wbHVzTW9udGhzID0gZnVuY3Rpb24gcGx1c01vbnRocyhtb250aHNUb0FkZCkge1xuICAgIGlmIChtb250aHNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBtb250aENvdW50ID0gdGhpcy5feWVhciAqIDEyICsgKHRoaXMuX21vbnRoIC0gMSk7XG4gICAgdmFyIGNhbGNNb250aHMgPSBtb250aENvdW50ICsgbW9udGhzVG9BZGQ7XG4gICAgdmFyIG5ld1llYXIgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShNYXRoVXRpbC5mbG9vckRpdihjYWxjTW9udGhzLCAxMikpO1xuICAgIHZhciBuZXdNb250aCA9IE1hdGhVdGlsLmZsb29yTW9kKGNhbGNNb250aHMsIDEyKSArIDE7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5fcmVzb2x2ZVByZXZpb3VzVmFsaWQobmV3WWVhciwgbmV3TW9udGgsIHRoaXMuX2RheSk7XG4gIH07XG4gIF9wcm90by5wbHVzV2Vla3MgPSBmdW5jdGlvbiBwbHVzV2Vla3Mod2Vla3NUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKE1hdGhVdGlsLnNhZmVNdWx0aXBseSh3ZWVrc1RvQWRkLCA3KSk7XG4gIH07XG4gIF9wcm90by5wbHVzRGF5cyA9IGZ1bmN0aW9uIHBsdXNEYXlzKGRheXNUb0FkZCkge1xuICAgIGlmIChkYXlzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbWpEYXkgPSBNYXRoVXRpbC5zYWZlQWRkKHRoaXMudG9FcG9jaERheSgpLCBkYXlzVG9BZGQpO1xuICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheShtakRheSk7XG4gIH07XG4gIF9wcm90by5fbWludXNVbml0ID0gZnVuY3Rpb24gX21pbnVzVW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9TdWJ0cmFjdCwgJ2Ftb3VudFRvU3VidHJhY3QnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJldHVybiB0aGlzLl9wbHVzVW5pdCgtMSAqIGFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNZZWFycyA9IGZ1bmN0aW9uIG1pbnVzWWVhcnMoeWVhcnNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKHllYXJzVG9TdWJ0cmFjdCAqIC0xKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTW9udGhzID0gZnVuY3Rpb24gbWludXNNb250aHMobW9udGhzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMobW9udGhzVG9TdWJ0cmFjdCAqIC0xKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzV2Vla3MgPSBmdW5jdGlvbiBtaW51c1dlZWtzKHdlZWtzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcyh3ZWVrc1RvU3VidHJhY3QgKiAtMSk7XG4gIH07XG4gIF9wcm90by5taW51c0RheXMgPSBmdW5jdGlvbiBtaW51c0RheXMoZGF5c1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhkYXlzVG9TdWJ0cmFjdCAqIC0xKTtcbiAgfTtcbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gX0Nocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gX0Nocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGUuYWRqdXN0SW50by5jYWxsKHRoaXMsIHRlbXBvcmFsKTtcbiAgfTtcbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwocDEsIHAyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdGhpcy51bnRpbDEocDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bnRpbDIocDEsIHAyKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by51bnRpbDIgPSBmdW5jdGlvbiB1bnRpbDIoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgdmFyIGVuZCA9IExvY2FsRGF0ZS5mcm9tKGVuZEV4Y2x1c2l2ZSk7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRBWVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF5c1VudGlsKGVuZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5XRUVLUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuZGF5c1VudGlsKGVuZCksIDcpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTU9OVEhTOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNVbnRpbChlbmQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuWUVBUlM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9tb250aHNVbnRpbChlbmQpLCAxMik7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ERUNBREVTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbW9udGhzVW50aWwoZW5kKSwgMTIwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkNFTlRVUklFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX21vbnRoc1VudGlsKGVuZCksIDEyMDApO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTEVOTklBOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbW9udGhzVW50aWwoZW5kKSwgMTIwMDApO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuRVJBUzpcbiAgICAgICAgICByZXR1cm4gZW5kLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgdW5pdDogXCIgKyB1bml0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuICBfcHJvdG8uZGF5c1VudGlsID0gZnVuY3Rpb24gZGF5c1VudGlsKGVuZCkge1xuICAgIHJldHVybiBlbmQudG9FcG9jaERheSgpIC0gdGhpcy50b0Vwb2NoRGF5KCk7XG4gIH07XG4gIF9wcm90by5fbW9udGhzVW50aWwgPSBmdW5jdGlvbiBfbW9udGhzVW50aWwoZW5kKSB7XG4gICAgdmFyIHBhY2tlZDEgPSB0aGlzLl9wcm9sZXB0aWNNb250aCgpICogMzIgKyB0aGlzLmRheU9mTW9udGgoKTtcbiAgICB2YXIgcGFja2VkMiA9IGVuZC5fcHJvbGVwdGljTW9udGgoKSAqIDMyICsgZW5kLmRheU9mTW9udGgoKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHBhY2tlZDIgLSBwYWNrZWQxLCAzMik7XG4gIH07XG4gIF9wcm90by51bnRpbDEgPSBmdW5jdGlvbiB1bnRpbDEoZW5kRGF0ZSkge1xuICAgIHZhciBlbmQgPSBMb2NhbERhdGUuZnJvbShlbmREYXRlKTtcbiAgICB2YXIgdG90YWxNb250aHMgPSBlbmQuX3Byb2xlcHRpY01vbnRoKCkgLSB0aGlzLl9wcm9sZXB0aWNNb250aCgpO1xuICAgIHZhciBkYXlzID0gZW5kLl9kYXkgLSB0aGlzLl9kYXk7XG4gICAgaWYgKHRvdGFsTW9udGhzID4gMCAmJiBkYXlzIDwgMCkge1xuICAgICAgdG90YWxNb250aHMtLTtcbiAgICAgIHZhciBjYWxjRGF0ZSA9IHRoaXMucGx1c01vbnRocyh0b3RhbE1vbnRocyk7XG4gICAgICBkYXlzID0gZW5kLnRvRXBvY2hEYXkoKSAtIGNhbGNEYXRlLnRvRXBvY2hEYXkoKTtcbiAgICB9IGVsc2UgaWYgKHRvdGFsTW9udGhzIDwgMCAmJiBkYXlzID4gMCkge1xuICAgICAgdG90YWxNb250aHMrKztcbiAgICAgIGRheXMgLT0gZW5kLmxlbmd0aE9mTW9udGgoKTtcbiAgICB9XG4gICAgdmFyIHllYXJzID0gTWF0aFV0aWwuaW50RGl2KHRvdGFsTW9udGhzLCAxMik7XG4gICAgdmFyIG1vbnRocyA9IE1hdGhVdGlsLmludE1vZCh0b3RhbE1vbnRocywgMTIpO1xuICAgIHJldHVybiBQZXJpb2Qub2YoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gIH07XG4gIF9wcm90by5hdFRpbWUgPSBmdW5jdGlvbiBhdFRpbWUoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0VGltZTEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYXRUaW1lNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLmF0VGltZTEgPSBmdW5jdGlvbiBhdFRpbWUxKHRpbWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0aW1lLCAndGltZScpO1xuICAgIGlmICh0aW1lIGluc3RhbmNlb2YgTG9jYWxUaW1lKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5vZih0aGlzLCB0aW1lKTtcbiAgICB9IGVsc2UgaWYgKHRpbWUgaW5zdGFuY2VvZiBPZmZzZXRUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXRUaW1lT2Zmc2V0VGltZSh0aW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcInRpbWUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBMb2NhbFRpbWUgb3IgT2Zmc2V0VGltZVwiICsgKHRpbWUgJiYgdGltZS5jb25zdHJ1Y3RvciAmJiB0aW1lLmNvbnN0cnVjdG9yLm5hbWUgPyBcIiwgYnV0IGlzIFwiICsgdGltZS5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG4gIH07XG4gIF9wcm90by5hdFRpbWU0ID0gZnVuY3Rpb24gYXRUaW1lNChob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKHNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBzZWNvbmQgPSAwO1xuICAgIH1cbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmF0VGltZTEoTG9jYWxUaW1lLm9mKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vT2ZTZWNvbmQpKTtcbiAgfTtcbiAgX3Byb3RvLl9hdFRpbWVPZmZzZXRUaW1lID0gZnVuY3Rpb24gX2F0VGltZU9mZnNldFRpbWUodGltZSkge1xuICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZihMb2NhbERhdGVUaW1lLm9mKHRoaXMsIHRpbWUudG9Mb2NhbFRpbWUoKSksIHRpbWUub2Zmc2V0KCkpO1xuICB9O1xuICBfcHJvdG8uYXRTdGFydE9mRGF5ID0gZnVuY3Rpb24gYXRTdGFydE9mRGF5KHpvbmUpIHtcbiAgICBpZiAoem9uZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXRTdGFydE9mRGF5V2l0aFpvbmUoem9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mKHRoaXMsIExvY2FsVGltZS5NSUROSUdIVCk7XG4gICAgfVxuICB9O1xuICBfcHJvdG8uX2F0U3RhcnRPZkRheVdpdGhab25lID0gZnVuY3Rpb24gX2F0U3RhcnRPZkRheVdpdGhab25lKHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHZhciBsZHQgPSB0aGlzLmF0VGltZShMb2NhbFRpbWUuTUlETklHSFQpO1xuICAgIGlmICh6b25lIGluc3RhbmNlb2YgWm9uZU9mZnNldCA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciB0cmFucyA9IHpvbmUucnVsZXMoKS50cmFuc2l0aW9uKGxkdCk7XG4gICAgICBpZiAodHJhbnMgIT0gbnVsbCAmJiB0cmFucy5pc0dhcCgpKSB7XG4gICAgICAgIGxkdCA9IHRyYW5zLmRhdGVUaW1lQWZ0ZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2YobGR0LCB6b25lKTtcbiAgfTtcbiAgX3Byb3RvLnRvRXBvY2hEYXkgPSBmdW5jdGlvbiB0b0Vwb2NoRGF5KCkge1xuICAgIHZhciB5ID0gdGhpcy5feWVhcjtcbiAgICB2YXIgbSA9IHRoaXMuX21vbnRoO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdG90YWwgKz0gMzY1ICogeTtcbiAgICBpZiAoeSA+PSAwKSB7XG4gICAgICB0b3RhbCArPSBNYXRoVXRpbC5pbnREaXYoeSArIDMsIDQpIC0gTWF0aFV0aWwuaW50RGl2KHkgKyA5OSwgMTAwKSArIE1hdGhVdGlsLmludERpdih5ICsgMzk5LCA0MDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3RhbCAtPSBNYXRoVXRpbC5pbnREaXYoeSwgLTQpIC0gTWF0aFV0aWwuaW50RGl2KHksIC0xMDApICsgTWF0aFV0aWwuaW50RGl2KHksIC00MDApO1xuICAgIH1cbiAgICB0b3RhbCArPSBNYXRoVXRpbC5pbnREaXYoMzY3ICogbSAtIDM2MiwgMTIpO1xuICAgIHRvdGFsICs9IHRoaXMuZGF5T2ZNb250aCgpIC0gMTtcbiAgICBpZiAobSA+IDIpIHtcbiAgICAgIHRvdGFsLS07XG4gICAgICBpZiAoIUlzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5KSkge1xuICAgICAgICB0b3RhbC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWwgLSBEQVlTXzAwMDBfVE9fMTk3MDtcbiAgfTtcbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIExvY2FsRGF0ZSwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBhcmVUbzAob3RoZXIpO1xuICB9O1xuICBfcHJvdG8uX2NvbXBhcmVUbzAgPSBmdW5jdGlvbiBfY29tcGFyZVRvMChvdGhlckRhdGUpIHtcbiAgICB2YXIgY21wID0gdGhpcy5feWVhciAtIG90aGVyRGF0ZS5feWVhcjtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICBjbXAgPSB0aGlzLl9tb250aCAtIG90aGVyRGF0ZS5fbW9udGg7XG4gICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgIGNtcCA9IHRoaXMuX2RheSAtIG90aGVyRGF0ZS5fZGF5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY21wO1xuICB9O1xuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID4gMDtcbiAgfTtcbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpIDwgMDtcbiAgfTtcbiAgX3Byb3RvLmlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIExvY2FsRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbXBhcmVUbzAob3RoZXIpID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHZhciB5ZWFyVmFsdWUgPSB0aGlzLl95ZWFyO1xuICAgIHZhciBtb250aFZhbHVlID0gdGhpcy5fbW9udGg7XG4gICAgdmFyIGRheVZhbHVlID0gdGhpcy5fZGF5O1xuICAgIHJldHVybiBNYXRoVXRpbC5oYXNoKHllYXJWYWx1ZSAmIDB4RkZGRkY4MDAgXiAoeWVhclZhbHVlIDw8IDExKSArIChtb250aFZhbHVlIDw8IDYpICsgZGF5VmFsdWUpO1xuICB9O1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgZGF5U3RyaW5nLCBtb250aFN0cmluZywgeWVhclN0cmluZztcbiAgICB2YXIgeWVhclZhbHVlID0gdGhpcy5feWVhcjtcbiAgICB2YXIgbW9udGhWYWx1ZSA9IHRoaXMuX21vbnRoO1xuICAgIHZhciBkYXlWYWx1ZSA9IHRoaXMuX2RheTtcbiAgICB2YXIgYWJzWWVhciA9IE1hdGguYWJzKHllYXJWYWx1ZSk7XG4gICAgaWYgKGFic1llYXIgPCAxMDAwKSB7XG4gICAgICBpZiAoeWVhclZhbHVlIDwgMCkge1xuICAgICAgICB5ZWFyU3RyaW5nID0gXCItXCIgKyAoXCJcIiArICh5ZWFyVmFsdWUgLSAxMDAwMCkpLnNsaWNlKC00KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHllYXJTdHJpbmcgPSAoXCJcIiArICh5ZWFyVmFsdWUgKyAxMDAwMCkpLnNsaWNlKC00KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHllYXJWYWx1ZSA+IDk5OTkpIHtcbiAgICAgICAgeWVhclN0cmluZyA9IFwiK1wiICsgeWVhclZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhclN0cmluZyA9IFwiXCIgKyB5ZWFyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb250aFZhbHVlIDwgMTApIHtcbiAgICAgIG1vbnRoU3RyaW5nID0gXCItMFwiICsgbW9udGhWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9udGhTdHJpbmcgPSBcIi1cIiArIG1vbnRoVmFsdWU7XG4gICAgfVxuICAgIGlmIChkYXlWYWx1ZSA8IDEwKSB7XG4gICAgICBkYXlTdHJpbmcgPSBcIi0wXCIgKyBkYXlWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF5U3RyaW5nID0gXCItXCIgKyBkYXlWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHllYXJTdHJpbmcgKyBtb250aFN0cmluZyArIGRheVN0cmluZztcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmb3JtYXR0ZXIsIERhdGVUaW1lRm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGUucHJvdG90eXBlLmZvcm1hdC5jYWxsKHRoaXMsIGZvcm1hdHRlcik7XG4gIH07XG4gIHJldHVybiBMb2NhbERhdGU7XG59KENocm9ub0xvY2FsRGF0ZSk7XG5mdW5jdGlvbiBfaW5pdCQ1KCkge1xuICBMb2NhbERhdGUuTUlOID0gTG9jYWxEYXRlLm9mKFllYXJDb25zdGFudHMuTUlOX1ZBTFVFLCAxLCAxKTtcbiAgTG9jYWxEYXRlLk1BWCA9IExvY2FsRGF0ZS5vZihZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSwgMTIsIDMxKTtcbiAgTG9jYWxEYXRlLkVQT0NIXzAgPSBMb2NhbERhdGUub2ZFcG9jaERheSgwKTtcbiAgTG9jYWxEYXRlLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMb2NhbERhdGUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgQ2hyb25vTG9jYWxEYXRlVGltZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hyb25vTG9jYWxEYXRlVGltZSwgX1RlbXBvcmFsKTtcbiAgZnVuY3Rpb24gQ2hyb25vTG9jYWxEYXRlVGltZSgpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gQ2hyb25vTG9jYWxEYXRlVGltZS5wcm90b3R5cGU7XG4gIF9wcm90by5jaHJvbm9sb2d5ID0gZnVuY3Rpb24gY2hyb25vbG9neSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0xvY2FsRGF0ZSgpLmNocm9ub2xvZ3koKTtcbiAgfTtcbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hyb25vbG9neSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBDaHJvbm9Vbml0Lk5BTk9TO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheSh0aGlzLnRvTG9jYWxEYXRlKCkudG9FcG9jaERheSgpKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0xvY2FsVGltZSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5FUE9DSF9EQVksIHRoaXMudG9Mb2NhbERhdGUoKS50b0Vwb2NoRGF5KCkpLndpdGgoQ2hyb25vRmllbGQuTkFOT19PRl9EQVksIHRoaXMudG9Mb2NhbFRpbWUoKS50b05hbm9PZkRheSgpKTtcbiAgfTtcbiAgX3Byb3RvLnRvSW5zdGFudCA9IGZ1bmN0aW9uIHRvSW5zdGFudChvZmZzZXQpIHtcbiAgICByZXF1aXJlSW5zdGFuY2Uob2Zmc2V0LCBab25lT2Zmc2V0LCAnem9uZUlkJyk7XG4gICAgcmV0dXJuIEluc3RhbnQub2ZFcG9jaFNlY29uZCh0aGlzLnRvRXBvY2hTZWNvbmQob2Zmc2V0KSwgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSk7XG4gIH07XG4gIF9wcm90by50b0Vwb2NoU2Vjb25kID0gZnVuY3Rpb24gdG9FcG9jaFNlY29uZChvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICB2YXIgZXBvY2hEYXkgPSB0aGlzLnRvTG9jYWxEYXRlKCkudG9FcG9jaERheSgpO1xuICAgIHZhciBzZWNzID0gZXBvY2hEYXkgKiA4NjQwMCArIHRoaXMudG9Mb2NhbFRpbWUoKS50b1NlY29uZE9mRGF5KCk7XG4gICAgc2VjcyAtPSBvZmZzZXQudG90YWxTZWNvbmRzKCk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVUb0ludChzZWNzKTtcbiAgfTtcbiAgcmV0dXJuIENocm9ub0xvY2FsRGF0ZVRpbWU7XG59KFRlbXBvcmFsKTtcblxudmFyIExvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiAoX0Nocm9ub0xvY2FsRGF0ZVRpbWUpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9jYWxEYXRlVGltZSwgX0Nocm9ub0xvY2FsRGF0ZVRpbWUpO1xuICBMb2NhbERhdGVUaW1lLm5vdyA9IGZ1bmN0aW9uIG5vdyhjbG9ja09yWm9uZSkge1xuICAgIGlmIChjbG9ja09yWm9uZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5fbm93KENsb2NrLnN5c3RlbURlZmF1bHRab25lKCkpO1xuICAgIH0gZWxzZSBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBDbG9jaykge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUuX25vdyhjbG9ja09yWm9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLl9ub3coQ2xvY2suc3lzdGVtKGNsb2NrT3Jab25lKSk7XG4gICAgfVxuICB9O1xuICBMb2NhbERhdGVUaW1lLl9ub3cgPSBmdW5jdGlvbiBfbm93KGNsb2NrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoY2xvY2ssICdjbG9jaycpO1xuICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mSW5zdGFudChjbG9jay5pbnN0YW50KCksIGNsb2NrLnpvbmUoKSk7XG4gIH07XG4gIExvY2FsRGF0ZVRpbWUuX29mRXBvY2hNaWxsaXMgPSBmdW5jdGlvbiBfb2ZFcG9jaE1pbGxpcyhlcG9jaE1pbGxpLCBvZmZzZXQpIHtcbiAgICB2YXIgbG9jYWxTZWNvbmQgPSBNYXRoVXRpbC5mbG9vckRpdihlcG9jaE1pbGxpLCAxMDAwKSArIG9mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICB2YXIgbG9jYWxFcG9jaERheSA9IE1hdGhVdGlsLmZsb29yRGl2KGxvY2FsU2Vjb25kLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICB2YXIgc2Vjc09mRGF5ID0gTWF0aFV0aWwuZmxvb3JNb2QobG9jYWxTZWNvbmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHZhciBuYW5vT2ZTZWNvbmQgPSBNYXRoVXRpbC5mbG9vck1vZChlcG9jaE1pbGxpLCAxMDAwKSAqIDEwMDAwMDA7XG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2ZFcG9jaERheShsb2NhbEVwb2NoRGF5KTtcbiAgICB2YXIgdGltZSA9IExvY2FsVGltZS5vZlNlY29uZE9mRGF5KHNlY3NPZkRheSwgbmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gbmV3IExvY2FsRGF0ZVRpbWUoZGF0ZSwgdGltZSk7XG4gIH07XG4gIExvY2FsRGF0ZVRpbWUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5vZkRhdGVBbmRUaW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mTnVtYmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgTG9jYWxEYXRlVGltZS5vZk51bWJlcnMgPSBmdW5jdGlvbiBvZk51bWJlcnMoeWVhciwgbW9udGgsIGRheU9mTW9udGgsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vT2ZTZWNvbmQpIHtcbiAgICBpZiAoaG91ciA9PT0gdm9pZCAwKSB7XG4gICAgICBob3VyID0gMDtcbiAgICB9XG4gICAgaWYgKG1pbnV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW51dGUgPSAwO1xuICAgIH1cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZCA9IDA7XG4gICAgfVxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2YoeWVhciwgbW9udGgsIGRheU9mTW9udGgpO1xuICAgIHZhciB0aW1lID0gTG9jYWxUaW1lLm9mKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlVGltZShkYXRlLCB0aW1lKTtcbiAgfTtcbiAgTG9jYWxEYXRlVGltZS5vZkRhdGVBbmRUaW1lID0gZnVuY3Rpb24gb2ZEYXRlQW5kVGltZShkYXRlLCB0aW1lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF0ZSwgJ2RhdGUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh0aW1lLCAndGltZScpO1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlVGltZShkYXRlLCB0aW1lKTtcbiAgfTtcbiAgTG9jYWxEYXRlVGltZS5vZkluc3RhbnQgPSBmdW5jdGlvbiBvZkluc3RhbnQoaW5zdGFudCwgem9uZSkge1xuICAgIGlmICh6b25lID09PSB2b2lkIDApIHtcbiAgICAgIHpvbmUgPSBab25lSWQuc3lzdGVtRGVmYXVsdCgpO1xuICAgIH1cbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShpbnN0YW50LCBJbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZChpbnN0YW50LmVwb2NoU2Vjb25kKCksIGluc3RhbnQubmFubygpLCBvZmZzZXQpO1xuICB9O1xuICBMb2NhbERhdGVUaW1lLm9mRXBvY2hTZWNvbmQgPSBmdW5jdGlvbiBvZkVwb2NoU2Vjb25kKGVwb2NoU2Vjb25kLCBuYW5vT2ZTZWNvbmQsIG9mZnNldCkge1xuICAgIGlmIChlcG9jaFNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBlcG9jaFNlY29uZCA9IDA7XG4gICAgfVxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgbmFub09mU2Vjb25kIGluc3RhbmNlb2YgWm9uZU9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbmFub09mU2Vjb25kO1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgdmFyIGxvY2FsU2Vjb25kID0gZXBvY2hTZWNvbmQgKyBvZmZzZXQudG90YWxTZWNvbmRzKCk7XG4gICAgdmFyIGxvY2FsRXBvY2hEYXkgPSBNYXRoVXRpbC5mbG9vckRpdihsb2NhbFNlY29uZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSk7XG4gICAgdmFyIHNlY3NPZkRheSA9IE1hdGhVdGlsLmZsb29yTW9kKGxvY2FsU2Vjb25kLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICB2YXIgZGF0ZSA9IExvY2FsRGF0ZS5vZkVwb2NoRGF5KGxvY2FsRXBvY2hEYXkpO1xuICAgIHZhciB0aW1lID0gTG9jYWxUaW1lLm9mU2Vjb25kT2ZEYXkoc2Vjc09mRGF5LCBuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlVGltZShkYXRlLCB0aW1lKTtcbiAgfTtcbiAgTG9jYWxEYXRlVGltZS5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfSBlbHNlIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbC50b0xvY2FsRGF0ZVRpbWUoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkYXRlID0gTG9jYWxEYXRlLmZyb20odGVtcG9yYWwpO1xuICAgICAgdmFyIHRpbWUgPSBMb2NhbFRpbWUuZnJvbSh0ZW1wb3JhbCk7XG4gICAgICByZXR1cm4gbmV3IExvY2FsRGF0ZVRpbWUoZGF0ZSwgdGltZSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gTG9jYWxEYXRlVGltZSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgfTtcbiAgTG9jYWxEYXRlVGltZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEVfVElNRTtcbiAgICB9XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBMb2NhbERhdGVUaW1lLkZST00pO1xuICB9O1xuICBmdW5jdGlvbiBMb2NhbERhdGVUaW1lKGRhdGUsIHRpbWUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfQ2hyb25vTG9jYWxEYXRlVGltZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmVxdWlyZUluc3RhbmNlKGRhdGUsIExvY2FsRGF0ZSwgJ2RhdGUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodGltZSwgTG9jYWxUaW1lLCAndGltZScpO1xuICAgIF90aGlzLl9kYXRlID0gZGF0ZTtcbiAgICBfdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBMb2NhbERhdGVUaW1lLnByb3RvdHlwZTtcbiAgX3Byb3RvLl93aXRoRGF0ZVRpbWUgPSBmdW5jdGlvbiBfd2l0aERhdGVUaW1lKG5ld0RhdGUsIG5ld1RpbWUpIHtcbiAgICBpZiAodGhpcy5fZGF0ZS5lcXVhbHMobmV3RGF0ZSkgJiYgdGhpcy5fdGltZS5lcXVhbHMobmV3VGltZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExvY2FsRGF0ZVRpbWUobmV3RGF0ZSwgbmV3VGltZSk7XG4gIH07XG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5pc1RpbWVCYXNlZCgpID8gdGhpcy5fdGltZS5yYW5nZShmaWVsZCkgOiB0aGlzLl9kYXRlLnJhbmdlKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5pc1RpbWVCYXNlZCgpID8gdGhpcy5fdGltZS5nZXQoZmllbGQpIDogdGhpcy5fZGF0ZS5nZXQoZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gX0Nocm9ub0xvY2FsRGF0ZVRpbWUucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuaXNUaW1lQmFzZWQoKSA/IHRoaXMuX3RpbWUuZ2V0TG9uZyhmaWVsZCkgOiB0aGlzLl9kYXRlLmdldExvbmcoZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGQuZ2V0RnJvbSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnllYXIgPSBmdW5jdGlvbiB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnllYXIoKTtcbiAgfTtcbiAgX3Byb3RvLm1vbnRoVmFsdWUgPSBmdW5jdGlvbiBtb250aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLm1vbnRoVmFsdWUoKTtcbiAgfTtcbiAgX3Byb3RvLm1vbnRoID0gZnVuY3Rpb24gbW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUubW9udGgoKTtcbiAgfTtcbiAgX3Byb3RvLmRheU9mTW9udGggPSBmdW5jdGlvbiBkYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLmRheU9mTW9udGgoKTtcbiAgfTtcbiAgX3Byb3RvLmRheU9mWWVhciA9IGZ1bmN0aW9uIGRheU9mWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5kYXlPZlllYXIoKTtcbiAgfTtcbiAgX3Byb3RvLmRheU9mV2VlayA9IGZ1bmN0aW9uIGRheU9mV2VlaygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS5kYXlPZldlZWsoKTtcbiAgfTtcbiAgX3Byb3RvLmhvdXIgPSBmdW5jdGlvbiBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLmhvdXIoKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnV0ZSA9IGZ1bmN0aW9uIG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS5taW51dGUoKTtcbiAgfTtcbiAgX3Byb3RvLnNlY29uZCA9IGZ1bmN0aW9uIHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS5zZWNvbmQoKTtcbiAgfTtcbiAgX3Byb3RvLm5hbm8gPSBmdW5jdGlvbiBuYW5vKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLm5hbm8oKTtcbiAgfTtcbiAgX3Byb3RvLl93aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiBfd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuICAgIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZShhZGp1c3RlciwgdGhpcy5fdGltZSk7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLCBhZGp1c3Rlcik7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiBhZGp1c3RlcjtcbiAgICB9XG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGVUaW1lLnByb3RvdHlwZS5fd2l0aEFkanVzdGVyLmNhbGwodGhpcywgYWRqdXN0ZXIpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQuaXNUaW1lQmFzZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUsIHRoaXMuX3RpbWUud2l0aChmaWVsZCwgbmV3VmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS53aXRoKGZpZWxkLCBuZXdWYWx1ZSksIHRoaXMuX3RpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG4gIF9wcm90by53aXRoWWVhciA9IGZ1bmN0aW9uIHdpdGhZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUud2l0aFllYXIoeWVhciksIHRoaXMuX3RpbWUpO1xuICB9O1xuICBfcHJvdG8ud2l0aE1vbnRoID0gZnVuY3Rpb24gd2l0aE1vbnRoKG1vbnRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLndpdGhNb250aChtb250aCksIHRoaXMuX3RpbWUpO1xuICB9O1xuICBfcHJvdG8ud2l0aERheU9mTW9udGggPSBmdW5jdGlvbiB3aXRoRGF5T2ZNb250aChkYXlPZk1vbnRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLndpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpLCB0aGlzLl90aW1lKTtcbiAgfTtcbiAgX3Byb3RvLndpdGhEYXlPZlllYXIgPSBmdW5jdGlvbiB3aXRoRGF5T2ZZZWFyKGRheU9mWWVhcikge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS53aXRoRGF5T2ZZZWFyKGRheU9mWWVhciksIHRoaXMuX3RpbWUpO1xuICB9O1xuICBfcHJvdG8ud2l0aEhvdXIgPSBmdW5jdGlvbiB3aXRoSG91cihob3VyKSB7XG4gICAgdmFyIG5ld1RpbWUgPSB0aGlzLl90aW1lLndpdGhIb3VyKGhvdXIpO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG4gIF9wcm90by53aXRoTWludXRlID0gZnVuY3Rpb24gd2l0aE1pbnV0ZShtaW51dGUpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuX3RpbWUud2l0aE1pbnV0ZShtaW51dGUpO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuX3RpbWUud2l0aFNlY29uZChzZWNvbmQpO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG4gIF9wcm90by53aXRoTmFubyA9IGZ1bmN0aW9uIHdpdGhOYW5vKG5hbm9PZlNlY29uZCkge1xuICAgIHZhciBuZXdUaW1lID0gdGhpcy5fdGltZS53aXRoTmFubyhuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG4gIF9wcm90by50cnVuY2F0ZWRUbyA9IGZ1bmN0aW9uIHRydW5jYXRlZFRvKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUsIHRoaXMuX3RpbWUudHJ1bmNhdGVkVG8odW5pdCkpO1xuICB9O1xuICBfcHJvdG8uX3BsdXNVbml0ID0gZnVuY3Rpb24gX3BsdXNVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTkFOT1M6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhNYXRoVXRpbC5pbnREaXYoYW1vdW50VG9BZGQsIExvY2FsVGltZS5NSUNST1NfUEVSX0RBWSkpLnBsdXNOYW5vcyhNYXRoVXRpbC5pbnRNb2QoYW1vdW50VG9BZGQsIExvY2FsVGltZS5NSUNST1NfUEVSX0RBWSkgKiAxMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExJUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhNYXRoVXRpbC5pbnREaXYoYW1vdW50VG9BZGQsIExvY2FsVGltZS5NSUxMSVNfUEVSX0RBWSkpLnBsdXNOYW5vcyhNYXRoVXRpbC5pbnRNb2QoYW1vdW50VG9BZGQsIExvY2FsVGltZS5NSUxMSVNfUEVSX0RBWSkgKiAxMDAwMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoYW1vdW50VG9BZGQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTWludXRlcyhhbW91bnRUb0FkZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IT1VSUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzSG91cnMoYW1vdW50VG9BZGQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgMjU2KSkucGx1c0hvdXJzKE1hdGhVdGlsLmludE1vZChhbW91bnRUb0FkZCwgMjU2KSAqIDEyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS5wbHVzKGFtb3VudFRvQWRkLCB1bml0KSwgdGhpcy5fdGltZSk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFycykge1xuICAgIHZhciBuZXdEYXRlID0gdGhpcy5fZGF0ZS5wbHVzWWVhcnMoeWVhcnMpO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gIH07XG4gIF9wcm90by5wbHVzTW9udGhzID0gZnVuY3Rpb24gcGx1c01vbnRocyhtb250aHMpIHtcbiAgICB2YXIgbmV3RGF0ZSA9IHRoaXMuX2RhdGUucGx1c01vbnRocyhtb250aHMpO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gIH07XG4gIF9wcm90by5wbHVzV2Vla3MgPSBmdW5jdGlvbiBwbHVzV2Vla3Mod2Vla3MpIHtcbiAgICB2YXIgbmV3RGF0ZSA9IHRoaXMuX2RhdGUucGx1c1dlZWtzKHdlZWtzKTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKG5ld0RhdGUsIHRoaXMuX3RpbWUpO1xuICB9O1xuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzKSB7XG4gICAgdmFyIG5ld0RhdGUgPSB0aGlzLl9kYXRlLnBsdXNEYXlzKGRheXMpO1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gIH07XG4gIF9wcm90by5wbHVzSG91cnMgPSBmdW5jdGlvbiBwbHVzSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCBob3VycywgMCwgMCwgMCwgMSk7XG4gIH07XG4gIF9wcm90by5wbHVzTWludXRlcyA9IGZ1bmN0aW9uIHBsdXNNaW51dGVzKG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCAwLCBtaW51dGVzLCAwLCAwLCAxKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNTZWNvbmRzID0gZnVuY3Rpb24gcGx1c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIDAsIDAsIHNlY29uZHMsIDAsIDEpO1xuICB9O1xuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgMCwgMCwgMCwgbmFub3MsIDEpO1xuICB9O1xuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG4gIF9wcm90by5taW51c1llYXJzID0gZnVuY3Rpb24gbWludXNZZWFycyh5ZWFycykge1xuICAgIHJldHVybiB0aGlzLnBsdXNZZWFycygtMSAqIHllYXJzKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTW9udGhzID0gZnVuY3Rpb24gbWludXNNb250aHMobW9udGhzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c01vbnRocygtMSAqIG1vbnRocyk7XG4gIH07XG4gIF9wcm90by5taW51c1dlZWtzID0gZnVuY3Rpb24gbWludXNXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcygtMSAqIHdlZWtzKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzRGF5cyA9IGZ1bmN0aW9uIG1pbnVzRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c0RheXMoLTEgKiBkYXlzKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzSG91cnMgPSBmdW5jdGlvbiBtaW51c0hvdXJzKGhvdXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgaG91cnMsIDAsIDAsIDAsIC0xKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTWludXRlcyA9IGZ1bmN0aW9uIG1pbnVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgMCwgbWludXRlcywgMCwgMCwgLTEpO1xuICB9O1xuICBfcHJvdG8ubWludXNTZWNvbmRzID0gZnVuY3Rpb24gbWludXNTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCAwLCAwLCBzZWNvbmRzLCAwLCAtMSk7XG4gIH07XG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vcykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIDAsIDAsIDAsIG5hbm9zLCAtMSk7XG4gIH07XG4gIF9wcm90by5fcGx1c1dpdGhPdmVyZmxvdyA9IGZ1bmN0aW9uIF9wbHVzV2l0aE92ZXJmbG93KG5ld0RhdGUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBuYW5vcywgc2lnbikge1xuICAgIGlmIChob3VycyA9PT0gMCAmJiBtaW51dGVzID09PSAwICYmIHNlY29uZHMgPT09IDAgJiYgbmFub3MgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gICAgfVxuICAgIHZhciB0b3REYXlzID0gTWF0aFV0aWwuaW50RGl2KG5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnREaXYoc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnREaXYobWludXRlcywgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnREaXYoaG91cnMsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKTtcbiAgICB0b3REYXlzICo9IHNpZ247XG4gICAgdmFyIHRvdE5hbm9zID0gTWF0aFV0aWwuaW50TW9kKG5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSkgKyBNYXRoVXRpbC5pbnRNb2Qoc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCArIE1hdGhVdGlsLmludE1vZChtaW51dGVzLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZKSAqIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFICsgTWF0aFV0aWwuaW50TW9kKGhvdXJzLCBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWSkgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVI7XG4gICAgdmFyIGN1ck5vRCA9IHRoaXMuX3RpbWUudG9OYW5vT2ZEYXkoKTtcbiAgICB0b3ROYW5vcyA9IHRvdE5hbm9zICogc2lnbiArIGN1ck5vRDtcbiAgICB0b3REYXlzICs9IE1hdGhVdGlsLmZsb29yRGl2KHRvdE5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSk7XG4gICAgdmFyIG5ld05vRCA9IE1hdGhVdGlsLmZsb29yTW9kKHRvdE5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSk7XG4gICAgdmFyIG5ld1RpbWUgPSBuZXdOb0QgPT09IGN1ck5vRCA/IHRoaXMuX3RpbWUgOiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkobmV3Tm9EKTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKG5ld0RhdGUucGx1c0RheXModG90RGF5cyksIG5ld1RpbWUpO1xuICB9O1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbERhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGVUaW1lLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIF9xdWVyeSk7XG4gIH07XG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlVGltZS5wcm90b3R5cGUuYWRqdXN0SW50by5jYWxsKHRoaXMsIHRlbXBvcmFsKTtcbiAgfTtcbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZW5kRXhjbHVzaXZlLCAnZW5kRXhjbHVzaXZlJyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICB2YXIgZW5kID0gTG9jYWxEYXRlVGltZS5mcm9tKGVuZEV4Y2x1c2l2ZSk7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBpZiAodW5pdC5pc1RpbWVCYXNlZCgpKSB7XG4gICAgICAgIHZhciBkYXlzVW50aWwgPSB0aGlzLl9kYXRlLmRheXNVbnRpbChlbmQuX2RhdGUpO1xuICAgICAgICB2YXIgdGltZVVudGlsID0gZW5kLl90aW1lLnRvTmFub09mRGF5KCkgLSB0aGlzLl90aW1lLnRvTmFub09mRGF5KCk7XG4gICAgICAgIGlmIChkYXlzVW50aWwgPiAwICYmIHRpbWVVbnRpbCA8IDApIHtcbiAgICAgICAgICBkYXlzVW50aWwtLTtcbiAgICAgICAgICB0aW1lVW50aWwgKz0gTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5c1VudGlsIDwgMCAmJiB0aW1lVW50aWwgPiAwKSB7XG4gICAgICAgICAgZGF5c1VudGlsKys7XG4gICAgICAgICAgdGltZVVudGlsIC09IExvY2FsVGltZS5OQU5PU19QRVJfREFZO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbW91bnQgPSBkYXlzVW50aWw7XG4gICAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5OQU5PUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgdGltZVVudGlsKTtcbiAgICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlDUk9TOlxuICAgICAgICAgICAgYW1vdW50ID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudCwgTG9jYWxUaW1lLk1JQ1JPU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgTWF0aFV0aWwuaW50RGl2KHRpbWVVbnRpbCwgMTAwMCkpO1xuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMSVM6XG4gICAgICAgICAgICBhbW91bnQgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50LCBMb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCBNYXRoVXRpbC5pbnREaXYodGltZVVudGlsLCAxMDAwMDAwKSk7XG4gICAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgICBhbW91bnQgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50LCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgTWF0aFV0aWwuaW50RGl2KHRpbWVVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIExvY2FsVGltZS5NSU5VVEVTX1BFUl9EQVkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCBNYXRoVXRpbC5pbnREaXYodGltZVVudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSkpO1xuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IT1VSUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgTWF0aFV0aWwuaW50RGl2KHRpbWVVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKSk7XG4gICAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhBTEZfREFZUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCBNYXRoVXRpbC5pbnREaXYodGltZVVudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIgKiAxMikpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgICB9XG4gICAgICB2YXIgZW5kRGF0ZSA9IGVuZC5fZGF0ZTtcbiAgICAgIHZhciBlbmRUaW1lID0gZW5kLl90aW1lO1xuICAgICAgaWYgKGVuZERhdGUuaXNBZnRlcih0aGlzLl9kYXRlKSAmJiBlbmRUaW1lLmlzQmVmb3JlKHRoaXMuX3RpbWUpKSB7XG4gICAgICAgIGVuZERhdGUgPSBlbmREYXRlLm1pbnVzRGF5cygxKTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kRGF0ZS5pc0JlZm9yZSh0aGlzLl9kYXRlKSAmJiBlbmRUaW1lLmlzQWZ0ZXIodGhpcy5fdGltZSkpIHtcbiAgICAgICAgZW5kRGF0ZSA9IGVuZERhdGUucGx1c0RheXMoMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZS51bnRpbChlbmREYXRlLCB1bml0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuICBfcHJvdG8uYXRPZmZzZXQgPSBmdW5jdGlvbiBhdE9mZnNldChvZmZzZXQpIHtcbiAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YodGhpcywgb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLmF0Wm9uZSA9IGZ1bmN0aW9uIGF0Wm9uZSh6b25lKSB7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2YodGhpcywgem9uZSk7XG4gIH07XG4gIF9wcm90by50b0xvY2FsRGF0ZSA9IGZ1bmN0aW9uIHRvTG9jYWxEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlO1xuICB9O1xuICBfcHJvdG8udG9Mb2NhbFRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZTtcbiAgfTtcbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIExvY2FsRGF0ZVRpbWUsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl9jb21wYXJlVG8wKG90aGVyKTtcbiAgfTtcbiAgX3Byb3RvLl9jb21wYXJlVG8wID0gZnVuY3Rpb24gX2NvbXBhcmVUbzAob3RoZXIpIHtcbiAgICB2YXIgY21wID0gdGhpcy5fZGF0ZS5jb21wYXJlVG8ob3RoZXIudG9Mb2NhbERhdGUoKSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gdGhpcy5fdGltZS5jb21wYXJlVG8ob3RoZXIudG9Mb2NhbFRpbWUoKSk7XG4gICAgfVxuICAgIHJldHVybiBjbXA7XG4gIH07XG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICB9O1xuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPCAwO1xuICB9O1xuICBfcHJvdG8uaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID09PSAwO1xuICB9O1xuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTG9jYWxEYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGUuZXF1YWxzKG90aGVyLl9kYXRlKSAmJiB0aGlzLl90aW1lLmVxdWFscyhvdGhlci5fdGltZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuaGFzaENvZGUoKSBeIHRoaXMuX3RpbWUuaGFzaENvZGUoKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUudG9TdHJpbmcoKSArIFwiVFwiICsgdGhpcy5fdGltZS50b1N0cmluZygpO1xuICB9O1xuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG4gIHJldHVybiBMb2NhbERhdGVUaW1lO1xufShDaHJvbm9Mb2NhbERhdGVUaW1lKTtcbmZ1bmN0aW9uIF9pbml0JDQoKSB7XG4gIExvY2FsRGF0ZVRpbWUuTUlOID0gTG9jYWxEYXRlVGltZS5vZihMb2NhbERhdGUuTUlOLCBMb2NhbFRpbWUuTUlOKTtcbiAgTG9jYWxEYXRlVGltZS5NQVggPSBMb2NhbERhdGVUaW1lLm9mKExvY2FsRGF0ZS5NQVgsIExvY2FsVGltZS5NQVgpO1xuICBMb2NhbERhdGVUaW1lLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMb2NhbERhdGVUaW1lLkZST00nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBMb2NhbFRpbWUgPSBmdW5jdGlvbiAoX1RlbXBvcmFsKSB7XG4gIF9pbmhlcml0c0xvb3NlKExvY2FsVGltZSwgX1RlbXBvcmFsKTtcbiAgTG9jYWxUaW1lLm5vdyA9IGZ1bmN0aW9uIG5vdyhjbG9ja09yWm9uZSkge1xuICAgIGlmIChjbG9ja09yWm9uZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gTG9jYWxUaW1lLl9ub3coQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gICAgfSBlbHNlIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIENsb2NrKSB7XG4gICAgICByZXR1cm4gTG9jYWxUaW1lLl9ub3coY2xvY2tPclpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTG9jYWxUaW1lLl9ub3coQ2xvY2suc3lzdGVtKGNsb2NrT3Jab25lKSk7XG4gICAgfVxuICB9O1xuICBMb2NhbFRpbWUuX25vdyA9IGZ1bmN0aW9uIF9ub3coY2xvY2spIHtcbiAgICBpZiAoY2xvY2sgPT09IHZvaWQgMCkge1xuICAgICAgY2xvY2sgPSBDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpO1xuICAgIH1cbiAgICByZXF1aXJlTm9uTnVsbChjbG9jaywgJ2Nsb2NrJyk7XG4gICAgcmV0dXJuIExvY2FsVGltZS5vZkluc3RhbnQoY2xvY2suaW5zdGFudCgpLCBjbG9jay56b25lKCkpO1xuICB9O1xuICBMb2NhbFRpbWUub2ZJbnN0YW50ID0gZnVuY3Rpb24gb2ZJbnN0YW50KGluc3RhbnQsIHpvbmUpIHtcbiAgICBpZiAoem9uZSA9PT0gdm9pZCAwKSB7XG4gICAgICB6b25lID0gWm9uZUlkLnN5c3RlbURlZmF1bHQoKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIHNlY3NPZkRheSA9IE1hdGhVdGlsLmludE1vZChpbnN0YW50LmVwb2NoU2Vjb25kKCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHNlY3NPZkRheSA9IE1hdGhVdGlsLmludE1vZChzZWNzT2ZEYXkgKyBvZmZzZXQudG90YWxTZWNvbmRzKCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIGlmIChzZWNzT2ZEYXkgPCAwKSB7XG4gICAgICBzZWNzT2ZEYXkgKz0gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWTtcbiAgICB9XG4gICAgcmV0dXJuIExvY2FsVGltZS5vZlNlY29uZE9mRGF5KHNlY3NPZkRheSwgaW5zdGFudC5uYW5vKCkpO1xuICB9O1xuICBMb2NhbFRpbWUub2YgPSBmdW5jdGlvbiBvZihob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gIH07XG4gIExvY2FsVGltZS5vZlNlY29uZE9mRGF5ID0gZnVuY3Rpb24gb2ZTZWNvbmRPZkRheShzZWNvbmRPZkRheSwgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKHNlY29uZE9mRGF5ID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZE9mRGF5ID0gMDtcbiAgICB9XG4gICAgaWYgKG5hbm9PZlNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vT2ZTZWNvbmQgPSAwO1xuICAgIH1cbiAgICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShzZWNvbmRPZkRheSk7XG4gICAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZFZhbHVlKG5hbm9PZlNlY29uZCk7XG4gICAgdmFyIGhvdXJzID0gTWF0aFV0aWwuaW50RGl2KHNlY29uZE9mRGF5LCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUik7XG4gICAgc2Vjb25kT2ZEYXkgLT0gaG91cnMgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUjtcbiAgICB2YXIgbWludXRlcyA9IE1hdGhVdGlsLmludERpdihzZWNvbmRPZkRheSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgc2Vjb25kT2ZEYXkgLT0gbWludXRlcyAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEU7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZE9mRGF5LCBuYW5vT2ZTZWNvbmQpO1xuICB9O1xuICBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkgPSBmdW5jdGlvbiBvZk5hbm9PZkRheShuYW5vT2ZEYXkpIHtcbiAgICBpZiAobmFub09mRGF5ID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZkRheSA9IDA7XG4gICAgfVxuICAgIENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShuYW5vT2ZEYXkpO1xuICAgIHZhciBob3VycyA9IE1hdGhVdGlsLmludERpdihuYW5vT2ZEYXksIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUik7XG4gICAgbmFub09mRGF5IC09IGhvdXJzICogTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSO1xuICAgIHZhciBtaW51dGVzID0gTWF0aFV0aWwuaW50RGl2KG5hbm9PZkRheSwgTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEUpO1xuICAgIG5hbm9PZkRheSAtPSBtaW51dGVzICogTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEU7XG4gICAgdmFyIHNlY29uZHMgPSBNYXRoVXRpbC5pbnREaXYobmFub09mRGF5LCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgbmFub09mRGF5IC09IHNlY29uZHMgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORDtcbiAgICByZXR1cm4gbmV3IExvY2FsVGltZShob3VycywgbWludXRlcywgc2Vjb25kcywgbmFub09mRGF5KTtcbiAgfTtcbiAgTG9jYWxUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHZhciB0aW1lID0gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKTtcbiAgICBpZiAodGltZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJVbmFibGUgdG8gb2J0YWluIExvY2FsVGltZSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZTtcbiAgfTtcbiAgTG9jYWxUaW1lLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGZvcm1hdHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRTtcbiAgICB9XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBMb2NhbFRpbWUuRlJPTSk7XG4gIH07XG4gIGZ1bmN0aW9uIExvY2FsVGltZShob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIGlmIChob3VyID09PSB2b2lkIDApIHtcbiAgICAgIGhvdXIgPSAwO1xuICAgIH1cbiAgICBpZiAobWludXRlID09PSB2b2lkIDApIHtcbiAgICAgIG1pbnV0ZSA9IDA7XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kID0gMDtcbiAgICB9XG4gICAgaWYgKG5hbm9PZlNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vT2ZTZWNvbmQgPSAwO1xuICAgIH1cbiAgICBfdGhpcyA9IF9UZW1wb3JhbC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgdmFyIF9ob3VyID0gTWF0aFV0aWwuc2FmZVRvSW50KGhvdXIpO1xuICAgIHZhciBfbWludXRlID0gTWF0aFV0aWwuc2FmZVRvSW50KG1pbnV0ZSk7XG4gICAgdmFyIF9zZWNvbmQgPSBNYXRoVXRpbC5zYWZlVG9JbnQoc2Vjb25kKTtcbiAgICB2YXIgX25hbm9PZlNlY29uZCA9IE1hdGhVdGlsLnNhZmVUb0ludChuYW5vT2ZTZWNvbmQpO1xuICAgIExvY2FsVGltZS5fdmFsaWRhdGUoX2hvdXIsIF9taW51dGUsIF9zZWNvbmQsIF9uYW5vT2ZTZWNvbmQpO1xuICAgIGlmIChfbWludXRlID09PSAwICYmIF9zZWNvbmQgPT09IDAgJiYgX25hbm9PZlNlY29uZCA9PT0gMCkge1xuICAgICAgaWYgKCFMb2NhbFRpbWUuSE9VUlNbX2hvdXJdKSB7XG4gICAgICAgIF90aGlzLl9ob3VyID0gX2hvdXI7XG4gICAgICAgIF90aGlzLl9taW51dGUgPSBfbWludXRlO1xuICAgICAgICBfdGhpcy5fc2Vjb25kID0gX3NlY29uZDtcbiAgICAgICAgX3RoaXMuX25hbm8gPSBfbmFub09mU2Vjb25kO1xuICAgICAgICBMb2NhbFRpbWUuSE9VUlNbX2hvdXJdID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTG9jYWxUaW1lLkhPVVJTW19ob3VyXSB8fCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICB9XG4gICAgX3RoaXMuX2hvdXIgPSBfaG91cjtcbiAgICBfdGhpcy5fbWludXRlID0gX21pbnV0ZTtcbiAgICBfdGhpcy5fc2Vjb25kID0gX3NlY29uZDtcbiAgICBfdGhpcy5fbmFubyA9IF9uYW5vT2ZTZWNvbmQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIExvY2FsVGltZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiBfdmFsaWRhdGUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCkge1xuICAgIENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShob3VyKTtcbiAgICBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUi5jaGVja1ZhbGlkVmFsdWUobWludXRlKTtcbiAgICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFLmNoZWNrVmFsaWRWYWx1ZShzZWNvbmQpO1xuICAgIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELmNoZWNrVmFsaWRWYWx1ZShuYW5vT2ZTZWNvbmQpO1xuICB9O1xuICB2YXIgX3Byb3RvID0gTG9jYWxUaW1lLnByb3RvdHlwZTtcbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRPclVuaXQgIT0gbnVsbCAmJiBmaWVsZE9yVW5pdC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkKTtcbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5yYW5nZS5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmdldExvbmcoZmllbGQpO1xuICB9O1xuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXQwKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5fZ2V0MCA9IGZ1bmN0aW9uIF9nZXQwKGZpZWxkKSB7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbm87XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZOlxuICAgICAgICByZXR1cm4gdGhpcy50b05hbm9PZkRheSgpO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQ6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFubywgMTAwMCk7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JQ1JPX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLnRvTmFub09mRGF5KCksIDEwMDApO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQ6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFubywgMTAwMDAwMCk7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTExJX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLnRvTmFub09mRGF5KCksIDEwMDAwMDApO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFOlxuICAgICAgICByZXR1cm4gdGhpcy5fc2Vjb25kO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZOlxuICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZE9mRGF5KCk7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSOlxuICAgICAgICByZXR1cm4gdGhpcy5fbWludXRlO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZOlxuICAgICAgICByZXR1cm4gdGhpcy5faG91ciAqIDYwICsgdGhpcy5fbWludXRlO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE06XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnRNb2QodGhpcy5faG91ciwgMTIpO1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE06XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaGFtID0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKTtcbiAgICAgICAgICByZXR1cm4gaGFtICUgMTIgPT09IDAgPyAxMiA6IGhhbTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvdXI7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZOlxuICAgICAgICByZXR1cm4gdGhpcy5faG91ciA9PT0gMCA/IDI0IDogdGhpcy5faG91cjtcbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5faG91ciwgMTIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gIH07XG4gIF9wcm90by5ob3VyID0gZnVuY3Rpb24gaG91cigpIHtcbiAgICByZXR1cm4gdGhpcy5faG91cjtcbiAgfTtcbiAgX3Byb3RvLm1pbnV0ZSA9IGZ1bmN0aW9uIG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludXRlO1xuICB9O1xuICBfcHJvdG8uc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWNvbmQ7XG4gIH07XG4gIF9wcm90by5uYW5vID0gZnVuY3Rpb24gbmFubygpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFubztcbiAgfTtcbiAgX3Byb3RvLl93aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiBfd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuICAgIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsVGltZSkge1xuICAgICAgcmV0dXJuIGFkanVzdGVyO1xuICAgIH1cbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5fd2l0aEFkanVzdGVyLmNhbGwodGhpcywgYWRqdXN0ZXIpO1xuICB9O1xuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmaWVsZCwgVGVtcG9yYWxGaWVsZCwgJ2ZpZWxkJyk7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGZpZWxkLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aE5hbm8obmV3VmFsdWUpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZOlxuICAgICAgICAgIHJldHVybiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkobmV3VmFsdWUpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORDpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoTmFubyhuZXdWYWx1ZSAqIDEwMDApO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JQ1JPX09GX0RBWTpcbiAgICAgICAgICByZXR1cm4gTG9jYWxUaW1lLm9mTmFub09mRGF5KG5ld1ZhbHVlICogMTAwMCk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhOYW5vKG5ld1ZhbHVlICogMTAwMDAwMCk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZOlxuICAgICAgICAgIHJldHVybiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkobmV3VmFsdWUgKiAxMDAwMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhTZWNvbmQobmV3VmFsdWUpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMobmV3VmFsdWUgLSB0aGlzLnRvU2Vjb25kT2ZEYXkoKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1pbnV0ZShuZXdWYWx1ZSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlOVVRFX09GX0RBWTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTWludXRlcyhuZXdWYWx1ZSAtICh0aGlzLl9ob3VyICogNjAgKyB0aGlzLl9taW51dGUpKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE06XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKG5ld1ZhbHVlIC0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygobmV3VmFsdWUgPT09IDEyID8gMCA6IG5ld1ZhbHVlKSAtIE1hdGhVdGlsLmludE1vZCh0aGlzLl9ob3VyLCAxMikpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhIb3VyKG5ld1ZhbHVlKTtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoSG91cihuZXdWYWx1ZSA9PT0gMjQgPyAwIDogbmV3VmFsdWUpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkFNUE1fT0ZfREFZOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygobmV3VmFsdWUgLSBNYXRoVXRpbC5pbnREaXYodGhpcy5faG91ciwgMTIpKSAqIDEyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuICBfcHJvdG8ud2l0aEhvdXIgPSBmdW5jdGlvbiB3aXRoSG91cihob3VyKSB7XG4gICAgaWYgKGhvdXIgPT09IHZvaWQgMCkge1xuICAgICAgaG91ciA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ob3VyID09PSBob3VyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91ciwgdGhpcy5fbWludXRlLCB0aGlzLl9zZWNvbmQsIHRoaXMuX25hbm8pO1xuICB9O1xuICBfcHJvdG8ud2l0aE1pbnV0ZSA9IGZ1bmN0aW9uIHdpdGhNaW51dGUobWludXRlKSB7XG4gICAgaWYgKG1pbnV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW51dGUgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbWludXRlID09PSBtaW51dGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExvY2FsVGltZSh0aGlzLl9ob3VyLCBtaW51dGUsIHRoaXMuX3NlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZWNvbmQgPT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKHRoaXMuX2hvdXIsIHRoaXMuX21pbnV0ZSwgc2Vjb25kLCB0aGlzLl9uYW5vKTtcbiAgfTtcbiAgX3Byb3RvLndpdGhOYW5vID0gZnVuY3Rpb24gd2l0aE5hbm8obmFub09mU2Vjb25kKSB7XG4gICAgaWYgKG5hbm9PZlNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vT2ZTZWNvbmQgPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbmFubyA9PT0gbmFub09mU2Vjb25kKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUodGhpcy5faG91ciwgdGhpcy5fbWludXRlLCB0aGlzLl9zZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gIH07XG4gIF9wcm90by50cnVuY2F0ZWRUbyA9IGZ1bmN0aW9uIHRydW5jYXRlZFRvKHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0Lk5BTk9TKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHVuaXREdXIgPSB1bml0LmR1cmF0aW9uKCk7XG4gICAgaWYgKHVuaXREdXIuc2Vjb25kcygpID4gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbml0IGlzIHRvbyBsYXJnZSB0byBiZSB1c2VkIGZvciB0cnVuY2F0aW9uJyk7XG4gICAgfVxuICAgIHZhciBkdXIgPSB1bml0RHVyLnRvTmFub3MoKTtcbiAgICBpZiAoTWF0aFV0aWwuaW50TW9kKExvY2FsVGltZS5OQU5PU19QRVJfREFZLCBkdXIpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuaXQgbXVzdCBkaXZpZGUgaW50byBhIHN0YW5kYXJkIGRheSB3aXRob3V0IHJlbWFpbmRlcicpO1xuICAgIH1cbiAgICB2YXIgbm9kID0gdGhpcy50b05hbm9PZkRheSgpO1xuICAgIHJldHVybiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkoTWF0aFV0aWwuaW50RGl2KG5vZCwgZHVyKSAqIGR1cik7XG4gIH07XG4gIF9wcm90by5fcGx1c1VuaXQgPSBmdW5jdGlvbiBfcGx1c1VuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5OQU5PUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTmFub3MoYW1vdW50VG9BZGQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlDUk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhNYXRoVXRpbC5pbnRNb2QoYW1vdW50VG9BZGQsIExvY2FsVGltZS5NSUNST1NfUEVSX0RBWSkgKiAxMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExJUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTmFub3MoTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkpICogMTAwMDAwMCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTlVURVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01pbnV0ZXMoYW1vdW50VG9BZGQpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhBTEZfREFZUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzSG91cnMoTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCAyKSAqIDEyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vyc1RvQWRkKSB7XG4gICAgaWYgKGhvdXJzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3SG91ciA9IE1hdGhVdGlsLmludE1vZChNYXRoVXRpbC5pbnRNb2QoaG91cnNUb0FkZCwgTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVkpICsgdGhpcy5faG91ciArIExvY2FsVGltZS5IT1VSU19QRVJfREFZLCBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWSk7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUobmV3SG91ciwgdGhpcy5fbWludXRlLCB0aGlzLl9zZWNvbmQsIHRoaXMuX25hbm8pO1xuICB9O1xuICBfcHJvdG8ucGx1c01pbnV0ZXMgPSBmdW5jdGlvbiBwbHVzTWludXRlcyhtaW51dGVzVG9BZGQpIHtcbiAgICBpZiAobWludXRlc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG1vZmQgPSB0aGlzLl9ob3VyICogTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIgKyB0aGlzLl9taW51dGU7XG4gICAgdmFyIG5ld01vZmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50TW9kKG1pbnV0ZXNUb0FkZCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSkgKyBtb2ZkICsgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSk7XG4gICAgaWYgKG1vZmQgPT09IG5ld01vZmQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3SG91ciA9IE1hdGhVdGlsLmludERpdihuZXdNb2ZkLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUik7XG4gICAgdmFyIG5ld01pbnV0ZSA9IE1hdGhVdGlsLmludE1vZChuZXdNb2ZkLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUik7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUobmV3SG91ciwgbmV3TWludXRlLCB0aGlzLl9zZWNvbmQsIHRoaXMuX25hbm8pO1xuICB9O1xuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzVG9BZGQpIHtcbiAgICBpZiAoc2Vjb25kc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHNvZmQgPSB0aGlzLl9ob3VyICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIgKyB0aGlzLl9taW51dGUgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFICsgdGhpcy5fc2Vjb25kO1xuICAgIHZhciBuZXdTb2ZkID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludE1vZChzZWNvbmRzVG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpICsgc29mZCArIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIGlmIChzb2ZkID09PSBuZXdTb2ZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld0hvdXIgPSBNYXRoVXRpbC5pbnREaXYobmV3U29mZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdNaW51dGUgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KG5ld1NvZmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUik7XG4gICAgdmFyIG5ld1NlY29uZCA9IE1hdGhVdGlsLmludE1vZChuZXdTb2ZkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICByZXR1cm4gbmV3IExvY2FsVGltZShuZXdIb3VyLCBuZXdNaW51dGUsIG5ld1NlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG4gIF9wcm90by5wbHVzTmFub3MgPSBmdW5jdGlvbiBwbHVzTmFub3MobmFub3NUb0FkZCkge1xuICAgIGlmIChuYW5vc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5vZmQgPSB0aGlzLnRvTmFub09mRGF5KCk7XG4gICAgdmFyIG5ld05vZmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50TW9kKG5hbm9zVG9BZGQsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKSArIG5vZmQgKyBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSwgTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVkpO1xuICAgIGlmIChub2ZkID09PSBuZXdOb2ZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld0hvdXIgPSBNYXRoVXRpbC5pbnREaXYobmV3Tm9mZCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKTtcbiAgICB2YXIgbmV3TWludXRlID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludERpdihuZXdOb2ZkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSksIExvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSKTtcbiAgICB2YXIgbmV3U2Vjb25kID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludERpdihuZXdOb2ZkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpO1xuICAgIHZhciBuZXdOYW5vID0gTWF0aFV0aWwuaW50TW9kKG5ld05vZmQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICByZXR1cm4gbmV3IExvY2FsVGltZShuZXdIb3VyLCBuZXdNaW51dGUsIG5ld1NlY29uZCwgbmV3TmFubyk7XG4gIH07XG4gIF9wcm90by5fbWludXNVbml0ID0gZnVuY3Rpb24gX21pbnVzVW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1VuaXQoLTEgKiBhbW91bnRUb1N1YnRyYWN0LCB1bml0KTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzSG91cnMgPSBmdW5jdGlvbiBtaW51c0hvdXJzKGhvdXJzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygtMSAqIE1hdGhVdGlsLmludE1vZChob3Vyc1RvU3VidHJhY3QsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKSk7XG4gIH07XG4gIF9wcm90by5taW51c01pbnV0ZXMgPSBmdW5jdGlvbiBtaW51c01pbnV0ZXMobWludXRlc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTWludXRlcygtMSAqIE1hdGhVdGlsLmludE1vZChtaW51dGVzVG9TdWJ0cmFjdCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSkpO1xuICB9O1xuICBfcHJvdG8ubWludXNTZWNvbmRzID0gZnVuY3Rpb24gbWludXNTZWNvbmRzKHNlY29uZHNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoLTEgKiBNYXRoVXRpbC5pbnRNb2Qoc2Vjb25kc1RvU3VidHJhY3QsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpKTtcbiAgfTtcbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcygtMSAqIE1hdGhVdGlsLmludE1vZChuYW5vc1RvU3VidHJhY3QsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKSk7XG4gIH07XG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5OQU5PUztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3F1ZXJ5LnF1ZXJ5RnJvbSh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoTG9jYWxUaW1lLk5BTk9fT0ZfREFZLCB0aGlzLnRvTmFub09mRGF5KCkpO1xuICB9O1xuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRFeGNsdXNpdmUsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHZhciBlbmQgPSBMb2NhbFRpbWUuZnJvbShlbmRFeGNsdXNpdmUpO1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgdmFyIG5hbm9zVW50aWwgPSBlbmQudG9OYW5vT2ZEYXkoKSAtIHRoaXMudG9OYW5vT2ZEYXkoKTtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTkFOT1M6XG4gICAgICAgICAgcmV0dXJuIG5hbm9zVW50aWw7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCAxMDAwKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExJUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG5hbm9zVW50aWwsIDEwMDAwMDApO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG5hbm9zVW50aWwsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTlVURVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IT1VSUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG5hbm9zVW50aWwsIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUik7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IQUxGX0RBWVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCAxMiAqIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG4gIF9wcm90by5hdERhdGUgPSBmdW5jdGlvbiBhdERhdGUoZGF0ZSkge1xuICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mKGRhdGUsIHRoaXMpO1xuICB9O1xuICBfcHJvdG8uYXRPZmZzZXQgPSBmdW5jdGlvbiBhdE9mZnNldChvZmZzZXQpIHtcbiAgICByZXR1cm4gT2Zmc2V0VGltZS5vZih0aGlzLCBvZmZzZXQpO1xuICB9O1xuICBfcHJvdG8udG9TZWNvbmRPZkRheSA9IGZ1bmN0aW9uIHRvU2Vjb25kT2ZEYXkoKSB7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5faG91ciAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSO1xuICAgIHRvdGFsICs9IHRoaXMuX21pbnV0ZSAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEU7XG4gICAgdG90YWwgKz0gdGhpcy5fc2Vjb25kO1xuICAgIHJldHVybiB0b3RhbDtcbiAgfTtcbiAgX3Byb3RvLnRvTmFub09mRGF5ID0gZnVuY3Rpb24gdG9OYW5vT2ZEYXkoKSB7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5faG91ciAqIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUjtcbiAgICB0b3RhbCArPSB0aGlzLl9taW51dGUgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURTtcbiAgICB0b3RhbCArPSB0aGlzLl9zZWNvbmQgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORDtcbiAgICB0b3RhbCArPSB0aGlzLl9uYW5vO1xuICAgIHJldHVybiB0b3RhbDtcbiAgfTtcbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIExvY2FsVGltZSwgJ290aGVyJyk7XG4gICAgdmFyIGNtcCA9IE1hdGhVdGlsLmNvbXBhcmVOdW1iZXJzKHRoaXMuX2hvdXIsIG90aGVyLl9ob3VyKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICBjbXAgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLl9taW51dGUsIG90aGVyLl9taW51dGUpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICBjbXAgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLl9zZWNvbmQsIG90aGVyLl9zZWNvbmQpO1xuICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fbmFubywgb3RoZXIuX25hbm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbXA7XG4gIH07XG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICB9O1xuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPCAwO1xuICB9O1xuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTG9jYWxUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5faG91ciA9PT0gb3RoZXIuX2hvdXIgJiYgdGhpcy5fbWludXRlID09PSBvdGhlci5fbWludXRlICYmIHRoaXMuX3NlY29uZCA9PT0gb3RoZXIuX3NlY29uZCAmJiB0aGlzLl9uYW5vID09PSBvdGhlci5fbmFubztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICB2YXIgbm9kID0gdGhpcy50b05hbm9PZkRheSgpO1xuICAgIHJldHVybiBNYXRoVXRpbC5oYXNoKG5vZCk7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB2YXIgaG91clZhbHVlID0gdGhpcy5faG91cjtcbiAgICB2YXIgbWludXRlVmFsdWUgPSB0aGlzLl9taW51dGU7XG4gICAgdmFyIHNlY29uZFZhbHVlID0gdGhpcy5fc2Vjb25kO1xuICAgIHZhciBuYW5vVmFsdWUgPSB0aGlzLl9uYW5vO1xuICAgIGJ1ZiArPSBob3VyVmFsdWUgPCAxMCA/ICcwJyA6ICcnO1xuICAgIGJ1ZiArPSBob3VyVmFsdWU7XG4gICAgYnVmICs9IG1pbnV0ZVZhbHVlIDwgMTAgPyAnOjAnIDogJzonO1xuICAgIGJ1ZiArPSBtaW51dGVWYWx1ZTtcbiAgICBpZiAoc2Vjb25kVmFsdWUgPiAwIHx8IG5hbm9WYWx1ZSA+IDApIHtcbiAgICAgIGJ1ZiArPSBzZWNvbmRWYWx1ZSA8IDEwID8gJzowJyA6ICc6JztcbiAgICAgIGJ1ZiArPSBzZWNvbmRWYWx1ZTtcbiAgICAgIGlmIChuYW5vVmFsdWUgPiAwKSB7XG4gICAgICAgIGJ1ZiArPSAnLic7XG4gICAgICAgIGlmIChNYXRoVXRpbC5pbnRNb2QobmFub1ZhbHVlLCAxMDAwMDAwKSA9PT0gMCkge1xuICAgICAgICAgIGJ1ZiArPSAoXCJcIiArIChNYXRoVXRpbC5pbnREaXYobmFub1ZhbHVlLCAxMDAwMDAwKSArIDEwMDApKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aFV0aWwuaW50TW9kKG5hbm9WYWx1ZSwgMTAwMCkgPT09IDApIHtcbiAgICAgICAgICBidWYgKz0gKFwiXCIgKyAoTWF0aFV0aWwuaW50RGl2KG5hbm9WYWx1ZSwgMTAwMCkgKyAxMDAwMDAwKSkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZiArPSAoXCJcIiArIChuYW5vVmFsdWUgKyAxMDAwMDAwMDAwKSkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH07XG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcbiAgcmV0dXJuIExvY2FsVGltZTtcbn0oVGVtcG9yYWwpO1xuZnVuY3Rpb24gX2luaXQkMygpIHtcbiAgTG9jYWxUaW1lLkhPVVJTID0gW107XG4gIGZvciAodmFyIGhvdXIgPSAwOyBob3VyIDwgMjQ7IGhvdXIrKykge1xuICAgIExvY2FsVGltZS5vZihob3VyLCAwLCAwLCAwKTtcbiAgfVxuICBMb2NhbFRpbWUuTUlOID0gTG9jYWxUaW1lLkhPVVJTWzBdO1xuICBMb2NhbFRpbWUuTUFYID0gbmV3IExvY2FsVGltZSgyMywgNTksIDU5LCA5OTk5OTk5OTkpO1xuICBMb2NhbFRpbWUuTUlETklHSFQgPSBMb2NhbFRpbWUuSE9VUlNbMF07XG4gIExvY2FsVGltZS5OT09OID0gTG9jYWxUaW1lLkhPVVJTWzEyXTtcbiAgTG9jYWxUaW1lLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMb2NhbFRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBMb2NhbFRpbWUuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVkgPSAyNDtcbkxvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSID0gNjA7XG5Mb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZID0gTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIgKiBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWTtcbkxvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUgPSA2MDtcbkxvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSID0gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSAqIExvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSO1xuTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSA9IExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSICogTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVk7XG5Mb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkgPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZICogMTAwMDtcbkxvY2FsVGltZS5NSUNST1NfUEVSX0RBWSA9IExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkgKiAxMDAwMDAwO1xuTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQgPSAxMDAwMDAwMDAwO1xuTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEUgPSBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEU7XG5Mb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIgPSBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSAqIExvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSO1xuTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVkgPSBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIgKiBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWTtcblxudmFyIE5BTk9TX1BFUl9NSUxMSSA9IDEwMDAwMDA7XG52YXIgSW5zdGFudCA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5zdGFudCwgX1RlbXBvcmFsKTtcbiAgSW5zdGFudC5ub3cgPSBmdW5jdGlvbiBub3coY2xvY2spIHtcbiAgICBpZiAoY2xvY2sgPT09IHZvaWQgMCkge1xuICAgICAgY2xvY2sgPSBDbG9jay5zeXN0ZW1VVEMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb2NrLmluc3RhbnQoKTtcbiAgfTtcbiAgSW5zdGFudC5vZkVwb2NoU2Vjb25kID0gZnVuY3Rpb24gb2ZFcG9jaFNlY29uZChlcG9jaFNlY29uZCwgbmFub0FkanVzdG1lbnQpIHtcbiAgICBpZiAobmFub0FkanVzdG1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub0FkanVzdG1lbnQgPSAwO1xuICAgIH1cbiAgICB2YXIgc2VjcyA9IGVwb2NoU2Vjb25kICsgTWF0aFV0aWwuZmxvb3JEaXYobmFub0FkanVzdG1lbnQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICB2YXIgbm9zID0gTWF0aFV0aWwuZmxvb3JNb2QobmFub0FkanVzdG1lbnQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICByZXR1cm4gSW5zdGFudC5fY3JlYXRlKHNlY3MsIG5vcyk7XG4gIH07XG4gIEluc3RhbnQub2ZFcG9jaE1pbGxpID0gZnVuY3Rpb24gb2ZFcG9jaE1pbGxpKGVwb2NoTWlsbGkpIHtcbiAgICB2YXIgc2VjcyA9IE1hdGhVdGlsLmZsb29yRGl2KGVwb2NoTWlsbGksIDEwMDApO1xuICAgIHZhciBtb3MgPSBNYXRoVXRpbC5mbG9vck1vZChlcG9jaE1pbGxpLCAxMDAwKTtcbiAgICByZXR1cm4gSW5zdGFudC5fY3JlYXRlKHNlY3MsIG1vcyAqIDEwMDAwMDApO1xuICB9O1xuICBJbnN0YW50Lm9mRXBvY2hNaWNybyA9IGZ1bmN0aW9uIG9mRXBvY2hNaWNybyhlcG9jaE1pY3JvKSB7XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5mbG9vckRpdihlcG9jaE1pY3JvLCAxMDAwMDAwKTtcbiAgICB2YXIgbW9zID0gTWF0aFV0aWwuZmxvb3JNb2QoZXBvY2hNaWNybywgMTAwMDAwMCk7XG4gICAgcmV0dXJuIEluc3RhbnQuX2NyZWF0ZShzZWNzLCBtb3MgKiAxMDAwKTtcbiAgfTtcbiAgSW5zdGFudC5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaW5zdGFudFNlY3MgPSB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgICB2YXIgbmFub09mU2Vjb25kID0gdGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICAgIHJldHVybiBJbnN0YW50Lm9mRXBvY2hTZWNvbmQoaW5zdGFudFNlY3MsIG5hbm9PZlNlY29uZCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gSW5zdGFudCBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArIHR5cGVvZiB0ZW1wb3JhbCwgZXgpO1xuICAgIH1cbiAgfTtcbiAgSW5zdGFudC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0lOU1RBTlQucGFyc2UodGV4dCwgSW5zdGFudC5GUk9NKTtcbiAgfTtcbiAgSW5zdGFudC5fY3JlYXRlID0gZnVuY3Rpb24gX2NyZWF0ZShzZWNvbmRzLCBuYW5vT2ZTZWNvbmQpIHtcbiAgICBpZiAoc2Vjb25kcyA9PT0gMCAmJiBuYW5vT2ZTZWNvbmQgPT09IDApIHtcbiAgICAgIHJldHVybiBJbnN0YW50LkVQT0NIO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEluc3RhbnQoc2Vjb25kcywgbmFub09mU2Vjb25kKTtcbiAgfTtcbiAgSW5zdGFudC5fdmFsaWRhdGUgPSBmdW5jdGlvbiBfdmFsaWRhdGUoc2Vjb25kcywgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKHNlY29uZHMgPCBJbnN0YW50Lk1JTl9TRUNPTkRTIHx8IHNlY29uZHMgPiBJbnN0YW50Lk1BWF9TRUNPTkRTKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ0luc3RhbnQgZXhjZWVkcyBtaW5pbXVtIG9yIG1heGltdW0gaW5zdGFudCcpO1xuICAgIH1cbiAgICBpZiAobmFub09mU2Vjb25kIDwgMCB8fCBuYW5vT2ZTZWNvbmQgPiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdJbnN0YW50IGV4Y2VlZHMgbWluaW11bSBvciBtYXhpbXVtIGluc3RhbnQnKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIEluc3RhbnQoc2Vjb25kcywgbmFub09mU2Vjb25kKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBJbnN0YW50Ll92YWxpZGF0ZShzZWNvbmRzLCBuYW5vT2ZTZWNvbmQpO1xuICAgIF90aGlzLl9zZWNvbmRzID0gTWF0aFV0aWwuc2FmZVRvSW50KHNlY29uZHMpO1xuICAgIF90aGlzLl9uYW5vcyA9IE1hdGhVdGlsLnNhZmVUb0ludChuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gSW5zdGFudC5wcm90b3R5cGU7XG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdCA9PT0gQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTIHx8IGZpZWxkT3JVbml0ID09PSBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCB8fCBmaWVsZE9yVW5pdCA9PT0gQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EIHx8IGZpZWxkT3JVbml0ID09PSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQ7XG4gICAgfVxuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpIHx8IGZpZWxkT3JVbml0ID09PSBDaHJvbm9Vbml0LkRBWVM7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucmFuZ2UuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbmFub3M7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFub3MsIDEwMDApO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORDpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm9zLCBOQU5PU19QRVJfTUlMTEkpO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vjb25kcztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5lcG9jaFNlY29uZCA9IGZ1bmN0aW9uIGVwb2NoU2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWNvbmRzO1xuICB9O1xuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICB9O1xuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBmaWVsZC5jaGVja1ZhbGlkVmFsdWUobmV3VmFsdWUpO1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbnZhbCA9IG5ld1ZhbHVlICogTkFOT1NfUEVSX01JTExJO1xuICAgICAgICAgICAgcmV0dXJuIG52YWwgIT09IHRoaXMuX25hbm9zID8gSW5zdGFudC5fY3JlYXRlKHRoaXMuX3NlY29uZHMsIG52YWwpIDogdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbnZhbCA9IG5ld1ZhbHVlICogMTAwMDtcbiAgICAgICAgICAgIHJldHVybiBfbnZhbCAhPT0gdGhpcy5fbmFub3MgPyBJbnN0YW50Ll9jcmVhdGUodGhpcy5fc2Vjb25kcywgX252YWwpIDogdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQ6XG4gICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlICE9PSB0aGlzLl9uYW5vcyA/IEluc3RhbnQuX2NyZWF0ZSh0aGlzLl9zZWNvbmRzLCBuZXdWYWx1ZSkgOiB0aGlzO1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gbmV3VmFsdWUgIT09IHRoaXMuX3NlY29uZHMgPyBJbnN0YW50Ll9jcmVhdGUobmV3VmFsdWUsIHRoaXMuX25hbm9zKSA6IHRoaXM7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuTkFOT1MpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgdW5pdER1ciA9IHVuaXQuZHVyYXRpb24oKTtcbiAgICBpZiAodW5pdER1ci5zZWNvbmRzKCkgPiBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuaXQgaXMgdG9vIGxhcmdlIHRvIGJlIHVzZWQgZm9yIHRydW5jYXRpb24nKTtcbiAgICB9XG4gICAgdmFyIGR1ciA9IHVuaXREdXIudG9OYW5vcygpO1xuICAgIGlmIChNYXRoVXRpbC5pbnRNb2QoTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVksIGR1cikgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignVW5pdCBtdXN0IGRpdmlkZSBpbnRvIGEgc3RhbmRhcmQgZGF5IHdpdGhvdXQgcmVtYWluZGVyJyk7XG4gICAgfVxuICAgIHZhciBub2QgPSBNYXRoVXRpbC5pbnRNb2QodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCArIHRoaXMuX25hbm9zO1xuICAgIHZhciByZXN1bHQgPSBNYXRoVXRpbC5pbnREaXYobm9kLCBkdXIpICogZHVyO1xuICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhyZXN1bHQgLSBub2QpO1xuICB9O1xuICBfcHJvdG8uX3BsdXNVbml0ID0gZnVuY3Rpb24gX3BsdXNVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9BZGQsICdhbW91bnRUb0FkZCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHVuaXQsIFRlbXBvcmFsVW5pdCk7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhhbW91bnRUb0FkZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01pY3JvcyhhbW91bnRUb0FkZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMSVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01pbGxpcyhhbW91bnRUb0FkZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTlVURVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IT1VSUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKSk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IQUxGX0RBWVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZIC8gMikpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuREFZUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNTZWNvbmRzID0gZnVuY3Rpb24gcGx1c1NlY29uZHMoc2Vjb25kc1RvQWRkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXMoc2Vjb25kc1RvQWRkLCAwKTtcbiAgfTtcbiAgX3Byb3RvLnBsdXNNaWxsaXMgPSBmdW5jdGlvbiBwbHVzTWlsbGlzKG1pbGxpc1RvQWRkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXMoTWF0aFV0aWwuaW50RGl2KG1pbGxpc1RvQWRkLCAxMDAwKSwgTWF0aFV0aWwuaW50TW9kKG1pbGxpc1RvQWRkLCAxMDAwKSAqIE5BTk9TX1BFUl9NSUxMSSk7XG4gIH07XG4gIF9wcm90by5wbHVzTmFub3MgPSBmdW5jdGlvbiBwbHVzTmFub3MobmFub3NUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVzKDAsIG5hbm9zVG9BZGQpO1xuICB9O1xuICBfcHJvdG8ucGx1c01pY3JvcyA9IGZ1bmN0aW9uIHBsdXNNaWNyb3MobWljcm9zVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1cyhNYXRoVXRpbC5pbnREaXYobWljcm9zVG9BZGQsIDEwMDAwMDApLCBNYXRoVXRpbC5pbnRNb2QobWljcm9zVG9BZGQsIDEwMDAwMDApICogMTAwMCk7XG4gIH07XG4gIF9wcm90by5fcGx1cyA9IGZ1bmN0aW9uIF9wbHVzKHNlY29uZHNUb0FkZCwgbmFub3NUb0FkZCkge1xuICAgIGlmIChzZWNvbmRzVG9BZGQgPT09IDAgJiYgbmFub3NUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBlcG9jaFNlYyA9IHRoaXMuX3NlY29uZHMgKyBzZWNvbmRzVG9BZGQ7XG4gICAgZXBvY2hTZWMgPSBlcG9jaFNlYyArIE1hdGhVdGlsLmludERpdihuYW5vc1RvQWRkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgdmFyIG5hbm9BZGp1c3RtZW50ID0gdGhpcy5fbmFub3MgKyBuYW5vc1RvQWRkICUgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgcmV0dXJuIEluc3RhbnQub2ZFcG9jaFNlY29uZChlcG9jaFNlYywgbmFub0FkanVzdG1lbnQpO1xuICB9O1xuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVzVW5pdCgtMSAqIGFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuICBfcHJvdG8ubWludXNTZWNvbmRzID0gZnVuY3Rpb24gbWludXNTZWNvbmRzKHNlY29uZHNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoc2Vjb25kc1RvU3VidHJhY3QgKiAtMSk7XG4gIH07XG4gIF9wcm90by5taW51c01pbGxpcyA9IGZ1bmN0aW9uIG1pbnVzTWlsbGlzKG1pbGxpc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTWlsbGlzKC0xICogbWlsbGlzVG9TdWJ0cmFjdCk7XG4gIH07XG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTmFub3MoLTEgKiBuYW5vc1RvU3VidHJhY3QpO1xuICB9O1xuICBfcHJvdG8ubWludXNNaWNyb3MgPSBmdW5jdGlvbiBtaW51c01pY3JvcyhtaWNyb3NUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c01pY3JvcygtMSAqIG1pY3Jvc1RvU3VidHJhY3QpO1xuICB9O1xuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTkFOT1M7XG4gICAgfVxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMsIHRoaXMuX3NlY29uZHMpLndpdGgoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIHRoaXMuX25hbm9zKTtcbiAgfTtcbiAgX3Byb3RvLnVudGlsID0gZnVuY3Rpb24gdW50aWwoZW5kRXhjbHVzaXZlLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZW5kRXhjbHVzaXZlLCAnZW5kRXhjbHVzaXZlJyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICB2YXIgZW5kID0gSW5zdGFudC5mcm9tKGVuZEV4Y2x1c2l2ZSk7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9uYW5vc1VudGlsKGVuZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21pY3Jvc1VudGlsKGVuZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMSVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChlbmQudG9FcG9jaE1pbGxpKCksIHRoaXMudG9FcG9jaE1pbGxpKCkpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vjb25kc1VudGlsKGVuZCk7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSU5VVEVTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kc1VudGlsKGVuZCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9zZWNvbmRzVW50aWwoZW5kKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kc1VudGlsKGVuZCksIDEyICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuREFZUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHNVbnRpbChlbmQpLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcbiAgX3Byb3RvLl9taWNyb3NVbnRpbCA9IGZ1bmN0aW9uIF9taWNyb3NVbnRpbChlbmQpIHtcbiAgICB2YXIgc2Vjc0RpZmYgPSBNYXRoVXRpbC5zYWZlU3VidHJhY3QoZW5kLmVwb2NoU2Vjb25kKCksIHRoaXMuZXBvY2hTZWNvbmQoKSk7XG4gICAgdmFyIHRvdGFsTWljcm9zID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KHNlY3NEaWZmLCAxMDAwMDAwKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZCh0b3RhbE1pY3JvcywgTWF0aFV0aWwuaW50RGl2KGVuZC5uYW5vKCkgLSB0aGlzLm5hbm8oKSwgMTAwMCkpO1xuICB9O1xuICBfcHJvdG8uX25hbm9zVW50aWwgPSBmdW5jdGlvbiBfbmFub3NVbnRpbChlbmQpIHtcbiAgICB2YXIgc2Vjc0RpZmYgPSBNYXRoVXRpbC5zYWZlU3VidHJhY3QoZW5kLmVwb2NoU2Vjb25kKCksIHRoaXMuZXBvY2hTZWNvbmQoKSk7XG4gICAgdmFyIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoc2Vjc0RpZmYsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZCh0b3RhbE5hbm9zLCBlbmQubmFubygpIC0gdGhpcy5uYW5vKCkpO1xuICB9O1xuICBfcHJvdG8uX3NlY29uZHNVbnRpbCA9IGZ1bmN0aW9uIF9zZWNvbmRzVW50aWwoZW5kKSB7XG4gICAgdmFyIHNlY3NEaWZmID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGVuZC5lcG9jaFNlY29uZCgpLCB0aGlzLmVwb2NoU2Vjb25kKCkpO1xuICAgIHZhciBuYW5vc0RpZmYgPSBlbmQubmFubygpIC0gdGhpcy5uYW5vKCk7XG4gICAgaWYgKHNlY3NEaWZmID4gMCAmJiBuYW5vc0RpZmYgPCAwKSB7XG4gICAgICBzZWNzRGlmZi0tO1xuICAgIH0gZWxzZSBpZiAoc2Vjc0RpZmYgPCAwICYmIG5hbm9zRGlmZiA+IDApIHtcbiAgICAgIHNlY3NEaWZmKys7XG4gICAgfVxuICAgIHJldHVybiBzZWNzRGlmZjtcbiAgfTtcbiAgX3Byb3RvLmF0T2Zmc2V0ID0gZnVuY3Rpb24gYXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mSW5zdGFudCh0aGlzLCBvZmZzZXQpO1xuICB9O1xuICBfcHJvdG8uYXRab25lID0gZnVuY3Rpb24gYXRab25lKHpvbmUpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQodGhpcywgem9uZSk7XG4gIH07XG4gIF9wcm90by50b0Vwb2NoTWlsbGkgPSBmdW5jdGlvbiB0b0Vwb2NoTWlsbGkoKSB7XG4gICAgdmFyIG1pbGxpcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl9zZWNvbmRzLCAxMDAwKTtcbiAgICByZXR1cm4gbWlsbGlzICsgTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm9zLCBOQU5PU19QRVJfTUlMTEkpO1xuICB9O1xuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVySW5zdGFudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVySW5zdGFudCwgJ290aGVySW5zdGFudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlckluc3RhbnQsIEluc3RhbnQsICdvdGhlckluc3RhbnQnKTtcbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fc2Vjb25kcywgb3RoZXJJbnN0YW50Ll9zZWNvbmRzKTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbmFub3MgLSBvdGhlckluc3RhbnQuX25hbm9zO1xuICB9O1xuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXJJbnN0YW50KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVySW5zdGFudCkgPiAwO1xuICB9O1xuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlckluc3RhbnQpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXJJbnN0YW50KSA8IDA7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBJbnN0YW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5lcG9jaFNlY29uZCgpID09PSBvdGhlci5lcG9jaFNlY29uZCgpICYmIHRoaXMubmFubygpID09PSBvdGhlci5uYW5vKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2hDb2RlKHRoaXMuX3NlY29uZHMsIHRoaXMuX25hbm9zKTtcbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lRm9ybWF0dGVyLklTT19JTlNUQU5ULmZvcm1hdCh0aGlzKTtcbiAgfTtcbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICByZXR1cm4gSW5zdGFudDtcbn0oVGVtcG9yYWwpO1xuZnVuY3Rpb24gX2luaXQkMigpIHtcbiAgSW5zdGFudC5NSU5fU0VDT05EUyA9IC0zMTYxOTExOTIxOTIwMDtcbiAgSW5zdGFudC5NQVhfU0VDT05EUyA9IDMxNDk0ODE2NDAzMTk5O1xuICBJbnN0YW50LkVQT0NIID0gbmV3IEluc3RhbnQoMCwgMCk7XG4gIEluc3RhbnQuTUlOID0gSW5zdGFudC5vZkVwb2NoU2Vjb25kKEluc3RhbnQuTUlOX1NFQ09ORFMsIDApO1xuICBJbnN0YW50Lk1BWCA9IEluc3RhbnQub2ZFcG9jaFNlY29uZChJbnN0YW50Lk1BWF9TRUNPTkRTLCA5OTk5OTk5OTkpO1xuICBJbnN0YW50LkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdJbnN0YW50LkZST00nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gSW5zdGFudC5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBDbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2xvY2soKSB7fVxuICBDbG9jay5zeXN0ZW1VVEMgPSBmdW5jdGlvbiBzeXN0ZW1VVEMoKSB7XG4gICAgcmV0dXJuIG5ldyBTeXN0ZW1DbG9jayhab25lT2Zmc2V0LlVUQyk7XG4gIH07XG4gIENsb2NrLnN5c3RlbURlZmF1bHRab25lID0gZnVuY3Rpb24gc3lzdGVtRGVmYXVsdFpvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBTeXN0ZW1DbG9jayhab25lSWQuc3lzdGVtRGVmYXVsdCgpKTtcbiAgfTtcbiAgQ2xvY2suc3lzdGVtID0gZnVuY3Rpb24gc3lzdGVtKHpvbmUpIHtcbiAgICByZXR1cm4gbmV3IFN5c3RlbUNsb2NrKHpvbmUpO1xuICB9O1xuICBDbG9jay5maXhlZCA9IGZ1bmN0aW9uIGZpeGVkKGZpeGVkSW5zdGFudCwgem9uZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBGaXhlZENsb2NrKGZpeGVkSW5zdGFudCwgem9uZUlkKTtcbiAgfTtcbiAgQ2xvY2sub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KGJhc2VDbG9jaywgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IE9mZnNldENsb2NrKGJhc2VDbG9jaywgZHVyYXRpb24pO1xuICB9O1xuICB2YXIgX3Byb3RvID0gQ2xvY2sucHJvdG90eXBlO1xuICBfcHJvdG8ubWlsbGlzID0gZnVuY3Rpb24gbWlsbGlzKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnQ2xvY2subWlsbGlzJyk7XG4gIH07XG4gIF9wcm90by5pbnN0YW50ID0gZnVuY3Rpb24gaW5zdGFudCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ0Nsb2NrLmluc3RhbnQnKTtcbiAgfTtcbiAgX3Byb3RvLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnQ2xvY2suem9uZScpO1xuICB9O1xuICBfcHJvdG8ud2l0aFpvbmUgPSBmdW5jdGlvbiB3aXRoWm9uZSgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ0Nsb2NrLndpdGhab25lJyk7XG4gIH07XG4gIHJldHVybiBDbG9jaztcbn0oKTtcbnZhciBTeXN0ZW1DbG9jayA9IGZ1bmN0aW9uIChfQ2xvY2spIHtcbiAgX2luaGVyaXRzTG9vc2UoU3lzdGVtQ2xvY2ssIF9DbG9jayk7XG4gIGZ1bmN0aW9uIFN5c3RlbUNsb2NrKHpvbmUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICBfdGhpcyA9IF9DbG9jay5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3pvbmUgPSB6b25lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvMiA9IFN5c3RlbUNsb2NrLnByb3RvdHlwZTtcbiAgX3Byb3RvMi56b25lID0gZnVuY3Rpb24gem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfTtcbiAgX3Byb3RvMi5taWxsaXMgPSBmdW5jdGlvbiBtaWxsaXMoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuICBfcHJvdG8yLmluc3RhbnQgPSBmdW5jdGlvbiBpbnN0YW50KCkge1xuICAgIHJldHVybiBJbnN0YW50Lm9mRXBvY2hNaWxsaSh0aGlzLm1pbGxpcygpKTtcbiAgfTtcbiAgX3Byb3RvMi5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFN5c3RlbUNsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fem9uZS5lcXVhbHMob2JqLl96b25lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8yLndpdGhab25lID0gZnVuY3Rpb24gd2l0aFpvbmUoem9uZSkge1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLl96b25lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3lzdGVtQ2xvY2soem9uZSk7XG4gIH07XG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJTeXN0ZW1DbG9ja1tcIiArIHRoaXMuX3pvbmUudG9TdHJpbmcoKSArIFwiXVwiO1xuICB9O1xuICByZXR1cm4gU3lzdGVtQ2xvY2s7XG59KENsb2NrKTtcbnZhciBGaXhlZENsb2NrID0gZnVuY3Rpb24gKF9DbG9jazIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRml4ZWRDbG9jaywgX0Nsb2NrMik7XG4gIGZ1bmN0aW9uIEZpeGVkQ2xvY2soZml4ZWRJbnN0YW50LCB6b25lSWQpIHtcbiAgICB2YXIgX3RoaXMyO1xuICAgIF90aGlzMiA9IF9DbG9jazIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzMi5faW5zdGFudCA9IGZpeGVkSW5zdGFudDtcbiAgICBfdGhpczIuX3pvbmVJZCA9IHpvbmVJZDtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIHZhciBfcHJvdG8zID0gRml4ZWRDbG9jay5wcm90b3R5cGU7XG4gIF9wcm90bzMuaW5zdGFudCA9IGZ1bmN0aW9uIGluc3RhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luc3RhbnQ7XG4gIH07XG4gIF9wcm90bzMubWlsbGlzID0gZnVuY3Rpb24gbWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnN0YW50LnRvRXBvY2hNaWxsaSgpO1xuICB9O1xuICBfcHJvdG8zLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lSWQ7XG4gIH07XG4gIF9wcm90bzMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0ZpeGVkQ2xvY2tbXSc7XG4gIH07XG4gIF9wcm90bzMuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBGaXhlZENsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5zdGFudC5lcXVhbHMob2JqLl9pbnN0YW50KSAmJiB0aGlzLl96b25lSWQuZXF1YWxzKG9iai5fem9uZUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8zLndpdGhab25lID0gZnVuY3Rpb24gd2l0aFpvbmUoem9uZSkge1xuICAgIGlmICh6b25lLmVxdWFscyh0aGlzLl96b25lSWQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaXhlZENsb2NrKHRoaXMuX2luc3RhbnQsIHpvbmUpO1xuICB9O1xuICByZXR1cm4gRml4ZWRDbG9jaztcbn0oQ2xvY2spO1xudmFyIE9mZnNldENsb2NrID0gZnVuY3Rpb24gKF9DbG9jazMpIHtcbiAgX2luaGVyaXRzTG9vc2UoT2Zmc2V0Q2xvY2ssIF9DbG9jazMpO1xuICBmdW5jdGlvbiBPZmZzZXRDbG9jayhiYXNlQ2xvY2ssIG9mZnNldCkge1xuICAgIHZhciBfdGhpczM7XG4gICAgX3RoaXMzID0gX0Nsb2NrMy5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMzLl9iYXNlQ2xvY2sgPSBiYXNlQ2xvY2s7XG4gICAgX3RoaXMzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuICB2YXIgX3Byb3RvNCA9IE9mZnNldENsb2NrLnByb3RvdHlwZTtcbiAgX3Byb3RvNC56b25lID0gZnVuY3Rpb24gem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZUNsb2NrLnpvbmUoKTtcbiAgfTtcbiAgX3Byb3RvNC53aXRoWm9uZSA9IGZ1bmN0aW9uIHdpdGhab25lKHpvbmUpIHtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy5fYmFzZUNsb2NrLnpvbmUoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9mZnNldENsb2NrKHRoaXMuX2Jhc2VDbG9jay53aXRoWm9uZSh6b25lKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvNC5taWxsaXMgPSBmdW5jdGlvbiBtaWxsaXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VDbG9jay5taWxsaXMoKSArIHRoaXMuX29mZnNldC50b01pbGxpcygpO1xuICB9O1xuICBfcHJvdG80Lmluc3RhbnQgPSBmdW5jdGlvbiBpbnN0YW50KCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlQ2xvY2suaW5zdGFudCgpLnBsdXModGhpcy5fb2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvNC5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE9mZnNldENsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYmFzZUNsb2NrLmVxdWFscyhvYmouX2Jhc2VDbG9jaykgJiYgdGhpcy5fb2Zmc2V0LmVxdWFscyhvYmouX29mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvNC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIk9mZnNldENsb2NrW1wiICsgdGhpcy5fYmFzZUNsb2NrICsgXCIsXCIgKyB0aGlzLl9vZmZzZXQgKyBcIl1cIjtcbiAgfTtcbiAgcmV0dXJuIE9mZnNldENsb2NrO1xufShDbG9jayk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG52YXIgWm9uZU9mZnNldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIFpvbmVPZmZzZXRUcmFuc2l0aW9uLm9mID0gZnVuY3Rpb24gb2YodHJhbnNpdGlvbiwgb2Zmc2V0QmVmb3JlLCBvZmZzZXRBZnRlcikge1xuICAgIHJldHVybiBuZXcgWm9uZU9mZnNldFRyYW5zaXRpb24odHJhbnNpdGlvbiwgb2Zmc2V0QmVmb3JlLCBvZmZzZXRBZnRlcik7XG4gIH07XG4gIGZ1bmN0aW9uIFpvbmVPZmZzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24sIG9mZnNldEJlZm9yZSwgb2Zmc2V0QWZ0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0cmFuc2l0aW9uLCAndHJhbnNpdGlvbicpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldEJlZm9yZSwgJ29mZnNldEJlZm9yZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldEFmdGVyLCAnb2Zmc2V0QWZ0ZXInKTtcbiAgICBpZiAob2Zmc2V0QmVmb3JlLmVxdWFscyhvZmZzZXRBZnRlcikpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ09mZnNldHMgbXVzdCBub3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zaXRpb24ubmFubygpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdOYW5vLW9mLXNlY29uZCBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICB0aGlzLl90cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdHJhbnNpdGlvbiA9IExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZCh0cmFuc2l0aW9uLCAwLCBvZmZzZXRCZWZvcmUpO1xuICAgIH1cbiAgICB0aGlzLl9vZmZzZXRCZWZvcmUgPSBvZmZzZXRCZWZvcmU7XG4gICAgdGhpcy5fb2Zmc2V0QWZ0ZXIgPSBvZmZzZXRBZnRlcjtcbiAgfVxuICB2YXIgX3Byb3RvID0gWm9uZU9mZnNldFRyYW5zaXRpb24ucHJvdG90eXBlO1xuICBfcHJvdG8uaW5zdGFudCA9IGZ1bmN0aW9uIGluc3RhbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24udG9JbnN0YW50KHRoaXMuX29mZnNldEJlZm9yZSk7XG4gIH07XG4gIF9wcm90by50b0Vwb2NoU2Vjb25kID0gZnVuY3Rpb24gdG9FcG9jaFNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbi50b0Vwb2NoU2Vjb25kKHRoaXMuX29mZnNldEJlZm9yZSk7XG4gIH07XG4gIF9wcm90by5kYXRlVGltZUJlZm9yZSA9IGZ1bmN0aW9uIGRhdGVUaW1lQmVmb3JlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uO1xuICB9O1xuICBfcHJvdG8uZGF0ZVRpbWVBZnRlciA9IGZ1bmN0aW9uIGRhdGVUaW1lQWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24ucGx1c1NlY29uZHModGhpcy5kdXJhdGlvblNlY29uZHMoKSk7XG4gIH07XG4gIF9wcm90by5vZmZzZXRCZWZvcmUgPSBmdW5jdGlvbiBvZmZzZXRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldEJlZm9yZTtcbiAgfTtcbiAgX3Byb3RvLm9mZnNldEFmdGVyID0gZnVuY3Rpb24gb2Zmc2V0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldEFmdGVyO1xuICB9O1xuICBfcHJvdG8uZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICByZXR1cm4gRHVyYXRpb24ub2ZTZWNvbmRzKHRoaXMuZHVyYXRpb25TZWNvbmRzKCkpO1xuICB9O1xuICBfcHJvdG8uZHVyYXRpb25TZWNvbmRzID0gZnVuY3Rpb24gZHVyYXRpb25TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRBZnRlci50b3RhbFNlY29uZHMoKSAtIHRoaXMuX29mZnNldEJlZm9yZS50b3RhbFNlY29uZHMoKTtcbiAgfTtcbiAgX3Byb3RvLmlzR2FwID0gZnVuY3Rpb24gaXNHYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldEFmdGVyLnRvdGFsU2Vjb25kcygpID4gdGhpcy5fb2Zmc2V0QmVmb3JlLnRvdGFsU2Vjb25kcygpO1xuICB9O1xuICBfcHJvdG8uaXNPdmVybGFwID0gZnVuY3Rpb24gaXNPdmVybGFwKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRBZnRlci50b3RhbFNlY29uZHMoKSA8IHRoaXMuX29mZnNldEJlZm9yZS50b3RhbFNlY29uZHMoKTtcbiAgfTtcbiAgX3Byb3RvLmlzVmFsaWRPZmZzZXQgPSBmdW5jdGlvbiBpc1ZhbGlkT2Zmc2V0KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmlzR2FwKCkgPyBmYWxzZSA6IHRoaXMuX29mZnNldEJlZm9yZS5lcXVhbHMob2Zmc2V0KSB8fCB0aGlzLl9vZmZzZXRBZnRlci5lcXVhbHMob2Zmc2V0KTtcbiAgfTtcbiAgX3Byb3RvLnZhbGlkT2Zmc2V0cyA9IGZ1bmN0aW9uIHZhbGlkT2Zmc2V0cygpIHtcbiAgICBpZiAodGhpcy5pc0dhcCgpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdGhpcy5fb2Zmc2V0QmVmb3JlLCB0aGlzLl9vZmZzZXRBZnRlcl07XG4gICAgfVxuICB9O1xuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW50KCkuY29tcGFyZVRvKHRyYW5zaXRpb24uaW5zdGFudCgpKTtcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFpvbmVPZmZzZXRUcmFuc2l0aW9uKSB7XG4gICAgICB2YXIgZCA9IG90aGVyO1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24uZXF1YWxzKGQuX3RyYW5zaXRpb24pICYmIHRoaXMuX29mZnNldEJlZm9yZS5lcXVhbHMoZC5vZmZzZXRCZWZvcmUoKSkgJiYgdGhpcy5fb2Zmc2V0QWZ0ZXIuZXF1YWxzKGQub2Zmc2V0QWZ0ZXIoKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24uaGFzaENvZGUoKSBeIHRoaXMuX29mZnNldEJlZm9yZS5oYXNoQ29kZSgpIF4gdGhpcy5fb2Zmc2V0QWZ0ZXIuaGFzaENvZGUoKSA+Pj4gMTY7XG4gIH07XG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlRyYW5zaXRpb25bXCIgKyAodGhpcy5pc0dhcCgpID8gJ0dhcCcgOiAnT3ZlcmxhcCcpICsgXCIgYXQgXCIgKyB0aGlzLl90cmFuc2l0aW9uLnRvU3RyaW5nKCkgKyB0aGlzLl9vZmZzZXRCZWZvcmUudG9TdHJpbmcoKSArIFwiIHRvIFwiICsgdGhpcy5fb2Zmc2V0QWZ0ZXIgKyBcIl1cIjtcbiAgfTtcbiAgcmV0dXJuIFpvbmVPZmZzZXRUcmFuc2l0aW9uO1xufSgpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxuZnVuY3Rpb24gX2luaXQkMSgpIHtcbiAgVGVtcG9yYWxRdWVyaWVzLlpPTkVfSUQgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdaT05FX0lEJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLnF1ZXJ5KFRlbXBvcmFsUXVlcmllcy5aT05FX0lEKTtcbiAgfSk7XG4gIFRlbXBvcmFsUXVlcmllcy5DSFJPTk8gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdDSFJPTk8nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLkNIUk9OTyk7XG4gIH0pO1xuICBUZW1wb3JhbFF1ZXJpZXMuUFJFQ0lTSU9OID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnUFJFQ0lTSU9OJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLnF1ZXJ5KFRlbXBvcmFsUXVlcmllcy5QUkVDSVNJT04pO1xuICB9KTtcbiAgVGVtcG9yYWxRdWVyaWVzLk9GRlNFVCA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ09GRlNFVCcsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykpIHtcbiAgICAgIHJldHVybiBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG4gIFRlbXBvcmFsUXVlcmllcy5aT05FID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnWk9ORScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHZhciB6b25lID0gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLlpPTkVfSUQpO1xuICAgIHJldHVybiB6b25lICE9IG51bGwgPyB6b25lIDogdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLk9GRlNFVCk7XG4gIH0pO1xuICBUZW1wb3JhbFF1ZXJpZXMuTE9DQUxfREFURSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0xPQ0FMX0RBVEUnLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSkge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KHRlbXBvcmFsLmdldExvbmcoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgVGVtcG9yYWxRdWVyaWVzLkxPQ0FMX1RJTUUgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMT0NBTF9USU1FJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKSkge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5vZk5hbm9PZkRheSh0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn1cblxudmFyIFN5c3RlbURlZmF1bHRab25lUnVsZXMgPSBmdW5jdGlvbiAoX1pvbmVSdWxlcykge1xuICBfaW5oZXJpdHNMb29zZShTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzLCBfWm9uZVJ1bGVzKTtcbiAgZnVuY3Rpb24gU3lzdGVtRGVmYXVsdFpvbmVSdWxlcygpIHtcbiAgICByZXR1cm4gX1pvbmVSdWxlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9wcm90byA9IFN5c3RlbURlZmF1bHRab25lUnVsZXMucHJvdG90eXBlO1xuICBfcHJvdG8uaXNGaXhlZE9mZnNldCA9IGZ1bmN0aW9uIGlzRml4ZWRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfcHJvdG8ub2Zmc2V0T2ZJbnN0YW50ID0gZnVuY3Rpb24gb2Zmc2V0T2ZJbnN0YW50KGluc3RhbnQpIHtcbiAgICB2YXIgb2Zmc2V0SW5NaW51dGVzID0gbmV3IERhdGUoaW5zdGFudC50b0Vwb2NoTWlsbGkoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICByZXR1cm4gWm9uZU9mZnNldC5vZlRvdGFsTWludXRlcyhvZmZzZXRJbk1pbnV0ZXMgKiAtMSk7XG4gIH07XG4gIF9wcm90by5vZmZzZXRPZkVwb2NoTWlsbGkgPSBmdW5jdGlvbiBvZmZzZXRPZkVwb2NoTWlsbGkoZXBvY2hNaWxsaSkge1xuICAgIHZhciBvZmZzZXRJbk1pbnV0ZXMgPSBuZXcgRGF0ZShlcG9jaE1pbGxpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiBab25lT2Zmc2V0Lm9mVG90YWxNaW51dGVzKG9mZnNldEluTWludXRlcyAqIC0xKTtcbiAgfTtcbiAgX3Byb3RvLm9mZnNldE9mTG9jYWxEYXRlVGltZSA9IGZ1bmN0aW9uIG9mZnNldE9mTG9jYWxEYXRlVGltZShsb2NhbERhdGVUaW1lKSB7XG4gICAgdmFyIGVwb2NoTWlsbGkgPSBsb2NhbERhdGVUaW1lLnRvRXBvY2hTZWNvbmQoWm9uZU9mZnNldC5VVEMpICogMTAwMDtcbiAgICB2YXIgb2Zmc2V0SW5NaW51dGVzQmVmb3JlUG9zc2libGVUcmFuc2l0aW9uID0gbmV3IERhdGUoZXBvY2hNaWxsaSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB2YXIgZXBvY2hNaWxsaVN5c3RlbVpvbmUgPSBlcG9jaE1pbGxpICsgb2Zmc2V0SW5NaW51dGVzQmVmb3JlUG9zc2libGVUcmFuc2l0aW9uICogNjAwMDA7XG4gICAgdmFyIG9mZnNldEluTWludXRlc0FmdGVyUG9zc2libGVUcmFuc2l0aW9uID0gbmV3IERhdGUoZXBvY2hNaWxsaVN5c3RlbVpvbmUpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZUb3RhbE1pbnV0ZXMob2Zmc2V0SW5NaW51dGVzQWZ0ZXJQb3NzaWJsZVRyYW5zaXRpb24gKiAtMSk7XG4gIH07XG4gIF9wcm90by52YWxpZE9mZnNldHMgPSBmdW5jdGlvbiB2YWxpZE9mZnNldHMobG9jYWxEYXRlVGltZSkge1xuICAgIHJldHVybiBbdGhpcy5vZmZzZXRPZkxvY2FsRGF0ZVRpbWUobG9jYWxEYXRlVGltZSldO1xuICB9O1xuICBfcHJvdG8udHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIF9wcm90by5zdGFuZGFyZE9mZnNldCA9IGZ1bmN0aW9uIHN0YW5kYXJkT2Zmc2V0KGluc3RhbnQpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRPZkluc3RhbnQoaW5zdGFudCk7XG4gIH07XG4gIF9wcm90by5kYXlsaWdodFNhdmluZ3MgPSBmdW5jdGlvbiBkYXlsaWdodFNhdmluZ3MoKSB7XG4gICAgdGhpcy5fdGhyb3dOb3RTdXBwb3J0ZWQoKTtcbiAgfTtcbiAgX3Byb3RvLmlzRGF5bGlnaHRTYXZpbmdzID0gZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ3MoKSB7XG4gICAgdGhpcy5fdGhyb3dOb3RTdXBwb3J0ZWQoKTtcbiAgfTtcbiAgX3Byb3RvLmlzVmFsaWRPZmZzZXQgPSBmdW5jdGlvbiBpc1ZhbGlkT2Zmc2V0KGRhdGVUaW1lLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRPZkxvY2FsRGF0ZVRpbWUoZGF0ZVRpbWUpLmVxdWFscyhvZmZzZXQpO1xuICB9O1xuICBfcHJvdG8ubmV4dFRyYW5zaXRpb24gPSBmdW5jdGlvbiBuZXh0VHJhbnNpdGlvbigpIHtcbiAgICB0aGlzLl90aHJvd05vdFN1cHBvcnRlZCgpO1xuICB9O1xuICBfcHJvdG8ucHJldmlvdXNUcmFuc2l0aW9uID0gZnVuY3Rpb24gcHJldmlvdXNUcmFuc2l0aW9uKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG4gIF9wcm90by50cmFuc2l0aW9ucyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25zKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG4gIF9wcm90by50cmFuc2l0aW9uUnVsZXMgPSBmdW5jdGlvbiB0cmFuc2l0aW9uUnVsZXMoKSB7XG4gICAgdGhpcy5fdGhyb3dOb3RTdXBwb3J0ZWQoKTtcbiAgfTtcbiAgX3Byb3RvLl90aHJvd05vdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIF90aHJvd05vdFN1cHBvcnRlZCgpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ25vdCBzdXBwb3J0ZWQgb3BlcmF0aW9uJyk7XG4gIH07XG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIgfHwgb3RoZXIgaW5zdGFuY2VvZiBTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTWVNURU0nO1xuICB9O1xuICByZXR1cm4gU3lzdGVtRGVmYXVsdFpvbmVSdWxlcztcbn0oWm9uZVJ1bGVzKTtcblxudmFyIFN5c3RlbURlZmF1bHRab25lSWQgPSBmdW5jdGlvbiAoX1pvbmVJZCkge1xuICBfaW5oZXJpdHNMb29zZShTeXN0ZW1EZWZhdWx0Wm9uZUlkLCBfWm9uZUlkKTtcbiAgZnVuY3Rpb24gU3lzdGVtRGVmYXVsdFpvbmVJZCgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX3RoaXMgPSBfWm9uZUlkLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fcnVsZXMgPSBuZXcgU3lzdGVtRGVmYXVsdFpvbmVSdWxlcygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX3Byb3RvID0gU3lzdGVtRGVmYXVsdFpvbmVJZC5wcm90b3R5cGU7XG4gIF9wcm90by5ydWxlcyA9IGZ1bmN0aW9uIHJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ydWxlcztcbiAgfTtcbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX3Byb3RvLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuICdTWVNURU0nO1xuICB9O1xuICByZXR1cm4gU3lzdGVtRGVmYXVsdFpvbmVJZDtcbn0oWm9uZUlkKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBab25lSWRGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lSWRGYWN0b3J5KCkge31cbiAgWm9uZUlkRmFjdG9yeS5zeXN0ZW1EZWZhdWx0ID0gZnVuY3Rpb24gc3lzdGVtRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gU1lTVEVNX0RFRkFVTFRfWk9ORV9JRF9JTlNUQU5DRTtcbiAgfTtcbiAgWm9uZUlkRmFjdG9yeS5nZXRBdmFpbGFibGVab25lSWRzID0gZnVuY3Rpb24gZ2V0QXZhaWxhYmxlWm9uZUlkcygpIHtcbiAgICByZXR1cm4gWm9uZVJ1bGVzUHJvdmlkZXIuZ2V0QXZhaWxhYmxlWm9uZUlkcygpO1xuICB9O1xuICBab25lSWRGYWN0b3J5Lm9mID0gZnVuY3Rpb24gb2Yoem9uZUlkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZUlkLCAnem9uZUlkJyk7XG4gICAgaWYgKHpvbmVJZCA9PT0gJ1onKSB7XG4gICAgICByZXR1cm4gWm9uZU9mZnNldC5VVEM7XG4gICAgfVxuICAgIGlmICh6b25lSWQubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbnZhbGlkIHpvbmU6IFwiICsgem9uZUlkKTtcbiAgICB9XG4gICAgaWYgKFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICcrJykgfHwgU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJy0nKSkge1xuICAgICAgcmV0dXJuIFpvbmVPZmZzZXQub2Yoem9uZUlkKTtcbiAgICB9XG4gICAgaWYgKHpvbmVJZCA9PT0gJ1VUQycgfHwgem9uZUlkID09PSAnR01UJyB8fCB6b25lSWQgPT09ICdHTVQwJyB8fCB6b25lSWQgPT09ICdVVCcpIHtcbiAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbih6b25lSWQsIFpvbmVPZmZzZXQuVVRDLnJ1bGVzKCkpO1xuICAgIH1cbiAgICBpZiAoU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJ1VUQysnKSB8fCBTdHJpbmdVdGlsLnN0YXJ0c1dpdGgoem9uZUlkLCAnR01UKycpIHx8IFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICdVVEMtJykgfHwgU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJ0dNVC0nKSkge1xuICAgICAgdmFyIG9mZnNldCA9IFpvbmVPZmZzZXQub2Yoem9uZUlkLnN1YnN0cmluZygzKSk7XG4gICAgICBpZiAob2Zmc2V0LnRvdGFsU2Vjb25kcygpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbih6b25lSWQuc3Vic3RyaW5nKDAsIDMpLCBvZmZzZXQucnVsZXMoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFpvbmVSZWdpb24oem9uZUlkLnN1YnN0cmluZygwLCAzKSArIG9mZnNldC5pZCgpLCBvZmZzZXQucnVsZXMoKSk7XG4gICAgfVxuICAgIGlmIChTdHJpbmdVdGlsLnN0YXJ0c1dpdGgoem9uZUlkLCAnVVQrJykgfHwgU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJ1VULScpKSB7XG4gICAgICB2YXIgX29mZnNldCA9IFpvbmVPZmZzZXQub2Yoem9uZUlkLnN1YnN0cmluZygyKSk7XG4gICAgICBpZiAoX29mZnNldC50b3RhbFNlY29uZHMoKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvbmVSZWdpb24oJ1VUJywgX29mZnNldC5ydWxlcygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbihcIlVUXCIgKyBfb2Zmc2V0LmlkKCksIF9vZmZzZXQucnVsZXMoKSk7XG4gICAgfVxuICAgIGlmICh6b25lSWQgPT09ICdTWVNURU0nKSB7XG4gICAgICByZXR1cm4gWm9uZUlkLnN5c3RlbURlZmF1bHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIFpvbmVSZWdpb24ub2ZJZCh6b25lSWQpO1xuICB9O1xuICBab25lSWRGYWN0b3J5Lm9mT2Zmc2V0ID0gZnVuY3Rpb24gb2ZPZmZzZXQocHJlZml4LCBvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChwcmVmaXgsICdwcmVmaXgnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgaWYgKHByZWZpeCA9PT0gJ0dNVCcgfHwgcHJlZml4ID09PSAnVVRDJyB8fCBwcmVmaXggPT09ICdVVCcpIHtcbiAgICAgIGlmIChvZmZzZXQudG90YWxTZWNvbmRzKCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHByZWZpeCwgb2Zmc2V0LnJ1bGVzKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHByZWZpeCArIG9mZnNldC5pZCgpLCBvZmZzZXQucnVsZXMoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJJbnZhbGlkIHByZWZpeCwgbXVzdCBiZSBHTVQsIFVUQyBvciBVVDogXCIgKyBwcmVmaXgpO1xuICB9O1xuICBab25lSWRGYWN0b3J5LmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHZhciBvYmogPSB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKTtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gWm9uZUlkIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiLCB0eXBlIFwiICsgKHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgcmV0dXJuIFpvbmVJZEZhY3Rvcnk7XG59KCk7XG52YXIgU1lTVEVNX0RFRkFVTFRfWk9ORV9JRF9JTlNUQU5DRSA9IG51bGw7XG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgU1lTVEVNX0RFRkFVTFRfWk9ORV9JRF9JTlNUQU5DRSA9IG5ldyBTeXN0ZW1EZWZhdWx0Wm9uZUlkKCk7XG4gIFpvbmVJZC5zeXN0ZW1EZWZhdWx0ID0gWm9uZUlkRmFjdG9yeS5zeXN0ZW1EZWZhdWx0O1xuICBab25lSWQuZ2V0QXZhaWxhYmxlWm9uZUlkcyA9IFpvbmVJZEZhY3RvcnkuZ2V0QXZhaWxhYmxlWm9uZUlkcztcbiAgWm9uZUlkLm9mID0gWm9uZUlkRmFjdG9yeS5vZjtcbiAgWm9uZUlkLm9mT2Zmc2V0ID0gWm9uZUlkRmFjdG9yeS5vZk9mZnNldDtcbiAgWm9uZUlkLmZyb20gPSBab25lSWRGYWN0b3J5LmZyb207XG4gIFpvbmVPZmZzZXQuZnJvbSA9IFpvbmVJZEZhY3RvcnkuZnJvbTtcbiAgWm9uZUlkLlNZU1RFTSA9IFNZU1RFTV9ERUZBVUxUX1pPTkVfSURfSU5TVEFOQ0U7XG4gIFpvbmVJZC5VVEMgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKDApO1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBpc0luaXQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGlmIChpc0luaXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXNJbml0ID0gdHJ1ZTtcbiAgX2luaXQkbSgpO1xuICBfaW5pdCRuKCk7XG4gIF9pbml0JGwoKTtcbiAgX2luaXQkaygpO1xuICBfaW5pdCQzKCk7XG4gIF9pbml0JGYoKTtcbiAgX2luaXQkMSgpO1xuICBfaW5pdCRqKCk7XG4gIF9pbml0JDIoKTtcbiAgX2luaXQkNSgpO1xuICBfaW5pdCQ0KCk7XG4gIF9pbml0JGEoKTtcbiAgX2luaXQkaSgpO1xuICBfaW5pdCRiKCk7XG4gIF9pbml0JGMoKTtcbiAgX2luaXQkaCgpO1xuICBfaW5pdCRnKCk7XG4gIF9pbml0JDcoKTtcbiAgX2luaXQoKTtcbiAgX2luaXQkOSgpO1xuICBfaW5pdCRkKCk7XG4gIF9pbml0JGUoKTtcbiAgX2luaXQkNigpO1xuICBfaW5pdCQ4KCk7XG59XG5pbml0KCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cblxudmFyIFRvTmF0aXZlSnNDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvTmF0aXZlSnNDb252ZXJ0ZXIodGVtcG9yYWwsIHpvbmUpIHtcbiAgICB2YXIgem9uZWREYXRlVGltZTtcbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBJbnN0YW50KSB7XG4gICAgICB0aGlzLmluc3RhbnQgPSB0ZW1wb3JhbDtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgTG9jYWxEYXRlKSB7XG4gICAgICB6b25lID0gem9uZSA9PSBudWxsID8gWm9uZUlkLnN5c3RlbURlZmF1bHQoKSA6IHpvbmU7XG4gICAgICB6b25lZERhdGVUaW1lID0gdGVtcG9yYWwuYXRTdGFydE9mRGF5KHpvbmUpO1xuICAgIH0gZWxzZSBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICB6b25lID0gem9uZSA9PSBudWxsID8gWm9uZUlkLnN5c3RlbURlZmF1bHQoKSA6IHpvbmU7XG4gICAgICB6b25lZERhdGVUaW1lID0gdGVtcG9yYWwuYXRab25lKHpvbmUpO1xuICAgIH0gZWxzZSBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBab25lZERhdGVUaW1lKSB7XG4gICAgICBpZiAoem9uZSA9PSBudWxsKSB7XG4gICAgICAgIHpvbmVkRGF0ZVRpbWUgPSB0ZW1wb3JhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvbmVkRGF0ZVRpbWUgPSB0ZW1wb3JhbC53aXRoWm9uZVNhbWVJbnN0YW50KHpvbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwidW5zdXBwb3J0ZWQgaW5zdGFuY2UgZm9yIGNvbnZlcnQgb3BlcmF0aW9uOlwiICsgdGVtcG9yYWwpO1xuICAgIH1cbiAgICB0aGlzLmluc3RhbnQgPSB6b25lZERhdGVUaW1lLnRvSW5zdGFudCgpO1xuICB9XG4gIHZhciBfcHJvdG8gPSBUb05hdGl2ZUpzQ29udmVydGVyLnByb3RvdHlwZTtcbiAgX3Byb3RvLnRvRGF0ZSA9IGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pbnN0YW50LnRvRXBvY2hNaWxsaSgpKTtcbiAgfTtcbiAgX3Byb3RvLnRvRXBvY2hNaWxsaSA9IGZ1bmN0aW9uIHRvRXBvY2hNaWxsaSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW50LnRvRXBvY2hNaWxsaSgpO1xuICB9O1xuICByZXR1cm4gVG9OYXRpdmVKc0NvbnZlcnRlcjtcbn0oKTtcbmZ1bmN0aW9uIGNvbnZlcnQodGVtcG9yYWwsIHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBUb05hdGl2ZUpzQ29udmVydGVyKHRlbXBvcmFsLCB6b25lKTtcbn1cblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgUGhpbGlwcCBUaMO8cnfDpGNodGVyLCBQYXR0cmljayBIw7xwZXIgJiBqcy1qb2RhIGNvbnRyaWJ1dG9yc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG5mdW5jdGlvbiBuYXRpdmVKcyhkYXRlLCB6b25lKSB7XG4gIGlmICh6b25lID09PSB2b2lkIDApIHtcbiAgICB6b25lID0gWm9uZUlkLnN5c3RlbURlZmF1bHQoKTtcbiAgfVxuICByZXF1aXJlTm9uTnVsbChkYXRlLCAnZGF0ZScpO1xuICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gSW5zdGFudC5vZkVwb2NoTWlsbGkoZGF0ZS5nZXRUaW1lKCkpLmF0Wm9uZSh6b25lKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0ZS50b0RhdGUgPT09ICdmdW5jdGlvbicgJiYgZGF0ZS50b0RhdGUoKSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gSW5zdGFudC5vZkVwb2NoTWlsbGkoZGF0ZS50b0RhdGUoKS5nZXRUaW1lKCkpLmF0Wm9uZSh6b25lKTtcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdkYXRlIG11c3QgYmUgYSBqYXZhc2NyaXB0IERhdGUgb3IgYSBtb21lbnQgaW5zdGFuY2UnKTtcbn1cblxuZnVuY3Rpb24gYmluZFVzZShqc0pvZGEpIHtcbiAgdmFyIHVzZWQgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZShmbikge1xuICAgIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICAgIGZuKGpzSm9kYSk7XG4gICAgICB1c2VkLnB1c2goZm4pO1xuICAgIH1cbiAgICByZXR1cm4ganNKb2RhO1xuICB9O1xufVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG52YXIgXyA9IHtcbiAgYXNzZXJ0OiBhc3NlcnQkMSxcbiAgRGF0ZVRpbWVCdWlsZGVyOiBEYXRlVGltZUJ1aWxkZXIsXG4gIERhdGVUaW1lUGFyc2VDb250ZXh0OiBEYXRlVGltZVBhcnNlQ29udGV4dCxcbiAgRGF0ZVRpbWVQcmludENvbnRleHQ6IERhdGVUaW1lUHJpbnRDb250ZXh0LFxuICBNYXRoVXRpbDogTWF0aFV0aWwsXG4gIFN0cmluZ1V0aWw6IFN0cmluZ1V0aWwsXG4gIFN0cmluZ0J1aWxkZXI6IFN0cmluZ0J1aWxkZXJcbn07XG52YXIganNKb2RhRXhwb3J0cyA9IHtcbiAgXzogXyxcbiAgY29udmVydDogY29udmVydCxcbiAgbmF0aXZlSnM6IG5hdGl2ZUpzLFxuICBBcml0aG1ldGljRXhjZXB0aW9uOiBBcml0aG1ldGljRXhjZXB0aW9uLFxuICBEYXRlVGltZUV4Y2VwdGlvbjogRGF0ZVRpbWVFeGNlcHRpb24sXG4gIERhdGVUaW1lUGFyc2VFeGNlcHRpb246IERhdGVUaW1lUGFyc2VFeGNlcHRpb24sXG4gIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjogSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLFxuICBJbGxlZ2FsU3RhdGVFeGNlcHRpb246IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbixcbiAgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb246IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uLFxuICBOdWxsUG9pbnRlckV4Y2VwdGlvbjogTnVsbFBvaW50ZXJFeGNlcHRpb24sXG4gIENsb2NrOiBDbG9jayxcbiAgRGF5T2ZXZWVrOiBEYXlPZldlZWssXG4gIER1cmF0aW9uOiBEdXJhdGlvbixcbiAgSW5zdGFudDogSW5zdGFudCxcbiAgTG9jYWxEYXRlOiBMb2NhbERhdGUsXG4gIExvY2FsVGltZTogTG9jYWxUaW1lLFxuICBMb2NhbERhdGVUaW1lOiBMb2NhbERhdGVUaW1lLFxuICBPZmZzZXRUaW1lOiBPZmZzZXRUaW1lLFxuICBPZmZzZXREYXRlVGltZTogT2Zmc2V0RGF0ZVRpbWUsXG4gIE1vbnRoOiBNb250aCxcbiAgTW9udGhEYXk6IE1vbnRoRGF5LFxuICBQYXJzZVBvc2l0aW9uOiBQYXJzZVBvc2l0aW9uLFxuICBQZXJpb2Q6IFBlcmlvZCxcbiAgWWVhcjogWWVhcixcbiAgWWVhckNvbnN0YW50czogWWVhckNvbnN0YW50cyxcbiAgWWVhck1vbnRoOiBZZWFyTW9udGgsXG4gIFpvbmVkRGF0ZVRpbWU6IFpvbmVkRGF0ZVRpbWUsXG4gIFpvbmVPZmZzZXQ6IFpvbmVPZmZzZXQsXG4gIFpvbmVJZDogWm9uZUlkLFxuICBab25lUmVnaW9uOiBab25lUmVnaW9uLFxuICBab25lT2Zmc2V0VHJhbnNpdGlvbjogWm9uZU9mZnNldFRyYW5zaXRpb24sXG4gIFpvbmVSdWxlczogWm9uZVJ1bGVzLFxuICBab25lUnVsZXNQcm92aWRlcjogWm9uZVJ1bGVzUHJvdmlkZXIsXG4gIENocm9ub0xvY2FsRGF0ZTogQ2hyb25vTG9jYWxEYXRlLFxuICBDaHJvbm9Mb2NhbERhdGVUaW1lOiBDaHJvbm9Mb2NhbERhdGVUaW1lLFxuICBDaHJvbm9ab25lZERhdGVUaW1lOiBDaHJvbm9ab25lZERhdGVUaW1lLFxuICBJc29DaHJvbm9sb2d5OiBJc29DaHJvbm9sb2d5LFxuICBDaHJvbm9GaWVsZDogQ2hyb25vRmllbGQsXG4gIENocm9ub1VuaXQ6IENocm9ub1VuaXQsXG4gIElzb0ZpZWxkczogSXNvRmllbGRzLFxuICBUZW1wb3JhbDogVGVtcG9yYWwsXG4gIFRlbXBvcmFsQWNjZXNzb3I6IFRlbXBvcmFsQWNjZXNzb3IsXG4gIFRlbXBvcmFsQWRqdXN0ZXI6IFRlbXBvcmFsQWRqdXN0ZXIsXG4gIFRlbXBvcmFsQWRqdXN0ZXJzOiBUZW1wb3JhbEFkanVzdGVycyxcbiAgVGVtcG9yYWxBbW91bnQ6IFRlbXBvcmFsQW1vdW50LFxuICBUZW1wb3JhbEZpZWxkOiBUZW1wb3JhbEZpZWxkLFxuICBUZW1wb3JhbFF1ZXJpZXM6IFRlbXBvcmFsUXVlcmllcyxcbiAgVGVtcG9yYWxRdWVyeTogVGVtcG9yYWxRdWVyeSxcbiAgVGVtcG9yYWxVbml0OiBUZW1wb3JhbFVuaXQsXG4gIFZhbHVlUmFuZ2U6IFZhbHVlUmFuZ2UsXG4gIERhdGVUaW1lRm9ybWF0dGVyOiBEYXRlVGltZUZvcm1hdHRlcixcbiAgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyOiBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIsXG4gIERlY2ltYWxTdHlsZTogRGVjaW1hbFN0eWxlLFxuICBSZXNvbHZlclN0eWxlOiBSZXNvbHZlclN0eWxlLFxuICBTaWduU3R5bGU6IFNpZ25TdHlsZSxcbiAgVGV4dFN0eWxlOiBUZXh0U3R5bGVcbn07XG52YXIgdXNlID0gYmluZFVzZShqc0pvZGFFeHBvcnRzKTtcbmpzSm9kYUV4cG9ydHMudXNlID0gdXNlO1xuXG5leHBvcnQgeyBBcml0aG1ldGljRXhjZXB0aW9uLCBDaHJvbm9GaWVsZCwgQ2hyb25vTG9jYWxEYXRlLCBDaHJvbm9Mb2NhbERhdGVUaW1lLCBDaHJvbm9Vbml0LCBDaHJvbm9ab25lZERhdGVUaW1lLCBDbG9jaywgRGF0ZVRpbWVFeGNlcHRpb24sIERhdGVUaW1lRm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIsIERhdGVUaW1lUGFyc2VFeGNlcHRpb24sIERheU9mV2VlaywgRGVjaW1hbFN0eWxlLCBEdXJhdGlvbiwgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLCBJbGxlZ2FsU3RhdGVFeGNlcHRpb24sIEluc3RhbnQsIElzb0Nocm9ub2xvZ3ksIElzb0ZpZWxkcywgTG9jYWxEYXRlLCBMb2NhbERhdGVUaW1lLCBMb2NhbFRpbWUsIE1vbnRoLCBNb250aERheSwgTnVsbFBvaW50ZXJFeGNlcHRpb24sIE9mZnNldERhdGVUaW1lLCBPZmZzZXRUaW1lLCBQYXJzZVBvc2l0aW9uLCBQZXJpb2QsIFJlc29sdmVyU3R5bGUsIFNpZ25TdHlsZSwgVGVtcG9yYWwsIFRlbXBvcmFsQWNjZXNzb3IsIFRlbXBvcmFsQWRqdXN0ZXIsIFRlbXBvcmFsQWRqdXN0ZXJzLCBUZW1wb3JhbEFtb3VudCwgVGVtcG9yYWxGaWVsZCwgVGVtcG9yYWxRdWVyaWVzLCBUZW1wb3JhbFF1ZXJ5LCBUZW1wb3JhbFVuaXQsIFRleHRTdHlsZSwgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24sIFZhbHVlUmFuZ2UsIFllYXIsIFllYXJDb25zdGFudHMsIFllYXJNb250aCwgWm9uZUlkLCBab25lT2Zmc2V0LCBab25lT2Zmc2V0VHJhbnNpdGlvbiwgWm9uZVJlZ2lvbiwgWm9uZVJ1bGVzLCBab25lUnVsZXNQcm92aWRlciwgWm9uZWREYXRlVGltZSwgXywgY29udmVydCwgbmF0aXZlSnMsIHVzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anMtam9kYS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlRXJyb3JUeXBlIiwibmFtZSIsImluaXQiLCJzdXBlckVycm9yQ2xhc3MiLCJFcnJvciIsIkpzSm9kYUV4Y2VwdGlvbiIsIm1lc3NhZ2UiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInN0YWNrIiwiY29uc3RydWN0b3IiLCJhcHBseSIsImFyZ3VtZW50cyIsInRvU3RyaW5nIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiRGF0ZVRpbWVFeGNlcHRpb24iLCJtZXNzYWdlV2l0aENhdXNlIiwiRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbiIsIm1lc3NhZ2VGb3JEYXRlVGltZVBhcnNlRXhjZXB0aW9uIiwiVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24iLCJBcml0aG1ldGljRXhjZXB0aW9uIiwiSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIiwiSWxsZWdhbFN0YXRlRXhjZXB0aW9uIiwiTnVsbFBvaW50ZXJFeGNlcHRpb24iLCJjYXVzZSIsIm1zZyIsInRleHQiLCJpbmRleCIsInBhcnNlZFN0cmluZyIsImVycm9ySW5kZXgiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJiaW5kIiwiX19wcm90b19fIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsImFzc2VydCIsImFzc2VydGlvbiIsImVycm9yIiwicmVxdWlyZU5vbk51bGwiLCJ2YWx1ZSIsInBhcmFtZXRlck5hbWUiLCJyZXF1aXJlSW5zdGFuY2UiLCJfY2xhc3MiLCJhYnN0cmFjdE1ldGhvZEZhaWwiLCJtZXRob2ROYW1lIiwiVHlwZUVycm9yIiwiYXNzZXJ0JDEiLCJmcmVlemUiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIk1hdGhVdGlsIiwiaW50RGl2IiwieCIsInkiLCJyIiwicm91bmREb3duIiwic2FmZVplcm8iLCJpbnRNb2QiLCJNYXRoIiwiY2VpbCIsImZsb29yIiwiZmxvb3JEaXYiLCJmbG9vck1vZCIsInNhZmVBZGQiLCJ2ZXJpZnlJbnQiLCJzYWZlVG9JbnQiLCJzYWZlU3VidHJhY3QiLCJzYWZlTXVsdGlwbHkiLCJwYXJzZUludCIsIl9wYXJzZUludCIsIl94IiwiaXNOYU4iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJjb21wYXJlTnVtYmVycyIsImEiLCJiIiwic21pIiwiaW50IiwiaGFzaCIsIm51bWJlciIsIkluZmluaXR5IiwicmVzdWx0IiwiaGFzaENvZGUiLCJfbGVuIiwibGVuZ3RoIiwibnVtYmVycyIsIkFycmF5IiwiX2tleSIsIl9pIiwiX251bWJlcnMiLCJuIiwiRW51bSIsIl9uYW1lIiwiX3Byb3RvIiwiZXF1YWxzIiwib3RoZXIiLCJ0b0pTT04iLCJUZW1wb3JhbEFtb3VudCIsImdldCIsInVuaXQiLCJ1bml0cyIsImFkZFRvIiwidGVtcG9yYWwiLCJzdWJ0cmFjdEZyb20iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsImhpbnQiLCJUZW1wb3JhbFVuaXQiLCJkdXJhdGlvbiIsImlzRHVyYXRpb25Fc3RpbWF0ZWQiLCJpc0RhdGVCYXNlZCIsImlzVGltZUJhc2VkIiwiaXNTdXBwb3J0ZWRCeSIsImRhdGVUaW1lIiwicGVyaW9kVG9BZGQiLCJiZXR3ZWVuIiwidGVtcG9yYWwxIiwidGVtcG9yYWwyIiwiRHVyYXRpb24iLCJfVGVtcG9yYWxBbW91bnQiLCJzZWNvbmRzIiwibmFub3MiLCJfdGhpcyIsImNhbGwiLCJfc2Vjb25kcyIsIl9uYW5vcyIsIm9mRGF5cyIsImRheXMiLCJfY3JlYXRlIiwiTG9jYWxUaW1lIiwiU0VDT05EU19QRVJfREFZIiwib2ZIb3VycyIsImhvdXJzIiwiU0VDT05EU19QRVJfSE9VUiIsIm9mTWludXRlcyIsIm1pbnV0ZXMiLCJTRUNPTkRTX1BFUl9NSU5VVEUiLCJvZlNlY29uZHMiLCJuYW5vQWRqdXN0bWVudCIsInNlY3MiLCJOQU5PU19QRVJfU0VDT05EIiwibm9zIiwib2ZNaWxsaXMiLCJtaWxsaXMiLCJtb3MiLCJvZk5hbm9zIiwib2YiLCJhbW91bnQiLCJaRVJPIiwicGx1cyIsImZyb20iLCJmb3JFYWNoIiwic3RhcnRJbmNsdXNpdmUiLCJlbmRFeGNsdXNpdmUiLCJ1bnRpbCIsIkNocm9ub1VuaXQiLCJTRUNPTkRTIiwiaXNTdXBwb3J0ZWQiLCJDaHJvbm9GaWVsZCIsIk5BTk9fT0ZfU0VDT05EIiwic3RhcnROb3MiLCJnZXRMb25nIiwiYWRqdXN0ZWRFbmQiLCJ3aXRoIiwiZSIsInBhcnNlIiwiUEFUVEVSTiIsIlJlZ0V4cCIsIm1hdGNoZXMiLCJleGVjIiwibmVnYXRlIiwiZGF5TWF0Y2giLCJob3VyTWF0Y2giLCJtaW51dGVNYXRjaCIsInNlY29uZE1hdGNoIiwiZnJhY3Rpb25NYXRjaCIsImRheXNBc1NlY3MiLCJfcGFyc2VOdW1iZXIiLCJob3Vyc0FzU2VjcyIsIm1pbnNBc1NlY3MiLCJuZWdhdGl2ZVNlY3MiLCJjaGFyQXQiLCJfcGFyc2VGcmFjdGlvbiIsImV4IiwicGFyc2VkIiwibXVsdGlwbGllciIsImVycm9yVGV4dCIsInN1YnN0cmluZyIsInBhcnNlRmxvYXQiLCJfY3JlYXRlU2Vjb25kc05hbm9zIiwiX2NyZWF0ZU5lZ2F0ZURheXNIb3Vyc01pbnV0ZXNTZWNvbmRzTmFub3MiLCJuZWdhdGVkIiwiTkFOT1MiLCJpc1plcm8iLCJpc05lZ2F0aXZlIiwibmFubyIsIndpdGhTZWNvbmRzIiwid2l0aE5hbm9zIiwibmFub09mU2Vjb25kIiwiY2hlY2tWYWxpZEludFZhbHVlIiwicGx1c0R1cmF0aW9uIiwiZHVyYXRpb25Pck51bWJlciIsInVuaXRPck51bWJlciIsInBsdXNBbW91bnRVbml0IiwicGx1c1NlY29uZHNOYW5vcyIsImFtb3VudFRvQWRkIiwiREFZUyIsInBsdXNOYW5vcyIsIk1JQ1JPUyIsIk1JTExJUyIsInBsdXNNaWxsaXMiLCJwbHVzU2Vjb25kcyIsIm11bHRpcGxpZWRCeSIsInBsdXNEYXlzIiwiZGF5c1RvQWRkIiwicGx1c0hvdXJzIiwiaG91cnNUb0FkZCIsInBsdXNNaW51dGVzIiwibWludXRlc1RvQWRkIiwic2Vjb25kc1RvQWRkIiwibWlsbGlzVG9BZGQiLCJuYW5vc1RvQWRkIiwiZXBvY2hTZWMiLCJtaW51cyIsIm1pbnVzRHVyYXRpb24iLCJtaW51c0Ftb3VudFVuaXQiLCJzZWNzVG9TdWJ0cmFjdCIsIm5hbm9zVG9TdWJ0cmFjdCIsImFtb3VudFRvU3VidHJhY3QiLCJtaW51c0RheXMiLCJkYXlzVG9TdWJ0cmFjdCIsIm1pbnVzSG91cnMiLCJob3Vyc1RvU3VidHJhY3QiLCJtaW51c01pbnV0ZXMiLCJtaW51dGVzVG9TdWJ0cmFjdCIsIm1pbnVzU2Vjb25kcyIsInNlY29uZHNUb1N1YnRyYWN0IiwibWludXNNaWxsaXMiLCJtaWxsaXNUb1N1YnRyYWN0IiwibWludXNOYW5vcyIsIm11bHRpcGxpY2FuZCIsImRpdmlkZWRCeSIsImRpdmlzb3IiLCJzZWNzTW9kIiwiYWJzIiwidG9EYXlzIiwidG9Ib3VycyIsInRvTWludXRlcyIsInRvTWlsbGlzIiwicm91bmQiLCJ0b05hbm9zIiwidG90YWxOYW5vcyIsImNvbXBhcmVUbyIsIm90aGVyRHVyYXRpb24iLCJjbXAiLCJydmFsIiwibmFub1N0cmluZyIsInNsaWNlIiwiX2luaXQkbiIsIlllYXJDb25zdGFudHMiLCJfaW5pdCRtIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwiX1RlbXBvcmFsVW5pdCIsImVzdGltYXRlZER1cmF0aW9uIiwiX2R1cmF0aW9uIiwiRk9SRVZFUiIsImUyIiwiX2luaXQkbCIsIk1JTlVURVMiLCJIT1VSUyIsIkhBTEZfREFZUyIsIldFRUtTIiwiTU9OVEhTIiwiWUVBUlMiLCJERUNBREVTIiwiQ0VOVFVSSUVTIiwiTUlMTEVOTklBIiwiRVJBUyIsIlRlbXBvcmFsRmllbGQiLCJiYXNlVW5pdCIsInJhbmdlVW5pdCIsInJhbmdlIiwicmFuZ2VSZWZpbmVkQnkiLCJnZXRGcm9tIiwiYWRqdXN0SW50byIsIm5ld1ZhbHVlIiwiZGlzcGxheU5hbWUiLCJWYWx1ZVJhbmdlIiwibWluU21hbGxlc3QiLCJtaW5MYXJnZXN0IiwibWF4U21hbGxlc3QiLCJtYXhMYXJnZXN0IiwiX21pblNtYWxsZXN0IiwiX21pbkxhcmdlc3QiLCJfbWF4TGFyZ2VzdCIsIl9tYXhTbWFsbGVzdCIsImlzRml4ZWQiLCJtaW5pbXVtIiwibGFyZ2VzdE1pbmltdW0iLCJtYXhpbXVtIiwic21hbGxlc3RNYXhpbXVtIiwiaXNWYWxpZFZhbHVlIiwiY2hlY2tWYWxpZFZhbHVlIiwiZmllbGQiLCJpc1ZhbGlkSW50VmFsdWUiLCJpc0ludFZhbHVlIiwic3RyIiwiX1RlbXBvcmFsRmllbGQiLCJieU5hbWUiLCJmaWVsZE5hbWUiLCJwcm9wIiwiX2Jhc2VVbml0IiwiX3JhbmdlVW5pdCIsIl9yYW5nZSIsImRhdGVCYXNlZCIsIkRBWV9PRl9XRUVLIiwiQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9NT05USCIsIkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUiIsIkRBWV9PRl9NT05USCIsIkRBWV9PRl9ZRUFSIiwiRVBPQ0hfREFZIiwiQUxJR05FRF9XRUVLX09GX01PTlRIIiwiQUxJR05FRF9XRUVLX09GX1lFQVIiLCJNT05USF9PRl9ZRUFSIiwiUFJPTEVQVElDX01PTlRIIiwiWUVBUl9PRl9FUkEiLCJZRUFSIiwiRVJBIiwidGltZUJhc2VkIiwiTkFOT19PRl9EQVkiLCJNSUNST19PRl9TRUNPTkQiLCJNSUNST19PRl9EQVkiLCJNSUxMSV9PRl9TRUNPTkQiLCJNSUxMSV9PRl9EQVkiLCJTRUNPTkRfT0ZfTUlOVVRFIiwiU0VDT05EX09GX0RBWSIsIk1JTlVURV9PRl9IT1VSIiwiTUlOVVRFX09GX0RBWSIsIkhPVVJfT0ZfQU1QTSIsIkNMT0NLX0hPVVJfT0ZfQU1QTSIsIkhPVVJfT0ZfREFZIiwiQ0xPQ0tfSE9VUl9PRl9EQVkiLCJBTVBNX09GX0RBWSIsIl9pbml0JGsiLCJJTlNUQU5UX1NFQ09ORFMiLCJPRkZTRVRfU0VDT05EUyIsIlRlbXBvcmFsUXVlcmllcyIsInpvbmVJZCIsIlpPTkVfSUQiLCJjaHJvbm9sb2d5IiwiQ0hST05PIiwicHJlY2lzaW9uIiwiUFJFQ0lTSU9OIiwiem9uZSIsIlpPTkUiLCJvZmZzZXQiLCJPRkZTRVQiLCJsb2NhbERhdGUiLCJMT0NBTF9EQVRFIiwibG9jYWxUaW1lIiwiTE9DQUxfVElNRSIsIlRlbXBvcmFsQWNjZXNzb3IiLCJxdWVyeSIsIl9xdWVyeSIsInF1ZXJ5RnJvbSIsIlRlbXBvcmFsUXVlcnkiLCJfRW51bSIsImNyZWF0ZVRlbXBvcmFsUXVlcnkiLCJxdWVyeUZyb21GdW5jdGlvbiIsIkV4dGVuZGVkVGVtcG9yYWxRdWVyeSIsIl9UZW1wb3JhbFF1ZXJ5IiwiRGF5T2ZXZWVrIiwiX1RlbXBvcmFsQWNjZXNzb3IiLCJvcmRpbmFsIiwiX29yZGluYWwiLCJ2YWx1ZXMiLCJFTlVNUyIsInZhbHVlT2YiLCJkYXlPZldlZWsiLCJzdHlsZSIsImxvY2FsZSIsIl9pbml0JGoiLCJNT05EQVkiLCJUVUVTREFZIiwiV0VETkVTREFZIiwiVEhVUlNEQVkiLCJGUklEQVkiLCJTQVRVUkRBWSIsIlNVTkRBWSIsIkZST00iLCJNb250aCIsIl92YWx1ZSIsIm1vbnRocyIsIm5ld01vbnRoVmFsIiwibGVhcFllYXIiLCJGRUJSVUFSWSIsIkFQUklMIiwiSlVORSIsIlNFUFRFTUJFUiIsIk5PVkVNQkVSIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwiZmlyc3REYXlPZlllYXIiLCJsZWFwIiwiSkFOVUFSWSIsIk1BUkNIIiwiTUFZIiwiSlVMWSIsIkFVR1VTVCIsIk9DVE9CRVIiLCJERUNFTUJFUiIsImZpcnN0TW9udGhPZlF1YXJ0ZXIiLCJJc29DaHJvbm9sb2d5IiwiSU5TVEFOQ0UiLCJtb250aCIsIl9pbml0JGkiLCJQZXJpb2QiLCJ5ZWFycyIsIl95ZWFycyIsIl9tb250aHMiLCJfZGF5cyIsIm9mWWVhcnMiLCJvZk1vbnRocyIsIm9mV2Vla3MiLCJ3ZWVrcyIsImkiLCJ1bml0QW1vdW50Iiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIkxvY2FsRGF0ZSIsIl9wYXJzZSIsInllYXJNYXRjaCIsIm1vbnRoTWF0Y2giLCJ3ZWVrTWF0Y2giLCJ2YWwiLCJ3aXRoWWVhcnMiLCJ3aXRoTW9udGhzIiwid2l0aERheXMiLCJwbHVzWWVhcnMiLCJ5ZWFyc1RvQWRkIiwicGx1c01vbnRocyIsIm1vbnRoc1RvQWRkIiwibWludXNZZWFycyIsInllYXJzVG9TdWJ0cmFjdCIsIm1pbnVzTW9udGhzIiwibW9udGhzVG9TdWJ0cmFjdCIsInNjYWxhciIsIm5vcm1hbGl6ZWQiLCJ0b3RhbE1vbnRocyIsInRvVG90YWxNb250aHMiLCJzcGxpdFllYXJzIiwic3BsaXRNb250aHMiLCJvYmoiLCJidWYiLCJfaW5pdCRoIiwiUGFyc2VQb3NpdGlvbiIsIl9pbmRleCIsIl9lcnJvckluZGV4IiwiZ2V0SW5kZXgiLCJzZXRJbmRleCIsImdldEVycm9ySW5kZXgiLCJzZXRFcnJvckluZGV4IiwiRW51bU1hcCIsIl9tYXAiLCJwdXRBbGwiLCJvdGhlck1hcCIsImtleSIsImNvbnRhaW5zS2V5IiwiaGFzT3duUHJvcGVydHkiLCJ1bmRlZmluZWQiLCJwdXQiLCJzZXQiLCJyZXRhaW5BbGwiLCJrZXlMaXN0IiwibWFwIiwicmVtb3ZlIiwia2V5TmFtZSIsImtleVNldCIsImNsZWFyIiwiUmVzb2x2ZXJTdHlsZSIsIlNUUklDVCIsIlNNQVJUIiwiTEVOSUVOVCIsIlRlbXBvcmFsIiwiZmllbGRPclVuaXQiLCJfbWludXNBbW91bnQiLCJfbWludXNVbml0IiwiX3BsdXNVbml0IiwiX3BsdXNBbW91bnQiLCJlbmRUZW1wb3JhbCIsIl93aXRoIiwiYWRqdXN0ZXJPckZpZWxkIiwiX3dpdGhBZGp1c3RlciIsIl93aXRoRmllbGQiLCJhZGp1c3RlciIsIkNocm9ub0xvY2FsRGF0ZSIsIl9UZW1wb3JhbCIsIm9mRXBvY2hEYXkiLCJ0b0Vwb2NoRGF5IiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwiRGF0ZVRpbWVGb3JtYXR0ZXIiLCJTdHJpbmdVdGlsIiwic3RhcnRzV2l0aCIsInBhdHRlcm4iLCJpbmRleE9mIiwibGVuIiwiY2hyIiwiY2hhckNvZGVBdCIsIlpvbmVJZCIsInN5c3RlbURlZmF1bHQiLCJnZXRBdmFpbGFibGVab25lSWRzIiwib2ZPZmZzZXQiLCJwcmVmaXgiLCJpZCIsInJ1bGVzIiwiaXNGaXhlZE9mZnNldCIsIkluc3RhbnQiLCJFUE9DSCIsIlpvbmVSdWxlcyIsIkZpeGVkIiwiaW5zdGFudE9yTG9jYWxEYXRlVGltZSIsIm9mZnNldE9mSW5zdGFudCIsIm9mZnNldE9mTG9jYWxEYXRlVGltZSIsImluc3RhbnQiLCJvZmZzZXRPZkVwb2NoTWlsbGkiLCJlcG9jaE1pbGxpIiwibG9jYWxEYXRlVGltZSIsInZhbGlkT2Zmc2V0cyIsInRyYW5zaXRpb24iLCJzdGFuZGFyZE9mZnNldCIsImRheWxpZ2h0U2F2aW5ncyIsImlzRGF5bGlnaHRTYXZpbmdzIiwiaXNWYWxpZE9mZnNldCIsIm5leHRUcmFuc2l0aW9uIiwicHJldmlvdXNUcmFuc2l0aW9uIiwidHJhbnNpdGlvbnMiLCJ0cmFuc2l0aW9uUnVsZXMiLCJfWm9uZVJ1bGVzIiwiX29mZnNldCIsIl9wcm90bzIiLCJTRUNPTkRTX0NBQ0hFIiwiSURfQ0FDSEUiLCJab25lT2Zmc2V0IiwiX1pvbmVJZCIsInRvdGFsU2Vjb25kcyIsIl92YWxpZGF0ZVRvdGFsU2Vjb25kcyIsIl90b3RhbFNlY29uZHMiLCJfcnVsZXMiLCJfaWQiLCJfYnVpbGRJZCIsImFic1RvdGFsU2Vjb25kcyIsImFic0hvdXJzIiwiYWJzTWludXRlcyIsIk1JTlVURVNfUEVSX0hPVVIiLCJhYnNTZWNvbmRzIiwiTUFYX1NFQ09ORFMiLCJfdmFsaWRhdGUiLCJvZmZzZXRJZCIsImZpcnN0Iiwib2ZIb3Vyc01pbnV0ZXNTZWNvbmRzIiwicG9zIiwicHJlY2VkZWRCeUNvbG9uIiwiY2gxIiwiY2gyIiwib2ZIb3Vyc01pbnV0ZXMiLCJvZlRvdGFsU2Vjb25kcyIsIm9mVG90YWxNaW51dGVzIiwidG90YWxNaW51dGVzIiwidG90YWxTZWNzIiwiX2luaXQkZyIsIlVUQyIsIk1JTiIsIk1BWCIsIkRhdGVUaW1lQnVpbGRlciIsImR0YiIsIl9hZGRGaWVsZFZhbHVlIiwiZmllbGRWYWx1ZXMiLCJjaHJvbm8iLCJkYXRlIiwidGltZSIsImxlYXBTZWNvbmQiLCJleGNlc3NEYXlzIiwiZ2V0RmllbGRWYWx1ZTAiLCJvbGQiLCJfcHV0RmllbGRWYWx1ZTAiLCJyZXNvbHZlIiwicmVzb2x2ZXJTdHlsZSIsInJlc29sdmVyRmllbGRzIiwiX21lcmdlRGF0ZSIsIl9tZXJnZVRpbWUiLCJfcmVzb2x2ZVRpbWVJbmZlclplcm9lcyIsIl9yZXNvbHZlSW5zdGFudCIsIl9jaGVja0RhdGUiLCJyZXNvbHZlRGF0ZSIsIl9hZGRPYmplY3QiLCJ2YWwxIiwidmFsMiIsImNoIiwiX2NoIiwiYXAiLCJoYXAiLCJub2QiLCJjb2QiLCJsb2QiLCJzb2QiLCJtb2QiLCJsb3MiLCJjb3MiLCJfbm9zIiwiX2NvcyIsIl9sb3MiLCJob2QiLCJtb2giLCJzb20iLCJob2RWYWwiLCJtb2hWYWwiLCJzb21WYWwiLCJub3NWYWwiLCJfaG9kVmFsIiwib2ZOYW5vT2ZEYXkiLCJfZXhjZXNzRGF5cyIsIm9mU2Vjb25kT2ZEYXkiLCJfZXhjZXNzRGF5czIiLCJkYXRlT3JUaW1lIiwib2Zmc2V0U2VjcyIsImF0VGltZSIsImF0Wm9uZSIsIl9pbnN0YW50IiwiYnVpbGQiLCJ0eXBlIiwiRGF0ZVRpbWVQYXJzZUNvbnRleHQiLCJfY29uc3RydWN0b3JTZWxmIiwiX2NvbnN0cnVjdG9yRm9ybWF0dGVyIiwiX2NvbnN0cnVjdG9yUGFyYW0iLCJfY2FzZVNlbnNpdGl2ZSIsIl9zdHJpY3QiLCJfcGFyc2VkIiwiUGFyc2VkIiwic3ltYm9scyIsIl9sb2NhbGUiLCJfc3ltYm9scyIsIl9vdmVycmlkZUNocm9ub2xvZ3kiLCJkZWNpbWFsU3R5bGUiLCJfb3ZlcnJpZGVab25lIiwiY29weSIsImlzU3RyaWN0Iiwic2V0U3RyaWN0Iiwic3RyaWN0Iiwic2V0TG9jYWxlIiwic3RhcnRPcHRpb25hbCIsInB1c2giLCJjdXJyZW50UGFyc2VkIiwiZW5kT3B0aW9uYWwiLCJzdWNjZXNzZnVsIiwic3BsaWNlIiwiaXNDYXNlU2Vuc2l0aXZlIiwic2V0Q2FzZVNlbnNpdGl2ZSIsImNhc2VTZW5zaXRpdmUiLCJzdWJTZXF1ZW5jZUVxdWFscyIsImNzMSIsIm9mZnNldDEiLCJjczIiLCJvZmZzZXQyIiwidG9Mb3dlckNhc2UiLCJjaGFyRXF1YWxzIiwiY2hhckVxdWFsc0lnbm9yZUNhc2UiLCJjMSIsImMyIiwic2V0UGFyc2VkRmllbGQiLCJlcnJvclBvcyIsInN1Y2Nlc3NQb3MiLCJjdXJyZW50UGFyc2VkRmllbGRWYWx1ZXMiLCJzZXRQYXJzZWRab25lIiwiZ2V0UGFyc2VkIiwidG9QYXJzZWQiLCJzZXRQYXJzZWRMZWFwU2Vjb25kIiwiZ2V0RWZmZWN0aXZlQ2hyb25vbG9neSIsImRhdGVUaW1lUGFyc2VDb250ZXh0IiwiY2xvbmVkIiwidG9CdWlsZGVyIiwiYnVpbGRlciIsIm92ZXJyaWRlWm9uZSIsIkRhdGVUaW1lUHJpbnRDb250ZXh0IiwibG9jYWxlT3JGb3JtYXR0ZXIiLCJfdGVtcG9yYWwiLCJhZGp1c3QiLCJfb3B0aW9uYWwiLCJnZXRWYWx1ZVF1ZXJ5IiwiZ2V0VmFsdWUiLCJzZXREYXRlVGltZSIsIklzb0ZpZWxkcyIsIlFVQVJURVJfREFZUyIsIkZpZWxkIiwiX2lzSXNvIiwiX2dldFdlZWtSYW5nZUJ5TG9jYWxEYXRlIiwid2J5IiwiX2dldFdlZWtCYXNlZFllYXIiLCJfZ2V0V2Vla1JhbmdlQnlZZWFyIiwiaXNMZWFwWWVhciIsIl9nZXRXZWVrIiwiZG93MCIsImRveTAiLCJkYXlPZlllYXIiLCJkb3lUaHUwIiwiYWxpZ25lZFdlZWsiLCJmaXJzdFRodURveTAiLCJmaXJzdE1vbkRveTAiLCJ3aXRoRGF5T2ZZZWFyIiwid2VlayIsInllYXIiLCJkb3kiLCJkb3ciLCJfZG93IiwiREFZX09GX1FVQVJURVJfRklFTEQiLCJfRmllbGQiLCJRVUFSVEVSX1lFQVJTIiwicW95IiwiUVVBUlRFUl9PRl9ZRUFSIiwibW95IiwiY3VyVmFsdWUiLCJwYXJ0aWFsVGVtcG9yYWwiLCJ5ZWFyTG9uZyIsInFveUxvbmciLCJkb3EiLCJEQVlfT0ZfUVVBUlRFUiIsIl9xb3kiLCJtYXgiLCJRVUFSVEVSX09GX1lFQVJfRklFTEQiLCJfRmllbGQyIiwiX3Byb3RvMyIsIldFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSX0ZJRUxEIiwiX0ZpZWxkMyIsIl9wcm90bzQiLCJXRUVLX0JBU0VEX1lFQVJTIiwid2J5TG9uZyIsIldFRUtfQkFTRURfWUVBUiIsImRvd0xvbmciLCJ3b3dieSIsIldFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSIiwicGx1c1dlZWtzIiwiX2RvdzIiLCJ0ZW1wIiwiV0VFS19CQVNFRF9ZRUFSX0ZJRUxEIiwiX0ZpZWxkNCIsIl9wcm90bzUiLCJuZXdXYnkiLCJyZXNvbHZlZCIsIlVuaXQiLCJfcHJvdG82IiwiYWRkZWQiLCJfaW5pdCRmIiwiaXNvV2Vla09mV2Vla3llYXIiLCJpc29XZWVreWVhciIsIkRlY2ltYWxTdHlsZSIsInplcm9DaGFyIiwicG9zaXRpdmVTaWduQ2hhciIsIm5lZ2F0aXZlU2lnbkNoYXIiLCJkZWNpbWFsUG9pbnRDaGFyIiwiX3plcm9EaWdpdCIsIl96ZXJvRGlnaXRDaGFyQ29kZSIsIl9wb3NpdGl2ZVNpZ24iLCJfbmVnYXRpdmVTaWduIiwiX2RlY2ltYWxTZXBhcmF0b3IiLCJwb3NpdGl2ZVNpZ24iLCJ3aXRoUG9zaXRpdmVTaWduIiwibmVnYXRpdmVTaWduIiwid2l0aE5lZ2F0aXZlU2lnbiIsInplcm9EaWdpdCIsIndpdGhaZXJvRGlnaXQiLCJkZWNpbWFsU2VwYXJhdG9yIiwid2l0aERlY2ltYWxTZXBhcmF0b3IiLCJjb252ZXJ0VG9EaWdpdCIsImNoYXIiLCJjb252ZXJ0TnVtYmVyVG9JMThOIiwibnVtZXJpY1RleHQiLCJkaWZmIiwiY29udmVydGVkVGV4dCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImF2YWlsYWJsZUxvY2FsZXMiLCJTVEFOREFSRCIsIlNpZ25TdHlsZSIsInBvc2l0aXZlIiwiZml4ZWRXaWR0aCIsIk5PUk1BTCIsIkFMV0FZUyIsIkVYQ0VFRFNfUEFEIiwiTkVWRVIiLCJOT1RfTkVHQVRJVkUiLCJUZXh0U3R5bGUiLCJpc1N0YW5kYWxvbmUiLCJGVUxMX1NUQU5EQUxPTkUiLCJTSE9SVF9TVEFOREFMT05FIiwiTkFSUk9XX1NUQU5EQUxPTkUiLCJhc1N0YW5kYWxvbmUiLCJGVUxMIiwiU0hPUlQiLCJOQVJST1ciLCJhc05vcm1hbCIsIkNoYXJMaXRlcmFsUHJpbnRlclBhcnNlciIsImxpdGVyYWwiLCJfbGl0ZXJhbCIsInByaW50IiwiY29udGV4dCIsImFwcGVuZCIsInBvc2l0aW9uIiwiQ29tcG9zaXRlUHJpbnRlclBhcnNlciIsInByaW50ZXJQYXJzZXJzIiwib3B0aW9uYWwiLCJfcHJpbnRlclBhcnNlcnMiLCJ3aXRoT3B0aW9uYWwiLCJwcCIsInNldExlbmd0aCIsIl9wcCIsIkZyYWN0aW9uUHJpbnRlclBhcnNlciIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJkZWNpbWFsUG9pbnQiLCJmcmFjdGlvbiIsImNvbnZlcnRUb0ZyYWN0aW9uIiwib3V0cHV0U2NhbGUiLCJtaW4iLCJzdWJzdHIiLCJlZmZlY3RpdmVNaW4iLCJlZmZlY3RpdmVNYXgiLCJtaW5FbmRQb3MiLCJtYXhFbmRQb3MiLCJ0b3RhbCIsImRpZ2l0IiwibW92ZUxlZnQiLCJzY2FsZSIsInBvdyIsImNvbnZlcnRGcm9tRnJhY3Rpb24iLCJfbWluIiwiX3NjYWxlZCIsImRlY2ltYWwiLCJNQVhfV0lEVEgkMSIsIkVYQ0VFRF9QT0lOVFMiLCJOdW1iZXJQcmludGVyUGFyc2VyIiwic2lnblN0eWxlIiwic3Vic2VxdWVudFdpZHRoIiwiX2ZpZWxkIiwiX21pbldpZHRoIiwiX21heFdpZHRoIiwiX3NpZ25TdHlsZSIsIl9zdWJzZXF1ZW50V2lkdGgiLCJ3aXRoRml4ZWRXaWR0aCIsIndpdGhTdWJzZXF1ZW50V2lkdGgiLCJfaXNGaXhlZFdpZHRoIiwiY29udGV4dFZhbHVlIiwiX2dldFZhbHVlIiwic2lnbiIsIm5lZ2F0aXZlIiwiZWZmTWluV2lkdGgiLCJlZmZNYXhXaWR0aCIsInBhc3MiLCJwYXJzZUxlbiIsIl9wYXJzZUxlbiIsIl9zZXRWYWx1ZSIsIlJlZHVjZWRQcmludGVyUGFyc2VyIiwiX051bWJlclByaW50ZXJQYXJzZXIiLCJ3aWR0aCIsImJhc2VWYWx1ZSIsImJhc2VEYXRlIiwiX2Jhc2VWYWx1ZSIsIl9iYXNlRGF0ZSIsImFic1ZhbHVlIiwibGFzdFBhcnQiLCJiYXNlUGFydCIsImlzRml4ZWRXaWR0aCIsIlBBVFRFUk5TIiwiT2Zmc2V0SWRQcmludGVyUGFyc2VyIiwibm9PZmZzZXRUZXh0IiwiX2NoZWNrUGF0dGVybiIsImJ1ZlBvcyIsIm91dHB1dCIsImFwcGVuZENoYXIiLCJub09mZnNldExlbiIsImFycmF5IiwiYXJyYXlJbmRleCIsInBhcnNlVGV4dCIsInJlcXVpcmVkIiwiY29udmVydGVkIiwicmVwbGFjZSIsIklOU1RBTkNFX0lEIiwiUGFkUHJpbnRlclBhcnNlckRlY29yYXRvciIsInByaW50ZXJQYXJzZXIiLCJwYWRXaWR0aCIsInBhZENoYXIiLCJfcHJpbnRlclBhcnNlciIsIl9wYWRXaWR0aCIsIl9wYWRDaGFyIiwicHJlTGVuIiwiaW5zZXJ0IiwiZW5kUG9zIiwicmVzdWx0UG9zIiwiU2V0dGluZ3NQYXJzZXIiLCJTRU5TSVRJVkUiLCJJTlNFTlNJVElWRSIsIlN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyIiwiWm9uZVJ1bGVzUHJvdmlkZXIiLCJnZXRSdWxlcyIsIlpvbmVSZWdpb24iLCJvZklkIiwiWm9uZUlkUHJpbnRlclBhcnNlciIsImRlc2NyaXB0aW9uIiwibmV4dENoYXIiLCJuZXdDb250ZXh0IiwibmV4dE5leHRDaGFyIiwiX3BhcnNlUHJlZml4ZWRPZmZzZXQiLCJhdmFpbGFibGVab25lSWRzIiwiem9uZUlkVHJlZSIsInNpemUiLCJab25lSWRUcmVlIiwiY3JlYXRlVHJlZU1hcCIsIm1heFBhcnNlTGVuZ3RoIiwidHJlZU1hcCIsInBhcnNlZFpvbmVJZCIsInBhcnNlTGVuZ3RoIiwicGFyc2VkU3ViWm9uZUlkIiwiaXNMZWFmIiwicHJlZml4UG9zIiwidG9VcHBlckNhc2UiLCJzb3J0ZWRab25lSWRzIiwic29ydCIsIlpvbmVJZFRyZWVNYXAiLCJhZGQiLCJfdHJlZU1hcCIsImlkTGVuZ3RoIiwic3ViWm9uZUlkIiwic3ViVHJlZU1hcCIsIk1BWF9XSURUSCIsIkRhdGVUaW1lRm9ybWF0dGVyQnVpbGRlciIsIl9hY3RpdmUiLCJfcGFyZW50IiwiX3BhZE5leHRXaWR0aCIsIl9wYWROZXh0Q2hhciIsIl92YWx1ZVBhcnNlckluZGV4IiwiX29mIiwicGFyZW50IiwiZHRGb3JtYXR0ZXJCdWlsZGVyIiwicGFyc2VDYXNlU2Vuc2l0aXZlIiwiX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlciIsInBhcnNlQ2FzZUluc2Vuc2l0aXZlIiwicGFyc2VTdHJpY3QiLCJwYXJzZUxlbmllbnQiLCJwYXJzZURlZmF1bHRpbmciLCJfYXBwZW5kSW50ZXJuYWwiLCJEZWZhdWx0aW5nUGFyc2VyIiwiYXBwZW5kVmFsdWUiLCJfYXBwZW5kVmFsdWUxIiwiX2FwcGVuZFZhbHVlMiIsIl9hcHBlbmRWYWx1ZTQiLCJfYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyIiwiYXBwZW5kVmFsdWVSZWR1Y2VkIiwiX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VEYXRlIiwiX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VWYWx1ZSIsImFjdGl2ZVZhbHVlUGFyc2VyIiwiYmFzZVBQIiwiYXBwZW5kRnJhY3Rpb24iLCJhcHBlbmRJbnN0YW50IiwiZnJhY3Rpb25hbERpZ2l0cyIsIkluc3RhbnRQcmludGVyUGFyc2VyIiwiYXBwZW5kT2Zmc2V0SWQiLCJhcHBlbmRPZmZzZXQiLCJhcHBlbmRab25lSWQiLCJhcHBlbmRQYXR0ZXJuIiwiX3BhcnNlUGF0dGVybiIsImFwcGVuZFpvbmVUZXh0IiwiYXBwZW5kVGV4dCIsImFwcGVuZExvY2FsaXplZE9mZnNldCIsImFwcGVuZFdlZWtGaWVsZCIsIkZJRUxEX01BUCIsImN1ciIsInN0YXJ0IiwiY291bnQiLCJwYWQiLCJwYWROZXh0IiwiX3BhcnNlRmllbGQiLCJ6ZXJvIiwiX3N0YXJ0IiwiYXBwZW5kTGl0ZXJhbCIsIm9wdGlvbmFsU3RhcnQiLCJvcHRpb25hbEVuZCIsIkJBU0VfREFURSIsIl9wYWROZXh0MSIsIl9wYWROZXh0MiIsImNwcCIsIl90b1ByaW50ZXJQYXJzZXIiLCJ0b0Zvcm1hdHRlciIsIlNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTIiwiU0VDT05EU18wMDAwX1RPXzE5NzAiLCJpblNlY3MiLCJpbk5hbm9zIiwiaW5TZWMiLCJpbk5hbm8iLCJ6ZXJvU2VjcyIsImhpIiwibG8iLCJsZHQiLCJMb2NhbERhdGVUaW1lIiwib2ZFcG9jaFNlY29uZCIsInNlY29uZCIsIl96ZXJvU2VjcyIsIl9oaSIsIl9sbyIsIl9sZHQiLCJkaXYiLCJtaW5EaWdpdHMiLCJtYXhEaWdpdHMiLCJwYXJzZXIiLCJJU09fTE9DQUxfREFURSIsInllYXJQYXJzZWQiLCJkYXkiLCJob3VyIiwic2VjVmFsIiwibmFub1ZhbCIsInNlYyIsImluc3RhbnRTZWNzIiwidG9FcG9jaFNlY29uZCIsIl9pbml0JGUiLCJTdHJpbmdCdWlsZGVyIiwiX3N0ciIsImVuZCIsInBhcnNlZEV4Y2Vzc0RheXMiLCJQQVJTRURfRVhDRVNTX0RBWVMiLCJwYXJzZWRMZWFwU2Vjb25kIiwiUEFSU0VEX0xFQVBfU0VDT05EIiwib2ZQYXR0ZXJuIiwiX2RlY2ltYWxTdHlsZSIsIl9yZXNvbHZlclN0eWxlIiwiX3Jlc29sdmVyRmllbGRzIiwiX2Nocm9ubyIsIl96b25lIiwid2l0aENocm9ub2xvZ3kiLCJ3aXRoTG9jYWxlIiwid2l0aFJlc29sdmVyU3R5bGUiLCJfZm9ybWF0VG8iLCJhcHBlbmRhYmxlIiwicGFyc2UxIiwicGFyc2UyIiwiX3BhcnNlVG9CdWlsZGVyIiwiX2NyZWF0ZUVycm9yIiwiYWJiciIsIl9wYXJzZVVucmVzb2x2ZWQwIiwicGFyc2VVbnJlc29sdmVkIiwiX2luaXQkZCIsIklTT19MT0NBTF9USU1FIiwiSVNPX0xPQ0FMX0RBVEVfVElNRSIsIklTT19JTlNUQU5UIiwiSVNPX09GRlNFVF9EQVRFX1RJTUUiLCJJU09fWk9ORURfREFURV9USU1FIiwiQkFTSUNfSVNPX0RBVEUiLCJJU09fT0ZGU0VUX0RBVEUiLCJJU09fT0ZGU0VUX1RJTUUiLCJJU09fT1JESU5BTF9EQVRFIiwiSVNPX1dFRUtfREFURSIsIklTT19EQVRFIiwiSVNPX1RJTUUiLCJJU09fREFURV9USU1FIiwiTW9udGhEYXkiLCJub3ciLCJ6b25lSWRPckNsb2NrIiwibm93MCIsIm5vd1pvbmVJZCIsIm5vd0Nsb2NrIiwiQ2xvY2siLCJzeXN0ZW1EZWZhdWx0Wm9uZSIsInN5c3RlbSIsImNsb2NrIiwiZGF5T2ZNb250aCIsIm1vbnRoT3JOdW1iZXIiLCJvZk1vbnRoTnVtYmVyIiwib2ZOdW1iZXJOdW1iZXIiLCJwYXJzZVN0cmluZyIsInBhcnNlU3RyaW5nRm9ybWF0dGVyIiwiUEFSU0VSJDIiLCJfbW9udGgiLCJfZGF5IiwibW9udGhWYWx1ZSIsImlzVmFsaWRZZWFyIiwiWWVhciIsImlzTGVhcCIsIndpdGhNb250aCIsIndpdGhEYXlPZk1vbnRoIiwiYXRZZWFyIiwiaXNBZnRlciIsImlzQmVmb3JlIiwiX2luaXQkYyIsIlllYXJNb250aCIsIm9mTnVtYmVyTW9udGgiLCJQQVJTRVIkMSIsIl95ZWFyIiwiaXNTdXBwb3J0ZWRGaWVsZCIsImlzU3VwcG9ydGVkVW5pdCIsIl9nZXRQcm9sZXB0aWNNb250aCIsImlzVmFsaWREYXkiLCJsZW5ndGhPZk1vbnRoIiwibGVuZ3RoT2ZZZWFyIiwiZiIsIndpdGhZZWFyIiwibmV3WWVhciIsIm1vbnRoQ291bnQiLCJjYWxjTW9udGhzIiwibmV3TW9udGgiLCJtb250aHNVbnRpbCIsImF0RGF5IiwiYXRFbmRPZk1vbnRoIiwiX2luaXQkYiIsImlzb1llYXIiLCJwYXJzZVRleHRGb3JtYXR0ZXIiLCJQQVJTRVIiLCJpc1ZhbGlkTW9udGhEYXkiLCJtb250aERheSIsIm9mWWVhckRheSIsImF0TW9udGgiLCJhdE1vbnRoTW9udGgiLCJhdE1vbnRoTnVtYmVyIiwiYXRNb250aERheSIsInllYXJzVW50aWwiLCJfaW5pdCRhIiwiVGVtcG9yYWxBZGp1c3RlciIsIlRlbXBvcmFsQWRqdXN0ZXJzIiwiZmlyc3REYXlPZk1vbnRoIiwiSW1wbCIsIkZJUlNUX0RBWV9PRl9NT05USCIsImxhc3REYXlPZk1vbnRoIiwiTEFTVF9EQVlfT0ZfTU9OVEgiLCJmaXJzdERheU9mTmV4dE1vbnRoIiwiRklSU1RfREFZX09GX05FWFRfTU9OVEgiLCJGSVJTVF9EQVlfT0ZfWUVBUiIsImxhc3REYXlPZlllYXIiLCJMQVNUX0RBWV9PRl9ZRUFSIiwiZmlyc3REYXlPZk5leHRZZWFyIiwiRklSU1RfREFZX09GX05FWFRfWUVBUiIsImZpcnN0SW5Nb250aCIsIkRheU9mV2Vla0luTW9udGgiLCJsYXN0SW5Nb250aCIsImRheU9mV2Vla0luTW9udGgiLCJuZXh0IiwiUmVsYXRpdmVEYXlPZldlZWsiLCJuZXh0T3JTYW1lIiwicHJldmlvdXMiLCJwcmV2aW91c09yU2FtZSIsIl9UZW1wb3JhbEFkanVzdGVyIiwiX1RlbXBvcmFsQWRqdXN0ZXIyIiwiX3RoaXMyIiwiX2Rvd1ZhbHVlIiwiY3VyRG93IiwiZG93RGlmZiIsIl90ZW1wIiwiX2N1ckRvdyIsImRheXNEaWZmIiwiX1RlbXBvcmFsQWRqdXN0ZXIzIiwicmVsYXRpdmUiLCJfdGhpczMiLCJfcmVsYXRpdmUiLCJjYWxEb3ciLCJfZGF5c0RpZmYiLCJwcm9sZXB0aWNZZWFyIiwiX3VwZGF0ZVJlc29sdmVNYXAiLCJjdXJyZW50IiwicHJvbGVwdGljTW9udGgiLCJ5b2VMb25nIiwiZXJhIiwiZG9tIiwiX3kiLCJfeTIiLCJfZGF5czIiLCJhdyIsImFkIiwiX3kzIiwiX3dlZWtzIiwiX2RheXMzIiwiX2F3IiwiX2RhdGUiLCJfaW5pdCQ5IiwiT2Zmc2V0VGltZSIsIk9mZnNldERhdGVUaW1lIiwidG9PZmZzZXRUaW1lIiwiY2xvY2tPclpvbmUiLCJfbm93Iiwib2ZJbnN0YW50Iiwib2ZUaW1lQW5kT2Zmc2V0Iiwib2ZOdW1iZXJzIiwibWludXRlIiwic2Vjc09mRGF5IiwiZXBvY2hTZWNvbmQiLCJfdGltZSIsInRvTmFub09mRGF5IiwiYXREYXRlIiwiX3RvRXBvY2hOYW5vIiwiaXNFcXVhbCIsIl93aXRoTG9jYWxUaW1lT2Zmc2V0IiwidG9Mb2NhbFRpbWUiLCJ0cnVuY2F0ZWRUbyIsIm5hbm9zVW50aWwiLCJOQU5PU19QRVJfTUlOVVRFIiwiTkFOT1NfUEVSX0hPVVIiLCJ3aXRoSG91ciIsIndpdGhNaW51dGUiLCJ3aXRoU2Vjb25kIiwid2l0aE5hbm8iLCJ3aXRoT2Zmc2V0U2FtZUluc3RhbnQiLCJkaWZmZXJlbmNlIiwiYWRqdXN0ZWQiLCJ3aXRoT2Zmc2V0U2FtZUxvY2FsIiwib2Zmc2V0TmFub3MiLCJjb21wYXJlIiwiX2luaXQkOCIsIkNocm9ub1pvbmVkRGF0ZVRpbWUiLCJ0b0xvY2FsRGF0ZSIsInRvSW5zdGFudCIsImVwb2NoRGF5IiwidG9TZWNvbmRPZkRheSIsInRvTG9jYWxEYXRlVGltZSIsInN0cmNtcCIsInRoaXNFcG9jaFNlYyIsIm90aGVyRXBvY2hTZWMiLCJab25lZERhdGVUaW1lIiwiX0Nocm9ub1pvbmVkRGF0ZVRpbWUiLCJvZjIiLCJvZjMiLCJvZjgiLCJvZkxvY2FsIiwiZHQiLCJwcmVmZXJyZWRPZmZzZXQiLCJ0cmFucyIsIm9mZnNldEFmdGVyIiwic29tZSIsInZhbGlkT2Zmc2V0Iiwib2ZJbnN0YW50MiIsIm9mSW5zdGFudDMiLCJvZlN0cmljdCIsImlzR2FwIiwib2ZMZW5pZW50IiwiemR0IiwiX2Zyb20iLCJfX2Zyb20iLCJfZGF0ZVRpbWUiLCJfcmVzb2x2ZUxvY2FsIiwibmV3RGF0ZVRpbWUiLCJfcmVzb2x2ZU9mZnNldCIsIndpdGhFYXJsaWVyT2Zmc2V0QXRPdmVybGFwIiwiaXNPdmVybGFwIiwiZWFybGllck9mZnNldCIsIm9mZnNldEJlZm9yZSIsIndpdGhMYXRlck9mZnNldEF0T3ZlcmxhcCIsImxhdGVyT2Zmc2V0Iiwid2l0aFpvbmVTYW1lTG9jYWwiLCJ3aXRoWm9uZVNhbWVJbnN0YW50Iiwid2l0aEZpeGVkT2Zmc2V0Wm9uZSIsIm1pbnVzV2Vla3MiLCJ0b09mZnNldERhdGVUaW1lIiwiX2luaXQkNyIsIl8iLCJvZkRhdGVUaW1lIiwib2ZEYXRlQW5kVGltZSIsImF0Wm9uZVNhbWVJbnN0YW50IiwiYXRab25lU2ltaWxhckxvY2FsIiwidG9ab25lZERhdGVUaW1lIiwiX3dpdGhEYXRlVGltZU9mZnNldCIsIl9pbml0JDYiLCJhdE9mZnNldCIsIkRBWVNfUEVSX0NZQ0xFIiwiREFZU18wMDAwX1RPXzE5NzAiLCJfQ2hyb25vTG9jYWxEYXRlIiwibW9udGhFbmQiLCJhZGp1c3RDeWNsZXMiLCJkb3lFc3QiLCJ5ZWFyRXN0IiwiemVyb0RheSIsIm1hcmNoRG95MCIsIm1hcmNoTW9udGgwIiwiX3Jlc29sdmVQcmV2aW91c1ZhbGlkIiwiX2dldDAiLCJfcHJvbGVwdGljTW9udGgiLCJtIiwid2Vla3NUb0FkZCIsIm1qRGF5Iiwid2Vla3NUb1N1YnRyYWN0IiwicDEiLCJwMiIsInVudGlsMSIsInVudGlsMiIsImRheXNVbnRpbCIsIl9tb250aHNVbnRpbCIsInBhY2tlZDEiLCJwYWNrZWQyIiwiY2FsY0RhdGUiLCJhdFRpbWUxIiwiYXRUaW1lNCIsIl9hdFRpbWVPZmZzZXRUaW1lIiwiYXRTdGFydE9mRGF5IiwiX2F0U3RhcnRPZkRheVdpdGhab25lIiwiTUlETklHSFQiLCJkYXRlVGltZUFmdGVyIiwiX2NvbXBhcmVUbzAiLCJvdGhlckRhdGUiLCJ5ZWFyVmFsdWUiLCJkYXlWYWx1ZSIsImRheVN0cmluZyIsIm1vbnRoU3RyaW5nIiwieWVhclN0cmluZyIsImFic1llYXIiLCJfaW5pdCQ1IiwiRVBPQ0hfMCIsIkNocm9ub0xvY2FsRGF0ZVRpbWUiLCJfQ2hyb25vTG9jYWxEYXRlVGltZSIsIl9vZkVwb2NoTWlsbGlzIiwibG9jYWxTZWNvbmQiLCJsb2NhbEVwb2NoRGF5IiwiX3dpdGhEYXRlVGltZSIsIm5ld0RhdGUiLCJuZXdUaW1lIiwiTUlDUk9TX1BFUl9EQVkiLCJNSUxMSVNfUEVSX0RBWSIsIl9wbHVzV2l0aE92ZXJmbG93IiwidG90RGF5cyIsIk5BTk9TX1BFUl9EQVkiLCJNSU5VVEVTX1BFUl9EQVkiLCJIT1VSU19QRVJfREFZIiwidG90TmFub3MiLCJjdXJOb0QiLCJuZXdOb0QiLCJ0aW1lVW50aWwiLCJlbmRUaW1lIiwiX2luaXQkNCIsInNlY29uZE9mRGF5IiwibmFub09mRGF5IiwiX2hvdXIiLCJfbWludXRlIiwiX3NlY29uZCIsIl9uYW5vT2ZTZWNvbmQiLCJfbmFubyIsImhhbSIsInVuaXREdXIiLCJkdXIiLCJuZXdIb3VyIiwibW9mZCIsIm5ld01vZmQiLCJuZXdNaW51dGUiLCJzb2ZkIiwibmV3U29mZCIsIm5ld1NlY29uZCIsIm5vZmQiLCJuZXdOb2ZkIiwibmV3TmFubyIsImhvdXJWYWx1ZSIsIm1pbnV0ZVZhbHVlIiwic2Vjb25kVmFsdWUiLCJuYW5vVmFsdWUiLCJfaW5pdCQzIiwiTk9PTiIsIk5BTk9TX1BFUl9NSUxMSSIsInN5c3RlbVVUQyIsIm9mRXBvY2hNaWxsaSIsIm9mRXBvY2hNaWNybyIsImVwb2NoTWljcm8iLCJNSU5fU0VDT05EUyIsIm52YWwiLCJfbnZhbCIsInBsdXNNaWNyb3MiLCJfcGx1cyIsIm1pY3Jvc1RvQWRkIiwibWludXNNaWNyb3MiLCJtaWNyb3NUb1N1YnRyYWN0IiwiX25hbm9zVW50aWwiLCJfbWljcm9zVW50aWwiLCJ0b0Vwb2NoTWlsbGkiLCJfc2Vjb25kc1VudGlsIiwic2Vjc0RpZmYiLCJ0b3RhbE1pY3JvcyIsIm5hbm9zRGlmZiIsIm90aGVySW5zdGFudCIsIl9pbml0JDIiLCJTeXN0ZW1DbG9jayIsImZpeGVkIiwiZml4ZWRJbnN0YW50IiwiRml4ZWRDbG9jayIsImJhc2VDbG9jayIsIk9mZnNldENsb2NrIiwid2l0aFpvbmUiLCJfQ2xvY2siLCJEYXRlIiwiZ2V0VGltZSIsIl9DbG9jazIiLCJfem9uZUlkIiwiX0Nsb2NrMyIsIl9iYXNlQ2xvY2siLCJab25lT2Zmc2V0VHJhbnNpdGlvbiIsIl90cmFuc2l0aW9uIiwiX29mZnNldEJlZm9yZSIsIl9vZmZzZXRBZnRlciIsImRhdGVUaW1lQmVmb3JlIiwiZHVyYXRpb25TZWNvbmRzIiwiZCIsIl9pbml0JDEiLCJTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzIiwib2Zmc2V0SW5NaW51dGVzIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJvZmZzZXRJbk1pbnV0ZXNCZWZvcmVQb3NzaWJsZVRyYW5zaXRpb24iLCJlcG9jaE1pbGxpU3lzdGVtWm9uZSIsIm9mZnNldEluTWludXRlc0FmdGVyUG9zc2libGVUcmFuc2l0aW9uIiwiX3Rocm93Tm90U3VwcG9ydGVkIiwiU3lzdGVtRGVmYXVsdFpvbmVJZCIsIlpvbmVJZEZhY3RvcnkiLCJTWVNURU1fREVGQVVMVF9aT05FX0lEX0lOU1RBTkNFIiwiX2luaXQiLCJTWVNURU0iLCJpc0luaXQiLCJUb05hdGl2ZUpzQ29udmVydGVyIiwiem9uZWREYXRlVGltZSIsInRvRGF0ZSIsImNvbnZlcnQiLCJuYXRpdmVKcyIsImJpbmRVc2UiLCJqc0pvZGEiLCJ1c2VkIiwidXNlIiwiZm4iLCJqc0pvZGFFeHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@js-joda/core/dist/js-joda.esm.js\n");

/***/ })

};
;